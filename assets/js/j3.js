(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject2 = require("./JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Unique ID generator for jThree objects.
 * @type {[type]}
 */

var JThreeID = function (_JThreeObject) {
  _inherits(JThreeID, _JThreeObject);

  function JThreeID() {
    _classCallCheck(this, JThreeID);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(JThreeID).apply(this, arguments));
  }

  _createClass(JThreeID, null, [{
    key: "getUniqueRandom",

    /**
     * Generate random string
     * @param  {number} length length of random string
     * @return {string}        generated string
     */
    value: function getUniqueRandom(length) {
      var random = "";
      for (var i = 0; i < length; i++) {
        random += JThreeID._randomChars.charAt(Math.random() * JThreeID._randomChars.length);
      }
      return random;
    }
  }]);

  return JThreeID;
}(_JThreeObject3.default);
/**
 * Random characters being used for generating unique id.
 * @type {string}
 */


JThreeID._randomChars = "abcdefghijklmnopqrstuvwxyzABCDEFHIJKLMNOPQRSTUVWXYZ1234567890-";
exports.default = JThreeID;

},{"./JThreeObject":3}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var JThreeLogger = function () {
    function JThreeLogger() {
        _classCallCheck(this, JThreeLogger);
    }

    _createClass(JThreeLogger, null, [{
        key: "sectionLog",
        value: function sectionLog(sectionName, log) {
            console.log.apply(console, JThreeLogger._sectionLogParams(sectionName, log));
        }
    }, {
        key: "sectionWarn",
        value: function sectionWarn(sectionName, log) {
            console.warn.apply(console, JThreeLogger._sectionLogParams(sectionName, log));
        }
    }, {
        key: "sectionError",
        value: function sectionError(sectionName, log) {
            console.error.apply(console, JThreeLogger._sectionLogParams(sectionName, log));
        }
    }, {
        key: "sectionInfo",
        value: function sectionInfo(sectionName, log) {
            console.info.apply(console, JThreeLogger._sectionLogParams(sectionName, log));
        }
    }, {
        key: "sectionLongLog",
        value: function sectionLongLog(sectionName, log) {
            // var params = JThreeLogger.sectionLogParams(sectionName,"");
            // var logLines = log.split('\n');
            // var entireLog="\n";
            // for (let i = 0; i < logLines.length; i++) {
            //     var line = `%c ${i+1} %c▶%c ${logLines[i]}\n`;
            //     params.push("background-color:#344F66;color:white;","color:#344F66;","");
            //     entireLog+=line;
            // }
            // params[0]+=entireLog;
            // console.log.apply(console,params);
        }
    }, {
        key: "_sectionLogParams",
        value: function _sectionLogParams(sectionName, log) {
            return ["%c jThree v3 %c▶ " + sectionName + " %c▶%c " + log, "background-color:#344F66;color:white;", "color:#344F66;background-color:#D1D4D7;", "color:#D1D4D7;", ""];
        }
    }]);

    return JThreeLogger;
}();

exports.default = JThreeLogger;

},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JsHack = require("./JsHack");

var _JsHack2 = _interopRequireDefault(_JsHack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Most based object for any jthree related classes.
 * @type {[type]}
 */

var JThreeObject = function () {
  function JThreeObject() {
    _classCallCheck(this, JThreeObject);
  }

  _createClass(JThreeObject, [{
    key: "toString",

    /**
     * Obtain stringfied object.
     * If this method was not overridden, this method return class name.
     * @return {string} stringfied object
     */
    value: function toString() {
      return _JsHack2.default.getObjectName(this);
    }
    /**
     * Obtain class name
     * @return {string} Class name of the instance.
     */

  }, {
    key: "getTypeName",
    value: function getTypeName() {
      return _JsHack2.default.getObjectName(this);
    }
  }]);

  return JThreeObject;
}();

exports.default = JThreeObject;

},{"./JsHack":7}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _events = require("events");

var _JThreeObject2 = require("./JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventEmitterをmixinしたJThreeObject
 */

var JThreeObjectEE = function (_JThreeObject) {
    _inherits(JThreeObjectEE, _JThreeObject);

    function JThreeObjectEE() {
        _classCallCheck(this, JThreeObjectEE);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(JThreeObjectEE).call(this));
    }

    return JThreeObjectEE;
}(_JThreeObject3.default);

function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(function (baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        });
    });
}
applyMixins(JThreeObjectEE, [_events.EventEmitter]);
exports.default = JThreeObjectEE;

},{"./JThreeObject":3,"events":318}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _events = require("events");

var _JThreeObjectWithID2 = require("./JThreeObjectWithID");

var _JThreeObjectWithID3 = _interopRequireDefault(_JThreeObjectWithID2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventEmitterをmixinしたJThreeObjectWithID
 */

var JThreeObjectEEWithID = function (_JThreeObjectWithID) {
    _inherits(JThreeObjectEEWithID, _JThreeObjectWithID);

    function JThreeObjectEEWithID(id) {
        _classCallCheck(this, JThreeObjectEEWithID);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(JThreeObjectEEWithID).call(this, id));
    }

    return JThreeObjectEEWithID;
}(_JThreeObjectWithID3.default);

function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(function (baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        });
    });
}
applyMixins(JThreeObjectEEWithID, [_events.EventEmitter]);
exports.default = JThreeObjectEEWithID;

},{"./JThreeObjectWithID":6,"events":318}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _JThreeObject2 = require("./JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

var _JThreeID = require("./JThreeID");

var _JThreeID2 = _interopRequireDefault(_JThreeID);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * JThree object with unique ID to identify object instancies.
 * @type {[type]}
 */

var JThreeObjectWithID = function (_JThreeObject) {
    _inherits(JThreeObjectWithID, _JThreeObject);

    function JThreeObjectWithID(id) {
        _classCallCheck(this, JThreeObjectWithID);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(JThreeObjectWithID).call(this));

        _this.id = id || _JThreeID2.default.getUniqueRandom(10);
        return _this;
    }

    return JThreeObjectWithID;
}(_JThreeObject3.default);

exports.default = JThreeObjectWithID;

},{"./JThreeID":1,"./JThreeObject":3}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Something tricky static methods for javascript.
 */

var JsHack = function () {
  function JsHack() {
    _classCallCheck(this, JsHack);
  }

  _createClass(JsHack, null, [{
    key: "getObjectName",

    /**
     * Obtain the class name of passed object.
     * @param  {any}    obj any object to get class name for
     * @return {string}   obtained name
     */
    value: function getObjectName(obj) {
      var funcNameRegex = /function (.{1,})\(/;
      var result = funcNameRegex.exec(obj.constructor.toString());
      return result && result.length > 1 ? result[1] : "";
    }
  }]);

  return JsHack;
}();

exports.default = JsHack;

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ContextComponents = function () {
    function ContextComponents() {
        _classCallCheck(this, ContextComponents);
    }

    _createClass(ContextComponents, null, [{
        key: "SceneManager",
        get: function get() {
            return 0;
        }
    }, {
        key: "CanvasManager",
        get: function get() {
            return 1;
        }
    }, {
        key: "ResourceManager",
        get: function get() {
            return 2;
        }
    }, {
        key: "NodeManager",
        get: function get() {
            return 3;
        }
    }, {
        key: "LoopManager",
        get: function get() {
            return 4;
        }
    }, {
        key: "Timer",
        get: function get() {
            return 5;
        }
    }, {
        key: "Debugger",
        get: function get() {
            return 6;
        }
    }, {
        key: "ResourceLoader",
        get: function get() {
            return 7;
        }
    }, {
        key: "MaterialManager",
        get: function get() {
            return 8;
        }
    }, {
        key: "PrimitiveRegistory",
        get: function get() {
            return 9;
        }
    }, {
        key: "RenderStageRegistory",
        get: function get() {
            return 10;
        }
    }, {
        key: "ModuleManager",
        get: function get() {
            return 11;
        }
    }]);

    return ContextComponents;
}();

exports.default = ContextComponents;

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _GLExtensionRegistory = require("./GL/GLExtensionRegistory");

var _GLExtensionRegistory2 = _interopRequireDefault(_GLExtensionRegistory);

var _Rectangle = require("../../Math/Rectangle");

var _Rectangle2 = _interopRequireDefault(_Rectangle);

var _CanvasSizeChangedEventArgs = require("./CanvasSizeChangedEventArgs");

var _CanvasSizeChangedEventArgs2 = _interopRequireDefault(_CanvasSizeChangedEventArgs);

var _Color = require("../../Math/Color4");

var _Color2 = _interopRequireDefault(_Color);

var _CanvasRegion2 = require("./CanvasRegion");

var _CanvasRegion3 = _interopRequireDefault(_CanvasRegion2);

var _Exceptions = require("../../Exceptions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The class to manage HTMLCanvasElement.
 * Provides most of interfaces related to GLContext except the features resource manager providing.
 *
 * HTMLCanvasElementを管理するクラスs
 * リソースマネージャーが提供する機能以外のGLContextが関連する機能のほとんどを内包します。
 */

var Canvas = function (_CanvasRegion) {
    _inherits(Canvas, _CanvasRegion);

    /**
     * Constructor
     * @param  {HTMLCanvasElement} canvasElement the HTMLCanvasElement that is managed by this class.
     */

    function Canvas(canvasElement) {
        _classCallCheck(this, Canvas);

        /**
        * backing field for ClearColor
        */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Canvas).call(this, canvasElement));

        _this.clearColor = new _Color2.default(1, 1, 1, 1);
        _this.glExtensionResolver = new _GLExtensionRegistory2.default();
        _this.canvas = _this;
        _this._lastWidth = canvasElement.width;
        _this._lastHeight = canvasElement.height;
        _this.__setGLContext(_this._tryGetGLContext());
        return _this;
    }
    /**
     * Called after rendering. It needs super.afterRenderer(renderer) when you need to override.
     */


    _createClass(Canvas, [{
        key: "afterRender",
        value: function afterRender(renderer) {
            return;
        }
    }, {
        key: "afterRenderAll",
        value: function afterRenderAll() {
            return;
        }
    }, {
        key: "beforeRender",
        value: function beforeRender(renderer) {
            return;
        }
    }, {
        key: "beforeRenderAll",
        value: function beforeRenderAll() {
            // check size changed or not.
            if (this.canvasElement.height !== this._lastHeight || this.canvasElement.width !== this._lastWidth) {
                this.emit("resize", new _CanvasSizeChangedEventArgs2.default(this, this._lastWidth, this._lastHeight, this.canvasElement.width, this.canvasElement.height));
                this._lastHeight = this.canvasElement.height;
                this._lastWidth = this.canvasElement.width;
            }
            this._clearCanvas();
        }
    }, {
        key: "__setGLContext",

        /**
         * apply gl context after webglrendering context initiated.
         */
        value: function __setGLContext(glContext) {
            this.gl = glContext;
            this.glExtensionResolver.checkExtensions(glContext);
            this.alternativeTexture = this.__initializeAlternativeTexture();
            this.alternativeCubeTexture = this.__initializeAlternativeCubeTexture();
            return;
        }
        /**
         * Initialize and obtain the buffer texture which will be used when any texture sampler2D variable in GLSL was not assigned.
         * This method will be called when RendererFactory called initialize method to construct instance.
         * Basically,this method is not intended to be called from user.
         * @return {TextureBase} Constructed texture buffer.
         */

    }, {
        key: "__initializeAlternativeTexture",
        value: function __initializeAlternativeTexture() {
            var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
            var tex = rm.createTexture("jthree.alt.texture2D." + this.id, 1, 1);
            tex.updateTexture(new Uint8Array([255, 0, 255, 255])); // Use purple color as the color of default buffer texture.
            return tex;
        }
    }, {
        key: "__initializeAlternativeCubeTexture",
        value: function __initializeAlternativeCubeTexture() {
            var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
            var tex = rm.createCubeTextureWithSource("jthree.alt.textureCube." + this.id, null);
            return tex;
        }
    }, {
        key: "_clearCanvas",
        value: function _clearCanvas() {
            this.gl.colorMask(true, true, true, true);
            this.gl.clearColor.apply(this.gl, this.clearColor.rawElements);
            this.gl.depthMask(true);
            this.gl.clearDepth(1.0);
            this.gl.clear(WebGLRenderingContext.COLOR_BUFFER_BIT | WebGLRenderingContext.DEPTH_BUFFER_BIT);
        }
        /**
         * Attempts to try getting GLContext from canvas.
         * @return {WebGLRenderingContext} [description]
         */

    }, {
        key: "_tryGetGLContext",
        value: function _tryGetGLContext() {
            try {
                var gl = this.canvasElement.getContext("webgl") || this.canvasElement.getContext("experimental-webgl");
                gl.id = this.id;
                return gl;
            } catch (e) {
                throw new _Exceptions.WebGLNotSupportedException();
            }
        }
    }, {
        key: "region",
        get: function get() {
            return new _Rectangle2.default(0, 0, this._lastWidth, this._lastHeight);
        }
    }]);

    return Canvas;
}(_CanvasRegion3.default);

exports.default = Canvas;

},{"../../ContextComponents":8,"../../Exceptions":159,"../../JThreeContext":267,"../../Math/Color4":270,"../../Math/Rectangle":276,"./CanvasRegion":12,"./CanvasSizeChangedEventArgs":13,"./GL/GLExtensionRegistory":20}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * All canvas element managed by jThree should be constructed with this class.
 */

var CanvasElementBuilder = function () {
    function CanvasElementBuilder() {
        _classCallCheck(this, CanvasElementBuilder);
    }

    _createClass(CanvasElementBuilder, null, [{
        key: "generate",

        /**
         * Generate canvas element structure
         * @param  {HTMLElement}             container the container element holds the canvas
         * @param  {number}                  width     [the width in pixel]
         * @param  {number}                  height    [the height in pixel]
         * @return {ICanvasElementStructure}           [constructed structure infomation]
         */
        value: function generate(container, width, height) {
            var innerContainer = CanvasElementBuilder._generateInnerContainer(container, width, height);
            var resizeDetecter = CanvasElementBuilder._generateResizeDetecter(innerContainer);
            var canvasElement = CanvasElementBuilder._generateCanvas(resizeDetecter);
            var loaderContainer = CanvasElementBuilder._generateLoaderContainer(resizeDetecter, width, height);
            return {
                innerContainer: innerContainer,
                resizeDetecter: resizeDetecter,
                canvas: canvasElement,
                container: container,
                loaderContainer: loaderContainer
            };
        }
    }, {
        key: "_generateInnerContainer",
        value: function _generateInnerContainer(container, width, height) {
            var innerContainer = document.createElement("div");
            container.style.marginLeft = "auto";
            container.style.marginRight = "auto";
            container.style.width = width + "px";
            container.style.height = height + "px";
            container.appendChild(innerContainer);
            return innerContainer;
        }
    }, {
        key: "_generateResizeDetecter",
        value: function _generateResizeDetecter(innerContainer) {
            var resizeDetecter = document.createElement("div");
            resizeDetecter.style.position = "relative";
            resizeDetecter.style.margin = "0";
            resizeDetecter.style.padding = "0";
            resizeDetecter.style.height = "100%";
            innerContainer.appendChild(resizeDetecter);
            return resizeDetecter;
        }
    }, {
        key: "_generateCanvas",
        value: function _generateCanvas(resizeDetecter) {
            var canvasElement = document.createElement("canvas");
            canvasElement.style.position = "absolute";
            canvasElement.setAttribute("antialias", "false");
            resizeDetecter.appendChild(canvasElement);
            return canvasElement;
        }
    }, {
        key: "_generateLoaderContainer",
        value: function _generateLoaderContainer(resizeDetecter, width, height) {
            var loaderContainer = document.createElement("div");
            loaderContainer.style.position = "absolute";
            loaderContainer.style.width = width + "px";
            loaderContainer.style.height = height + "px";
            loaderContainer.classList.add("x-j3-loader-container");
            resizeDetecter.appendChild(loaderContainer);
            return loaderContainer;
        }
    }]);

    return CanvasElementBuilder;
}();

exports.default = CanvasElementBuilder;

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectEE2 = require("../../Base/JThreeObjectEE");

var _JThreeObjectEE3 = _interopRequireDefault(_JThreeObjectEE2);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A context component provides the feature to manage all of canvas.
 *
 *すべてのCanvasを管理する機能を提供するコンテキストコンポーネント
 * @type {[type]}
 */

var CanvasManager = function (_JThreeObjectEE) {
    _inherits(CanvasManager, _JThreeObjectEE);

    function CanvasManager() {
        _classCallCheck(this, CanvasManager);

        /**
         * All canvas managed by jThree
         * @type {Canvas[]}
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CanvasManager).call(this));

        _this.canvases = [];
        _this.setMaxListeners(10000);
        var loopManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.LoopManager);
        loopManager.addAction(4000, function () {
            return _this.beforeRenderAll();
        });
        loopManager.addAction(6000, function () {
            return _this.afterRenderAll();
        });
        return _this;
    }
    /**
     * Implementation for IContextComponent
     */


    _createClass(CanvasManager, [{
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.CanvasManager;
        }
        /**
         * Add canvas to be managed.
         * @param {Canvas} canvas [description]
         */

    }, {
        key: "addCanvas",
        value: function addCanvas(canvas) {
            if (this.canvases.indexOf(canvas) === -1) {
                this.canvases.push(canvas);
                this.emit("canvas-list-changed", {
                    isAdditionalChange: true,
                    canvas: canvas
                });
            }
        }
        /**
         * Remove canvas from managed canvas list.
         */

    }, {
        key: "removeCanvas",
        value: function removeCanvas(canvas) {
            if (this.canvases.indexOf(canvas) !== -1) {
                for (var i = 0; i < this.canvases.length; i++) {
                    if (this.canvases[i] === canvas) {
                        this.canvases.splice(i, 1);
                        break;
                    }
                }
                this.emit("canvas-list-changed", {
                    isAdditionalChange: true,
                    canvas: canvas
                });
            }
        }
    }, {
        key: "beforeRenderAll",
        value: function beforeRenderAll() {
            this.canvases.forEach(function (c) {
                return c.beforeRenderAll();
            });
            return;
        }
    }, {
        key: "afterRenderAll",
        value: function afterRenderAll() {
            this.canvases.forEach(function (c) {
                return c.afterRenderAll();
            });
            return;
        }
    }]);

    return CanvasManager;
}(_JThreeObjectEE3.default);

exports.default = CanvasManager;

},{"../../Base/JThreeObjectEE":4,"../../ContextComponents":8,"../../JThreeContext":267}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectEEWithID2 = require("../../Base/JThreeObjectEEWithID");

var _JThreeObjectEEWithID3 = _interopRequireDefault(_JThreeObjectEEWithID2);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Abstract class to provide mouse tracking feature on a part of region on canvas.
 * This class is intended to be used in Canvas and viewport renderer.
 *
 * キャンバス内の特定領域におけるマウスイベントを管理するためのクラス。
 * 主にキャンバス自身や、ビューポートを持つレンダラによる使用を想定されている。
 */

var CanvasRegion = function (_JThreeObjectEEWithID) {
    _inherits(CanvasRegion, _JThreeObjectEEWithID);

    /**
     * Constructor
     * @param  {HTMLCanvasElement} canvasElement the canvas element which contains this region
     */

    function CanvasRegion(canvasElement) {
        _classCallCheck(this, CanvasRegion);

        /**
         * Whether mouse is on the region or not.
         *
         * マウスが現在このクラスが管理する領域の上に乗っているかどうか。
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CanvasRegion).call(this));

        _this.mouseOver = false;
        _this.mouseX = 0;
        _this.mouseY = 0;
        _this.lastMouseX = 0;
        _this.lastMouseY = 0;
        _this.lastMouseDownX = 0;
        _this.lastMouseDownY = 0;
        _this.mouseDownTracking = false;
        _this.mouseLocalX = 0;
        _this.mouseLocalY = 0;
        _this.canvasElement = canvasElement;
        _this.canvasElement.addEventListener("mousemove", _this._mouseMoveHandler.bind(_this), false);
        _this.canvasElement.addEventListener("mouseenter", _this._mouseEnterHandler.bind(_this), false);
        _this.canvasElement.addEventListener("mouseleave", _this._mouseLeaveHandler.bind(_this), false);
        _this.canvasElement.addEventListener("mousedown", _this._mouseDownHandler.bind(_this), false);
        _this.canvasElement.addEventListener("mouseup", _this._mouseUpHandler.bind(_this), false);
        _this.canvasElement.addEventListener("touchend", _this._mouseUpHandler.bind(_this), false);
        _this.canvasElement.addEventListener("touchstart", _this._mouseDownHandler.bind(_this), false);
        _this.canvasElement.addEventListener("touchmove", _this._mouseMoveHandler.bind(_this), false);
        _this.name = _this.id;
        return _this;
    }
    /**
     * The region managed by this class.(This getter should be overridden)
     *
     * このクラスによって管理されている領域(このgetterはオーバーライドされるべきものです。)
     */


    _createClass(CanvasRegion, [{
        key: "dispose",

        /**
         * Dispose used objects and event handlers.
         *
         *使ったオブジェクトやイベントハンドラの破棄
         */
        value: function dispose() {
            this.canvasElement.removeEventListener("mousemove", this._mouseMoveHandler, false);
            this.canvasElement.removeEventListener("mouseenter", this._mouseEnterHandler, false);
            this.canvasElement.removeEventListener("mouseleave", this._mouseLeaveHandler, false);
            return;
        }
    }, {
        key: "_checkMouseInside",
        value: function _checkMouseInside(e) {
            // TODO fix bug here
            var rect = this.canvasElement.getBoundingClientRect();
            this.lastMouseX = this.mouseX;
            this.lastMouseY = this.mouseY;
            var clientX = undefined;
            if (typeof e.clientX === "undefined") {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }
            var clientY = undefined;
            if (typeof e.clientY === "undefined") {
                clientY = e.touches[0].clientY;
            } else {
                clientY = e.clientY;
            }
            this.mouseX = clientX - rect.left;
            this.mouseY = clientY - rect.top;
            this.mouseOver = this.region.contains(this.mouseX, this.mouseY);
            var localPos = this.region.toLocal(this.mouseX, this.mouseY);
            this.mouseLocalX = localPos[0];
            this.mouseLocalY = localPos[1];
            var debug = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.Debugger);
            debug.setInfo("MouseState:" + this.name + "(" + this.getTypeName() + ")", {
                mouseOver: this.mouseOver,
                mousePositionX: this.mouseX,
                mousePositionY: this.mouseY,
                rawX: this.mouseX,
                rawY: this.mouseY
            });
            return this.mouseOver;
        }
    }, {
        key: "_mouseMoveHandler",
        value: function _mouseMoveHandler(e) {
            this._checkMouseInside(e);
            this.emit("mouse-move", {
                eventSource: e,
                enter: false,
                leave: false,
                mouseOver: this.mouseOver,
                region: this,
                mouseX: this.mouseX,
                mouseY: this.mouseY,
                mouseDownTracking: this.mouseDownTracking,
                trackDiffX: this.mouseX - this.lastMouseDownX,
                trackDiffY: this.mouseY - this.lastMouseDownY,
                mouseDiffX: this.mouseX - this.lastMouseX,
                mouseDiffY: this.mouseY - this.lastMouseY
            });
        }
    }, {
        key: "_mouseLeaveHandler",
        value: function _mouseLeaveHandler(e) {
            this._checkMouseInside(e);
            if (this.mouseDownTracking) {
                this.mouseDownTracking = false;
            }
            this.emit("mouse-leave", {
                eventSource: e,
                enter: false,
                leave: true,
                mouseOver: this.mouseOver,
                mouseX: this.mouseX,
                mouseY: this.mouseY,
                region: this,
                mouseDiffX: this.mouseX - this.lastMouseX,
                mouseDiffY: this.mouseY - this.lastMouseY
            });
        }
    }, {
        key: "_mouseEnterHandler",
        value: function _mouseEnterHandler(e) {
            this._checkMouseInside(e);
            this.emit("mouse-enter", {
                eventSource: e,
                enter: true,
                leave: false,
                mouseOver: this.mouseOver,
                mouseX: this.mouseX,
                mouseY: this.mouseY,
                region: this,
                mouseDiffX: this.mouseX - this.lastMouseX,
                mouseDiffY: this.mouseY - this.lastMouseY
            });
        }
    }, {
        key: "_mouseDownHandler",
        value: function _mouseDownHandler(e) {
            this._checkMouseInside(e);
            if (this.mouseOver) {
                this.mouseDownTracking = true;
                this.lastMouseDownX = this.mouseX;
                this.lastMouseDownY = this.mouseY;
            }
            this.emit("mouse-down", {
                eventSource: e,
                enter: false,
                leave: false,
                mouseOver: this.mouseOver,
                mouseX: this.mouseX,
                mouseY: this.mouseY,
                region: this,
                mouseDiffX: this.mouseX - this.lastMouseX,
                mouseDiffY: this.mouseY - this.lastMouseY
            });
        }
    }, {
        key: "_mouseUpHandler",
        value: function _mouseUpHandler(e) {
            this._checkMouseInside(e);
            if (this.mouseDownTracking) {
                this.mouseDownTracking = false;
            }
            this.emit("mouse-up", {
                eventSource: e,
                enter: false,
                leave: false,
                mouseOver: this.mouseOver,
                mouseX: this.mouseX,
                mouseY: this.mouseY,
                region: this,
                mouseDownTracking: this.mouseDownTracking,
                trackDiffX: this.mouseX - this.lastMouseDownX,
                trackDiffY: this.mouseY - this.lastMouseDownY,
                mouseDiffX: this.mouseX - this.lastMouseX,
                mouseDiffY: this.mouseY - this.lastMouseY
            });
        }
    }, {
        key: "region",
        get: function get() {
            return null;
        }
    }]);

    return CanvasRegion;
}(_JThreeObjectEEWithID3.default);

exports.default = CanvasRegion;

},{"../../Base/JThreeObjectEEWithID":5,"../../ContextComponents":8,"../../JThreeContext":267}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CanvasSizeChangedEventArg = function () {
    function CanvasSizeChangedEventArg(target, lastWidth, lastHeight, newWidth, newHeight) {
        _classCallCheck(this, CanvasSizeChangedEventArg);

        this._canvas = target;
        this._lastWidth = lastWidth;
        this._lastHeight = lastHeight;
        this._newWidth = newWidth;
        this._newHeight = newHeight;
    }

    _createClass(CanvasSizeChangedEventArg, [{
        key: "Canvas",
        get: function get() {
            return this._canvas;
        }
    }, {
        key: "LastWidth",
        get: function get() {
            return this._lastWidth;
        }
    }, {
        key: "LastHeight",
        get: function get() {
            return this._lastHeight;
        }
    }, {
        key: "NewWidth",
        get: function get() {
            return this._newWidth;
        }
    }, {
        key: "NewHeight",
        get: function get() {
            return this._newHeight;
        }
    }]);

    return CanvasSizeChangedEventArg;
}();

exports.default = CanvasSizeChangedEventArg;

},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ExtensionResolverBase = require("./ExtensionResolverBase");

var _ExtensionResolverBase2 = _interopRequireDefault(_ExtensionResolverBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* The extension resolver for "WEBGL_color_buffer_float"
*/

var ColorBufferFloatExtensionResolver = function (_ExtensionResolverBas) {
    _inherits(ColorBufferFloatExtensionResolver, _ExtensionResolverBas);

    function ColorBufferFloatExtensionResolver() {
        _classCallCheck(this, ColorBufferFloatExtensionResolver);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ColorBufferFloatExtensionResolver).apply(this, arguments));
    }

    _createClass(ColorBufferFloatExtensionResolver, [{
        key: "request",
        value: function request(gl) {
            var isSupported = this._checkWebglColorBufferFloat(gl);
            if (isSupported) {
                return {};
            } else {
                return null;
            }
        }
        /**
         * To check being able to use float value texture as rendering target, just calling getExtension is not sufficient.
         */

    }, {
        key: "_checkWebglColorBufferFloat",
        value: function _checkWebglColorBufferFloat(gl) {
            var isSupported = undefined;
            if (gl.getExtension("WEBGL_color_buffer_float") === null) {
                var fbo = gl.createFramebuffer();
                var tex = gl.createTexture();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                    isSupported = false;
                } else {
                    isSupported = true;
                }
                gl.deleteTexture(tex);
                gl.deleteFramebuffer(fbo);
            } else {
                isSupported = true;
            }
            return isSupported;
        }
    }]);

    return ColorBufferFloatExtensionResolver;
}(_ExtensionResolverBase2.default);

exports.default = ColorBufferFloatExtensionResolver;

},{"./ExtensionResolverBase":16}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ExtensionResolverBase = require("./ExtensionResolverBase");

var _ExtensionResolverBase2 = _interopRequireDefault(_ExtensionResolverBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DepthTextureExtensionResolver = function (_ExtensionResolverBas) {
    _inherits(DepthTextureExtensionResolver, _ExtensionResolverBas);

    function DepthTextureExtensionResolver() {
        _classCallCheck(this, DepthTextureExtensionResolver);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(DepthTextureExtensionResolver).apply(this, arguments));
    }

    _createClass(DepthTextureExtensionResolver, [{
        key: "request",
        value: function request(gl) {
            return this.__requestExtensionWithWarning(gl, "WEBGL_depth_texture");
        }
    }]);

    return DepthTextureExtensionResolver;
}(_ExtensionResolverBase2.default);

exports.default = DepthTextureExtensionResolver;

},{"./ExtensionResolverBase":16}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The class provides features to request extension of WebGL context.
 */

var ExtensionResolverBase = function () {
    function ExtensionResolverBase() {
        _classCallCheck(this, ExtensionResolverBase);
    }

    _createClass(ExtensionResolverBase, [{
        key: "__requestExtensionWithWarning",
        value: function __requestExtensionWithWarning(gl, extKey) {
            var requestResult = gl.getExtension(extKey);
            if (requestResult == null) {
                console.warn("The WebGL extension " + extKey + " was requested. But, this browser seems not supporting the feature.");
            }
            return requestResult;
        }
    }]);

    return ExtensionResolverBase;
}();

exports.default = ExtensionResolverBase;

},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ExtensionResolverBase = require("./ExtensionResolverBase");

var _ExtensionResolverBase2 = _interopRequireDefault(_ExtensionResolverBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FloatTextureExtensionResolver = function (_ExtensionResolverBas) {
    _inherits(FloatTextureExtensionResolver, _ExtensionResolverBas);

    function FloatTextureExtensionResolver() {
        _classCallCheck(this, FloatTextureExtensionResolver);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(FloatTextureExtensionResolver).apply(this, arguments));
    }

    _createClass(FloatTextureExtensionResolver, [{
        key: "request",
        value: function request(gl) {
            return this.__requestExtensionWithWarning(gl, "OES_texture_float");
        }
    }]);

    return FloatTextureExtensionResolver;
}(_ExtensionResolverBase2.default);

exports.default = FloatTextureExtensionResolver;

},{"./ExtensionResolverBase":16}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ExtensionResolverBase = require("./ExtensionResolverBase");

var _ExtensionResolverBase2 = _interopRequireDefault(_ExtensionResolverBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UintIndexExtensionResolver = function (_ExtensionResolverBas) {
    _inherits(UintIndexExtensionResolver, _ExtensionResolverBas);

    function UintIndexExtensionResolver() {
        _classCallCheck(this, UintIndexExtensionResolver);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(UintIndexExtensionResolver).apply(this, arguments));
    }

    _createClass(UintIndexExtensionResolver, [{
        key: "request",
        value: function request(gl) {
            return this.__requestExtensionWithWarning(gl, "OES_element_index_uint");
        }
    }]);

    return UintIndexExtensionResolver;
}(_ExtensionResolverBase2.default);

exports.default = UintIndexExtensionResolver;

},{"./ExtensionResolverBase":16}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GLEnumParser = function () {
    function GLEnumParser() {
        _classCallCheck(this, GLEnumParser);
    }

    _createClass(GLEnumParser, null, [{
        key: "parseBlendFunc",
        value: function parseBlendFunc(val) {
            val = val.toUpperCase();
            switch (val) {
                case "ZERO":
                case "0":
                    return WebGLRenderingContext.ZERO;
                case "ONE":
                case "1":
                    return WebGLRenderingContext.ONE;
                case "SRC_COLOR":
                    return WebGLRenderingContext.SRC_COLOR;
                case "ONE_MINUS_SRC_COLOR":
                    return WebGLRenderingContext.ONE_MINUS_SRC_COLOR;
                case "SRC_ALPHA":
                    return WebGLRenderingContext.SRC_ALPHA;
                case "ONE_MINUS_SRC_ALPHA":
                    return WebGLRenderingContext.ONE_MINUS_SRC_ALPHA;
                case "DST_ALPHA":
                    return WebGLRenderingContext.DST_ALPHA;
                case "ONE_MINUS_DST_ALPHA":
                    return WebGLRenderingContext.ONE_MINUS_DST_ALPHA;
                case "DST_COLOR":
                    return WebGLRenderingContext.DST_COLOR;
                case "ONE_MINUS_DST_COLOR":
                    return WebGLRenderingContext.ONE_MINUS_DST_COLOR;
                case "SRC_ALPHA_SATURATE":
                    return WebGLRenderingContext.SRC_ALPHA_SATURATE;
                default:
                    throw new Error("Unknown blend func constant:" + val);
            }
        }
    }, {
        key: "parseDepthFunc",
        value: function parseDepthFunc(val) {
            val = val.toUpperCase();
            switch (val) {
                case "NEVER":
                    return WebGLRenderingContext.NEVER;
                case "LESS":
                    return WebGLRenderingContext.LESS;
                case "LEQUAL":
                    return WebGLRenderingContext.LEQUAL;
                case "GREATER":
                    return WebGLRenderingContext.GREATER;
                case "NOTEQUAL":
                    return WebGLRenderingContext.NOTEQUAL;
                case "GEQUAL":
                    return WebGLRenderingContext.GEQUAL;
                case "ALWAYS":
                    return WebGLRenderingContext.ALWAYS;
                default:
                    throw new Error("Unknown depth func:" + val);
            }
        }
    }, {
        key: "parseCullMode",
        value: function parseCullMode(val) {
            val = val.toUpperCase();
            switch (val) {
                case "BACK":
                    return WebGLRenderingContext.BACK;
                case "FRONT":
                    return WebGLRenderingContext.FRONT;
                case "FRONT_AND_BACK":
                    return WebGLRenderingContext.FRONT_AND_BACK;
                default:
                    throw new Error("Unknown cull mode:" + val);
            }
        }
    }, {
        key: "parseTextureWrapMode",
        value: function parseTextureWrapMode(val) {
            val = val.toUpperCase();
            switch (val) {
                case "REPEAT":
                    return WebGLRenderingContext.REPEAT;
                case "CLAMP_TO_EDGE":
                    return WebGLRenderingContext.CLAMP_TO_EDGE;
                case "MIRRORED_REPEAT":
                    return WebGLRenderingContext.MIRRORED_REPEAT;
                default:
                    throw new Error("Unknown texture wrapping mode:" + val);
            }
        }
    }, {
        key: "parseTextureMagFilter",
        value: function parseTextureMagFilter(val) {
            val = val.toUpperCase();
            switch (val) {
                case "NEAREST":
                    return WebGLRenderingContext.NEAREST;
                case "LINEAR":
                    return WebGLRenderingContext.LINEAR;
                default:
                    throw new Error("Unknown mag filter mode:" + val);
            }
        }
    }, {
        key: "parseTextureMinFilter",
        value: function parseTextureMinFilter(val) {
            val = val.toUpperCase();
            switch (val) {
                case "NEAREST_MIPMAP_LINEAR":
                    return WebGLRenderingContext.NEAREST_MIPMAP_LINEAR;
                case "NEAREST_MIPMAP_NEAREST":
                    return WebGLRenderingContext.NEAREST_MIPMAP_NEAREST;
                case "LINEAR_MIPMAP_LINEAR":
                    return WebGLRenderingContext.LINEAR_MIPMAP_LINEAR;
                case "LINEAR_MIPMAP_NEAREST":
                    return WebGLRenderingContext.LINEAR_MIPMAP_NEAREST;
                case "NEAREST":
                    return WebGLRenderingContext.NEAREST;
                case "LINEAR":
                    return WebGLRenderingContext.LINEAR;
                default:
                    throw new Error("Unknown min filter mode:" + val);
            }
        }
    }, {
        key: "parseTextureLayout",
        value: function parseTextureLayout(val) {
            switch (val.toUpperCase()) {
                case "ALPHA":
                    return WebGLRenderingContext.ALPHA;
                case "RGB":
                    return WebGLRenderingContext.RGB;
                case "DEPTH":
                case "DEPTH_COMPONENT":
                    return WebGLRenderingContext.DEPTH_COMPONENT;
                case "LUMINANCE":
                    return WebGLRenderingContext.LUMINANCE;
                case "LUMINANCE_ALPHA":
                    return WebGLRenderingContext.LUMINANCE_ALPHA;
                case "DEPTH_STENCIL":
                    return WebGLRenderingContext.DEPTH_STENCIL;
                case "RGBA":
                    return WebGLRenderingContext.RGBA;
                default:
                    throw new Error("Unknown texture layout was specified" + val);
            }
        }
    }, {
        key: "parseTextureFormat",
        value: function parseTextureFormat(val) {
            switch (val.toUpperCase()) {
                case "UBYTE":
                case "UNSIGNED_BYTE":
                    return WebGLRenderingContext.UNSIGNED_BYTE;
                case "FLOAT":
                    return WebGLRenderingContext.FLOAT;
                case "USHORT565":
                case "UNSIGNED_SHORT_5_6_5":
                    return WebGLRenderingContext.UNSIGNED_SHORT_5_6_5;
                case "USHORT4444":
                case "UNSIGNED_SHORT_4_4_4_4":
                    return WebGLRenderingContext.UNSIGNED_SHORT_4_4_4_4;
                case "USHORT5551":
                case "UNSIGNED_SHORT_5_5_5_1":
                    return WebGLRenderingContext.UNSIGNED_SHORT_5_5_5_1;
                case "UINT":
                case "UNSIGNED_INT":
                    return WebGLRenderingContext.UNSIGNED_INT;
                case "USHORT":
                case "UNSIGNED_SHORT":
                    return WebGLRenderingContext.UNSIGNED_SHORT;
                // case "UINT24_8":
                //   return WebGLRenderingContext.UINT;
                default:
                    throw new Error("Unknown texture format was specified" + val);
            }
        }
    }]);

    return GLEnumParser;
}();

exports.default = GLEnumParser;

},{}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ColorBufferFloatExtensionResolver = require("./ExtensionResolver/ColorBufferFloatExtensionResolver");

var _ColorBufferFloatExtensionResolver2 = _interopRequireDefault(_ColorBufferFloatExtensionResolver);

var _DepthTextureExtensionResolver = require("./ExtensionResolver/DepthTextureExtensionResolver");

var _DepthTextureExtensionResolver2 = _interopRequireDefault(_DepthTextureExtensionResolver);

var _UintIndexExtensionResolver = require("./ExtensionResolver/UintIndexExtensionResolver");

var _UintIndexExtensionResolver2 = _interopRequireDefault(_UintIndexExtensionResolver);

var _FloatTextureExtensionResolver = require("./ExtensionResolver/FloatTextureExtensionResolver");

var _FloatTextureExtensionResolver2 = _interopRequireDefault(_FloatTextureExtensionResolver);

var _JThreeObject2 = require("../../../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides the feature to require gl extension.
 */

var GLExtensionRegistory = function (_JThreeObject) {
    _inherits(GLExtensionRegistory, _JThreeObject);

    function GLExtensionRegistory() {
        var _Object$getPrototypeO;

        _classCallCheck(this, GLExtensionRegistory);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(GLExtensionRegistory)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.extensions = {};
        return _this;
    }

    _createClass(GLExtensionRegistory, [{
        key: "checkExtensions",
        value: function checkExtensions(gl) {
            for (var extName in GLExtensionRegistory.requiredExtensions) {
                this.extensions[extName] = GLExtensionRegistory.requiredExtensions[extName].request(gl);
            }
        }
    }]);

    return GLExtensionRegistory;
}(_JThreeObject3.default);

GLExtensionRegistory.requiredExtensions = {
    "OES_texture_float": new _FloatTextureExtensionResolver2.default(),
    "OES_element_index_uint": new _UintIndexExtensionResolver2.default(),
    "WEBGL_depth_texture": new _DepthTextureExtensionResolver2.default(),
    "WEBGL_color_buffer_float": new _ColorBufferFloatExtensionResolver2.default()
};
exports.default = GLExtensionRegistory;

},{"../../../Base/JThreeObject":3,"./ExtensionResolver/ColorBufferFloatExtensionResolver":14,"./ExtensionResolver/DepthTextureExtensionResolver":15,"./ExtensionResolver/FloatTextureExtensionResolver":17,"./ExtensionResolver/UintIndexExtensionResolver":18}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _IndexedGeometry2 = require("./IndexedGeometry");

var _IndexedGeometry3 = _interopRequireDefault(_IndexedGeometry2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Basic geometry for builtin primitives. This geometry contains position,normal,uv as buffer.
 *
 * ビルトインのプリミティブのためのジオメトリ、このジオメトリはposition,normal,uvをバッファとして持つ。
 * @type {[type]}
 */

var BasicGeometry = function (_IndexedGeometry) {
    _inherits(BasicGeometry, _IndexedGeometry);

    function BasicGeometry() {
        _classCallCheck(this, BasicGeometry);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(BasicGeometry).apply(this, arguments));
    }

    _createClass(BasicGeometry, [{
        key: "__applyAttributeVariables",
        value: function __applyAttributeVariables(pWrapper, attributes) {
            this.__assignAttributeIfExists(pWrapper, attributes, "position", this.positionBuffer);
            this.__assignAttributeIfExists(pWrapper, attributes, "normal", this.normalBuffer);
            this.__assignAttributeIfExists(pWrapper, attributes, "uv", this.uvBuffer);
        }
    }, {
        key: "dispose",
        value: function dispose() {
            _get(Object.getPrototypeOf(BasicGeometry.prototype), "dispose", this).call(this);
            this.positionBuffer.dispose();
            this.normalBuffer.dispose();
            this.uvBuffer.dispose();
        }
    }]);

    return BasicGeometry;
}(_IndexedGeometry3.default);

exports.default = BasicGeometry;

},{"./IndexedGeometry":24}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject = require("../../../Base/JThreeObject");

var _JThreeObject2 = _interopRequireDefault(_JThreeObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Base abstraction for geometry.
 */

var Geometry = function (_jThreeObject) {
    _inherits(Geometry, _jThreeObject);

    function Geometry() {
        var _Object$getPrototypeO;

        _classCallCheck(this, Geometry);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Geometry)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.primitiveTopology = WebGLRenderingContext.TRIANGLES;
        return _this;
    }

    _createClass(Geometry, [{
        key: "useGeometry",
        value: function useGeometry(pWrapper, attributes) {
            if (Geometry.lastGeometry !== this || Geometry.lastProgram !== pWrapper) {
                this.__applyAttributeVariables(pWrapper, attributes);
                Geometry.lastGeometry = this;
                Geometry.lastProgram = pWrapper;
            }
        }
    }, {
        key: "__assignAttributeIfExists",
        value: function __assignAttributeIfExists(pWrapper, attributes, valName, buffer) {
            if (attributes[valName]) {
                pWrapper.assignAttributeVariable(valName, buffer);
            }
        }
    }, {
        key: "GeometryOffset",
        get: function get() {
            return 0;
        }
    }]);

    return Geometry;
}(_JThreeObject2.default);

Geometry.lastGeometry = null;
Geometry.lastProgram = null;
exports.default = Geometry;

},{"../../../Base/JThreeObject":3}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = require("../../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GeometryBuilder = function () {
    function GeometryBuilder() {
        _classCallCheck(this, GeometryBuilder);
    }

    _createClass(GeometryBuilder, null, [{
        key: "addDividedQuad",
        value: function addDividedQuad(pos, normal, uv, index, divX, divY) {
            var startIndex = pos.length / 3;
            var xP = 2.0 / divX;
            var yP = 2.0 / divY;
            for (var i = 0; i < divX + 1; i++) {
                var x = xP * i - 1;
                for (var j = 0; j < divY + 1; j++) {
                    var y = 1 - yP * j;
                    pos.push(x, y, 0);
                    normal.push(0, 0, 1);
                    uv.push(x / 2 + 0.5, 1 - y / 2 - 0.5);
                }
            }
            for (var _i = 0; _i < divX; _i++) {
                for (var _j = 0; _j < divY; _j++) {
                    var p0 = _i * (divY + 1) + _j + startIndex;
                    var p1 = p0 + 1;
                    var p3 = p0 + divY + 1;
                    var p2 = p3 + 1;
                    index.push(p0, p1, p3, p3, p1, p2);
                }
            }
        }
    }, {
        key: "addQuad",
        value: function addQuad(pos, normal, uv, index, points) {
            var startIndex = pos.length / 3;
            var v0 = points[0],
                v1 = points[1],
                v3 = points[2];
            var v02v1 = v1.subtractWith(v0);
            var v02v3 = v3.subtractWith(v0);
            var v2 = v0.addWith(v02v1).addWith(v02v3);
            var nV = v02v1.crossWith(v02v3).normalizeThis();
            normal.push(nV.X, nV.Y, nV.Z, nV.X, nV.Y, nV.Z, nV.X, nV.Y, nV.Z, nV.X, nV.Y, nV.Z);
            uv.push(0, 1, 0, 0, 1, 0, 1, 1);
            pos.push(v0.X, v0.Y, v0.Z, v1.X, v1.Y, v1.Z, v2.X, v2.Y, v2.Z, v3.X, v3.Y, v3.Z);
            index.push(startIndex, startIndex + 1, startIndex + 3, startIndex + 3, startIndex + 1, startIndex + 2);
        }
    }, {
        key: "addCircle",
        value: function addCircle(pos, normal, uv, index, divide, center, normalVector, tangentVector) {
            var tan2 = _Vector2.default.cross(tangentVector, normalVector);
            var vecCount = 2 + divide;
            var baseIndex = uv.length / 2;
            for (var i = 0; i < vecCount; i++) {
                var v = GeometryBuilder._calcNextPointInCircle(i, divide, center, tangentVector, tan2);
                var u = GeometryBuilder._calcUVInCircle(i, divide);
                pos.push(v.X, v.Y, v.Z);
                normal.push(normalVector.X, normalVector.Y, normalVector.Z);
                uv.push(u[0], u[1]);
            }
            for (var _i2 = 0; _i2 < divide; _i2++) {
                index.push(baseIndex);
                index.push(baseIndex + _i2 + 2);
                index.push(baseIndex + _i2 + 1);
            }
        }
    }, {
        key: "addCylinder",
        value: function addCylinder(pos, normal, uv, index, divide, start, end, tangent, radius) {
            var dest = _Vector2.default.subtract(end, start);
            var tangentNormalized = tangent.normalizeThis();
            var tan2 = _Vector2.default.cross(dest.normalizeThis(), tangentNormalized);
            tangentNormalized = tangentNormalized.multiplyWith(radius);
            tan2 = tan2.multiplyWith(radius);
            for (var i = 0; i < divide; i++) {
                var angle = (i - 1) * 2 * Math.PI / divide;
                var angleTo = i * 2 * Math.PI / divide;
                var currentNormal = _Vector2.default.add(tan2.multiplyWith(Math.cos(angle)), tangentNormalized.multiplyWith(Math.sin(angle)));
                var nextNormal = _Vector2.default.add(tan2.multiplyWith(Math.cos(angleTo)), tangentNormalized.multiplyWith(Math.sin(angleTo)));
                var v0 = _Vector2.default.add(start, currentNormal);
                var v1 = _Vector2.default.add(start, nextNormal);
                var v2 = _Vector2.default.add(v0, dest);
                var v3 = v1.addWith(dest);
                var startIndex = pos.length / 3;
                normal.push(currentNormal.X, currentNormal.Y, currentNormal.Z, nextNormal.X, nextNormal.Y, nextNormal.Z, nextNormal.X, nextNormal.Y, nextNormal.Z, currentNormal.X, currentNormal.Y, currentNormal.Z);
                uv.push(0, 1, 1, 0, 1, 0, 0, 0);
                pos.push(v0.X, v0.Y, v0.Z, v1.X, v1.Y, v1.Z, v3.X, v3.Y, v3.Z, v2.X, v2.Y, v2.Z);
                index.push(startIndex + 2, startIndex + 1, startIndex, startIndex + 3, startIndex + 2, startIndex);
            }
        }
    }, {
        key: "addSphere",
        value: function addSphere(pos, normal, uv, index, divideY, divideX, center) {
            var vt = _Vector2.default.add(center, new _Vector2.default(0, 1, 0));
            var vb = _Vector2.default.add(center, new _Vector2.default(0, -1, 0));
            pos.push(vt.X, vt.Y, vt.Z);
            normal.push(0, 1, 0);
            uv.push(0, 1);
            for (var i = 0; i < divideY - 1; i++) {
                var angle_y = (i + 1) * Math.PI / divideY;
                var d = Math.sin(angle_y);
                var h = Math.cos(angle_y);
                for (var j = 0; j < divideX; j++) {
                    var angle_x = j * 2 * Math.PI / divideX;
                    var v0 = new _Vector2.default(d * Math.sin(angle_x), h, d * Math.cos(angle_x));
                    var v0_n = v0.normalizeThis();
                    var _startIndex = pos.length / 3;
                    pos.push(v0.X, v0.Y, v0.Z);
                    normal.push(v0_n.X, v0_n.Y, v0_n.Z);
                    uv.push(0, 1);
                    if (i === 0) {
                        if (j !== 0) {
                            index.push(0, _startIndex - 1, _startIndex);
                            if (j === divideX - 1) {
                                index.push(0, _startIndex, 1);
                            }
                        }
                    } else {
                        if (j === 0) {
                            index.push(_startIndex - divideX, _startIndex, _startIndex - divideX + 1);
                        } else if (j === divideX - 1) {
                            index.push(_startIndex - divideX, _startIndex - 1, _startIndex);
                            index.push(_startIndex - divideX + 1, _startIndex - divideX - divideX + 1, _startIndex);
                            index.push(_startIndex - divideX - divideX + 1, _startIndex - divideX, _startIndex);
                        } else {
                            index.push(_startIndex - divideX, _startIndex - 1, _startIndex);
                            index.push(_startIndex - divideX + 1, _startIndex - divideX, _startIndex);
                        }
                    }
                }
            }
            var startIndex = pos.length / 3;
            pos.push(vb.X, vb.Y, vb.Z);
            normal.push(0, -1, 0);
            uv.push(0, 1);
            for (var _j2 = 0; _j2 < divideX - 1; _j2++) {
                index.push(startIndex, startIndex - 1 - _j2, startIndex - 2 - _j2);
            }
            index.push(startIndex, startIndex - divideX, startIndex - 1);
        }
    }, {
        key: "addCone",
        value: function addCone(pos, normal, uv, index, divide) {
            pos.push(0, -1, 0);
            normal.push(0, -1, 0);
            uv.push(0, 1);
            var angle = 2 * Math.PI / divide;
            var y = Math.sqrt(5) / 5.0;
            var k = y * 2;
            var startIndex = undefined;
            for (var i = 0; i < divide; i++) {
                var d1 = Math.sin(angle * i);
                var d2 = Math.cos(angle * i);
                var v = new _Vector2.default(d1, -1, d2);
                var vn = new _Vector2.default(d1 * k, y, d2 * k);
                startIndex = pos.length / 3;
                pos.push(v.X, v.Y, v.Z, v.X, v.Y, v.Z, 0, 1, 0);
                uv.push(0, 1, 0, 1, 0, 1);
                normal.push(vn.X, vn.Y, vn.Z, 0, -1, 0, vn.X, vn.Y, vn.Z);
                if (i !== 0) {
                    index.push(startIndex - 1, startIndex - 3, startIndex);
                    index.push(0, startIndex + 1, startIndex - 2);
                }
            }
            startIndex = pos.length / 3 - 1;
            index.push(startIndex, startIndex - 2, 1);
            index.push(0, 2, startIndex - 1);
        }
    }, {
        key: "_calcUVInCircle",
        value: function _calcUVInCircle(index, divCount) {
            if (index === 0) {
                return [0, 0];
            }
            var angle = (index - 1) * 2 * Math.PI / divCount;
            return [Math.cos(angle), Math.sin(angle)];
        }
    }, {
        key: "_calcNextPointInCircle",
        value: function _calcNextPointInCircle(index, divCount, center, tan, tan2) {
            var angle = (index - 1) * 2 * Math.PI / divCount;
            return index === 0 ? center : _Vector2.default.add(center, _Vector2.default.add(tan.multiplyWith(Math.sin(angle)), tan2.multiplyWith(Math.cos(angle))));
        }
    }]);

    return GeometryBuilder;
}();

exports.default = GeometryBuilder;

},{"../../../Math/Vector3":278}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Geometry2 = require("./Geometry");

var _Geometry3 = _interopRequireDefault(_Geometry2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The abstract class for the geometries having index buffer(ELEMENT_ARRAY_BUFFER) for drawing.
 *
 * 描画にインデックスバッファ(ELEMENT_ARRAY_BUFFER)を用いるジオメトリの抽象クラス
 */

var IndexedGeometry = function (_Geometry) {
    _inherits(IndexedGeometry, _Geometry);

    function IndexedGeometry() {
        _classCallCheck(this, IndexedGeometry);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(IndexedGeometry).apply(this, arguments));
    }

    _createClass(IndexedGeometry, [{
        key: "dispose",
        value: function dispose() {
            this.indexBuffer.dispose();
        }
        /**
         * The count of verticies.(3 times count of surfaces(When the topology was "triangles"))
         *
         * 頂点数(面数の3倍となる(topologyがtrianglesの時))
         * @return {number} The count of verticies
         */

    }, {
        key: "getDrawLength",
        value: function getDrawLength() {
            return this.indexBuffer.Length;
        }
        /**
         * Draw this geometry for specified material.
         *
         * 渡されたマテリアル用にジオメトリを描画します。
         * @param {Canvas}   canvas   the canvas should be rendererd with this method.
         * @param {Material} material the material should be used for rendering this geometry.
         */

    }, {
        key: "drawElements",
        value: function drawElements(canvas, material) {
            if (IndexedGeometry.lastIndexedGeometry !== this) {
                this.__bindIndexBuffer(canvas);
                IndexedGeometry.lastIndexedGeometry = this;
            }
            canvas.gl.drawElements(this.primitiveTopology, material.getDrawGeometryLength(this), this.indexBuffer.ElementType, material.getDrawGeometryOffset(this));
        }
        /**
         * Draw this geometry as wireframe for specified material.
         * @param {Canvas}   canvas   [description]
         * @param {Material} material [description]
         */

    }, {
        key: "drawWireframe",
        value: function drawWireframe(canvas, material) {
            this.__bindIndexBuffer(canvas);
            var offset = material.getDrawGeometryOffset(this);
            var length = material.getDrawGeometryLength(this);
            var index = offset;
            switch (this.primitiveTopology) {
                case WebGLRenderingContext.TRIANGLES:
                    if (length % 3 !== 0) {
                        throw new Error("length is invalid!");
                    }
                    while (offset + length > index) {
                        canvas.gl.drawElements(WebGLRenderingContext.POINTS, 3, this.indexBuffer.ElementType, index);
                        index += 3;
                    }
                    break;
                default:
                    throw new Error("Unsupported topology!");
            }
        }
        /**
         * Bind the index buffer for specified Canvas
         *
         * 渡されたCanvas用にインデックスバッファをバインドします。
         * @param  {Canvas} canvas the canvas this index buffer should be bound to
         */

    }, {
        key: "__bindIndexBuffer",
        value: function __bindIndexBuffer(canvas) {
            this.indexBuffer.getForGL(canvas.gl).bindBuffer();
        }
    }, {
        key: "__updateIndexBuffer",
        value: function __updateIndexBuffer(indicies, length) {
            var format = WebGLRenderingContext.UNSIGNED_INT;
            var arrayConstructor = Uint32Array;
            if (length < 256) {
                format = WebGLRenderingContext.UNSIGNED_BYTE;
                arrayConstructor = Uint8Array;
            } else if (length < 65535) {
                format = WebGLRenderingContext.UNSIGNED_SHORT;
                arrayConstructor = Uint16Array;
            } else if (length >= 4294967296) {
                throw new Error("Too many index of geometry!");
            }
            this.indexBuffer.update(new arrayConstructor(indicies), length);
            this.indexBuffer.ElementType = format;
        }
    }]);

    return IndexedGeometry;
}(_Geometry3.default);

exports.default = IndexedGeometry;

},{"./Geometry":22}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ConeGeometry = require("../ConeGeometry");

var _ConeGeometry2 = _interopRequireDefault(_ConeGeometry);

var _CylinderGeometry = require("../CylinderGeometry");

var _CylinderGeometry2 = _interopRequireDefault(_CylinderGeometry);

var _CubeGeometry = require("../CubeGeometry");

var _CubeGeometry2 = _interopRequireDefault(_CubeGeometry);

var _SphereGeometry = require("../SphereGeometry");

var _SphereGeometry2 = _interopRequireDefault(_SphereGeometry);

var _QuadGeometry = require("../QuadGeometry");

var _QuadGeometry2 = _interopRequireDefault(_QuadGeometry);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PrimitiveRegistory = function () {
    function PrimitiveRegistory() {
        _classCallCheck(this, PrimitiveRegistory);

        /**
         * Registered primitives
         */
        this._primitives = {};
    }

    _createClass(PrimitiveRegistory, [{
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.PrimitiveRegistory;
        }
    }, {
        key: "registerDefaultPrimitives",
        value: function registerDefaultPrimitives() {
            this.registerPrimitive("quad", new _QuadGeometry2.default("quad"));
            this.registerPrimitive("sphere", new _SphereGeometry2.default("sphere"));
            this.registerPrimitive("cube", new _CubeGeometry2.default("cube"));
            this.registerPrimitive("cylinder", new _CylinderGeometry2.default("cylinder"));
            this.registerPrimitive("cone", new _ConeGeometry2.default("cone"));
        }
    }, {
        key: "registerPrimitive",
        value: function registerPrimitive(key, geo) {
            this._primitives[key] = geo;
        }
    }, {
        key: "deregisterPrimitive",
        value: function deregisterPrimitive(key) {
            delete this._primitives[key];
        }
    }, {
        key: "getPrimitive",
        value: function getPrimitive(key) {
            return this._primitives[key];
        }
    }]);

    return PrimitiveRegistory;
}();

exports.default = PrimitiveRegistory;

},{"../../../ContextComponents":8,"../ConeGeometry":27,"../CubeGeometry":28,"../CylinderGeometry":29,"../QuadGeometry":31,"../SphereGeometry":32}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GeometryBuilder = require("./Base/GeometryBuilder");

var _GeometryBuilder2 = _interopRequireDefault(_GeometryBuilder);

var _BasicGeometry2 = require("./Base/BasicGeometry");

var _BasicGeometry3 = _interopRequireDefault(_BasicGeometry2);

var _Vector = require("../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CircleGeometry = function (_BasicGeometry) {
    _inherits(CircleGeometry, _BasicGeometry);

    function CircleGeometry(name) {
        _classCallCheck(this, CircleGeometry);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CircleGeometry).call(this));

        _this._divideCount = 30;
        var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        _this.indexBuffer = rm.createBuffer(name + "index", WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 1, WebGLRenderingContext.UNSIGNED_BYTE);
        _this.positionBuffer = rm.createBuffer(name + "-pos", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.normalBuffer = rm.createBuffer(name + "-nor", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.uvBuffer = rm.createBuffer(name + "-uv", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 2, WebGLRenderingContext.FLOAT);
        _this.__updateBuffers();
        return _this;
    }

    _createClass(CircleGeometry, [{
        key: "__updateBuffers",
        value: function __updateBuffers() {
            var pos = [];
            var normal = [];
            var uv = [];
            var index = [];
            _GeometryBuilder2.default.addCircle(pos, normal, uv, index, this._divideCount, _Vector2.default.Zero, _Vector2.default.YUnit, new _Vector2.default(0, 0, -1));
            this.indexBuffer.update(new Uint8Array(index), index.length);
            this.normalBuffer.update(new Float32Array(normal), normal.length);
            this.uvBuffer.update(new Float32Array(uv), uv.length);
            this.positionBuffer.update(new Float32Array(pos), pos.length);
        }
    }, {
        key: "DiviceCount",
        get: function get() {
            return this._divideCount;
        },
        set: function set(count) {
            this._divideCount = count;
            this.__updateBuffers();
        }
    }]);

    return CircleGeometry;
}(_BasicGeometry3.default);

exports.default = CircleGeometry;

},{"../../ContextComponents":8,"../../JThreeContext":267,"../../Math/Vector3":278,"./Base/BasicGeometry":21,"./Base/GeometryBuilder":23}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GeometryBuilder = require("./Base/GeometryBuilder");

var _GeometryBuilder2 = _interopRequireDefault(_GeometryBuilder);

var _BasicGeometry2 = require("./Base/BasicGeometry");

var _BasicGeometry3 = _interopRequireDefault(_BasicGeometry2);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ConeGeometry = function (_BasicGeometry) {
    _inherits(ConeGeometry, _BasicGeometry);

    function ConeGeometry(name) {
        _classCallCheck(this, ConeGeometry);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ConeGeometry).call(this));

        _this._divideCount = 10;
        var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        _this.indexBuffer = rm.createBuffer(name + "index", WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 1, WebGLRenderingContext.UNSIGNED_SHORT);
        _this.positionBuffer = rm.createBuffer(name + "-pos", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.normalBuffer = rm.createBuffer(name + "-nor", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.uvBuffer = rm.createBuffer(name + "-uv", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 2, WebGLRenderingContext.FLOAT);
        _this.__updateBuffers();
        return _this;
    }

    _createClass(ConeGeometry, [{
        key: "__updateBuffers",
        value: function __updateBuffers() {
            var pos = [];
            var normal = [];
            var uv = [];
            var index = [];
            _GeometryBuilder2.default.addCone(pos, normal, uv, index, 100);
            this.indexBuffer.update(new Uint16Array(index), index.length);
            this.normalBuffer.update(new Float32Array(normal), normal.length);
            this.uvBuffer.update(new Float32Array(uv), uv.length);
            this.positionBuffer.update(new Float32Array(pos), pos.length);
        }
    }, {
        key: "DivideCount",
        get: function get() {
            return this._divideCount;
        },
        set: function set(count) {
            this._divideCount = count;
            this.__updateBuffers();
        }
    }]);

    return ConeGeometry;
}(_BasicGeometry3.default);

exports.default = ConeGeometry;

},{"../../ContextComponents":8,"../../JThreeContext":267,"./Base/BasicGeometry":21,"./Base/GeometryBuilder":23}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GeometryBuilder = require("./Base/GeometryBuilder");

var _GeometryBuilder2 = _interopRequireDefault(_GeometryBuilder);

var _BasicGeometry2 = require("./Base/BasicGeometry");

var _BasicGeometry3 = _interopRequireDefault(_BasicGeometry2);

var _Vector = require("../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CubeGeometry = function (_BasicGeometry) {
    _inherits(CubeGeometry, _BasicGeometry);

    function CubeGeometry(name) {
        _classCallCheck(this, CubeGeometry);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CubeGeometry).call(this));

        var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        _this.indexBuffer = rm.createBuffer(name + "index", WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 1, WebGLRenderingContext.UNSIGNED_BYTE);
        _this.positionBuffer = rm.createBuffer(name + "-pos", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.normalBuffer = rm.createBuffer(name + "-nor", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.uvBuffer = rm.createBuffer(name + "-uv", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 2, WebGLRenderingContext.FLOAT);
        _this.__updateBuffers();
        return _this;
    }

    _createClass(CubeGeometry, [{
        key: "__updateBuffers",
        value: function __updateBuffers() {
            var pos = [];
            var normal = [];
            var uv = [];
            var index = [];
            _GeometryBuilder2.default.addQuad(pos, normal, uv, index, [new _Vector2.default(-1, 1, 1), new _Vector2.default(-1, -1, 1), new _Vector2.default(1, 1, 1)]);
            _GeometryBuilder2.default.addQuad(pos, normal, uv, index, [new _Vector2.default(1, 1, 1), new _Vector2.default(1, -1, 1), new _Vector2.default(1, 1, -1)]);
            _GeometryBuilder2.default.addQuad(pos, normal, uv, index, [new _Vector2.default(1, 1, -1), new _Vector2.default(1, -1, -1), new _Vector2.default(-1, 1, -1)]);
            _GeometryBuilder2.default.addQuad(pos, normal, uv, index, [new _Vector2.default(-1, 1, -1), new _Vector2.default(-1, -1, -1), new _Vector2.default(-1, 1, 1)]);
            _GeometryBuilder2.default.addQuad(pos, normal, uv, index, [new _Vector2.default(-1, 1, 1), new _Vector2.default(1, 1, 1), new _Vector2.default(-1, 1, -1)]);
            _GeometryBuilder2.default.addQuad(pos, normal, uv, index, [new _Vector2.default(1, -1, 1), new _Vector2.default(-1, -1, 1), new _Vector2.default(1, -1, -1)]);
            this.indexBuffer.update(new Uint8Array(index), index.length);
            this.normalBuffer.update(new Float32Array(normal), normal.length);
            this.uvBuffer.update(new Float32Array(uv), uv.length);
            this.positionBuffer.update(new Float32Array(pos), pos.length);
        }
    }]);

    return CubeGeometry;
}(_BasicGeometry3.default);

exports.default = CubeGeometry;

},{"../../ContextComponents":8,"../../JThreeContext":267,"../../Math/Vector3":278,"./Base/BasicGeometry":21,"./Base/GeometryBuilder":23}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GeometryBuilder = require("./Base/GeometryBuilder");

var _GeometryBuilder2 = _interopRequireDefault(_GeometryBuilder);

var _BasicGeometry2 = require("./Base/BasicGeometry");

var _BasicGeometry3 = _interopRequireDefault(_BasicGeometry2);

var _Vector = require("../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CylinderGeometry = function (_BasicGeometry) {
    _inherits(CylinderGeometry, _BasicGeometry);

    function CylinderGeometry(name) {
        _classCallCheck(this, CylinderGeometry);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CylinderGeometry).call(this));

        _this._divideCount = 10;
        var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        _this.indexBuffer = rm.createBuffer(name + "index", WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 1, WebGLRenderingContext.UNSIGNED_SHORT);
        _this.positionBuffer = rm.createBuffer(name + "-pos", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.normalBuffer = rm.createBuffer(name + "-nor", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.uvBuffer = rm.createBuffer(name + "-uv", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 2, WebGLRenderingContext.FLOAT);
        _this.__updateBuffers();
        return _this;
    }

    _createClass(CylinderGeometry, [{
        key: "__updateBuffers",
        value: function __updateBuffers() {
            var pos = [];
            var normal = [];
            var uv = [];
            var index = [];
            _GeometryBuilder2.default.addCylinder(pos, normal, uv, index, this.DivideCount, new _Vector2.default(0, 1, 0), new _Vector2.default(0, -1, 0), new _Vector2.default(0, 0, -1), 1);
            this.indexBuffer.update(new Uint16Array(index), index.length);
            this.normalBuffer.update(new Float32Array(normal), normal.length);
            this.uvBuffer.update(new Float32Array(uv), uv.length);
            this.positionBuffer.update(new Float32Array(pos), pos.length);
        }
    }, {
        key: "DivideCount",
        get: function get() {
            return this._divideCount;
        },
        set: function set(count) {
            this._divideCount = count;
            this.__updateBuffers();
        }
    }]);

    return CylinderGeometry;
}(_BasicGeometry3.default);

exports.default = CylinderGeometry;

},{"../../ContextComponents":8,"../../JThreeContext":267,"../../Math/Vector3":278,"./Base/BasicGeometry":21,"./Base/GeometryBuilder":23}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BasicGeometry2 = require("./Base/BasicGeometry");

var _BasicGeometry3 = _interopRequireDefault(_BasicGeometry2);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GridGeometry = function (_BasicGeometry) {
    _inherits(GridGeometry, _BasicGeometry);

    function GridGeometry(name) {
        _classCallCheck(this, GridGeometry);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GridGeometry).call(this));

        _this._holizontalDivide = 10;
        _this._verticalDivide = 10;
        var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        _this.primitiveTopology = WebGLRenderingContext.LINES;
        _this.indexBuffer = rm.createBuffer(name + "index", WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 1, WebGLRenderingContext.UNSIGNED_SHORT);
        _this.positionBuffer = rm.createBuffer(name + "-pos", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.normalBuffer = rm.createBuffer(name + "-nor", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.uvBuffer = rm.createBuffer(name + "-uv", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 2, WebGLRenderingContext.FLOAT);
        _this.__updateBuffers();
        return _this;
    }

    _createClass(GridGeometry, [{
        key: "__updatePositionBuffer",
        value: function __updatePositionBuffer() {
            var arr = [];
            for (var i = 0; i < this.HolizontalDivide + 1; i++) {
                var num = -1 + 1 / this.HolizontalDivide * i * 2;
                arr.push(num, 0, -1, num, 0, 1);
            }
            for (var _i = 0; _i < this.VerticalDivide + 1; _i++) {
                var _num = -1 + 1 / this.VerticalDivide * _i * 2;
                arr.push(-1, 0, _num, 1, 0, _num);
            }
            this.positionBuffer.update(new Float32Array(arr), arr.length);
        }
    }, {
        key: "__updateNormalBuffer",
        value: function __updateNormalBuffer() {
            this.normalBuffer.update(new Float32Array(new Array(this.VerticiesCount * 3)), this.VerticiesCount * 3);
        }
    }, {
        key: "__updateUvBuffer",
        value: function __updateUvBuffer() {
            this.uvBuffer.update(new Float32Array(new Array(this.VerticiesCount * 2)), this.VerticiesCount * 2);
        }
    }, {
        key: "__updateIndexBuffer",
        value: function __updateIndexBuffer() {
            var arr = [];
            for (var v = 0; v < this.VerticiesCount; v++) {
                arr.push(v);
            }
            this.indexBuffer.update(new Uint16Array(arr), this.VerticiesCount);
        }
    }, {
        key: "__updateBuffers",
        value: function __updateBuffers() {
            this.__updatePositionBuffer();
            this.__updateNormalBuffer();
            this.__updateUvBuffer();
            this.__updateIndexBuffer();
        }
    }, {
        key: "HolizontalDivide",
        get: function get() {
            return this._holizontalDivide;
        },
        set: function set(num) {
            this._holizontalDivide = num;
            this.__updateBuffers();
        }
    }, {
        key: "VerticalDivide",
        get: function get() {
            return this._verticalDivide;
        },
        set: function set(num) {
            this._verticalDivide = num;
            this.__updateBuffers();
        }
    }, {
        key: "VerticiesCount",
        get: function get() {
            return (this.HolizontalDivide + 1) * 2 + (this.VerticalDivide + 1) * 2;
        }
    }]);

    return GridGeometry;
}(_BasicGeometry3.default);

exports.default = GridGeometry;

},{"../../ContextComponents":8,"../../JThreeContext":267,"./Base/BasicGeometry":21}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GeometryBuilder = require("./Base/GeometryBuilder");

var _GeometryBuilder2 = _interopRequireDefault(_GeometryBuilder);

var _BasicGeometry2 = require("./Base/BasicGeometry");

var _BasicGeometry3 = _interopRequireDefault(_BasicGeometry2);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var QuadGeometry = function (_BasicGeometry) {
    _inherits(QuadGeometry, _BasicGeometry);

    function QuadGeometry(name) {
        _classCallCheck(this, QuadGeometry);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(QuadGeometry).call(this));

        _this._divX = 2;
        _this._divY = 2;
        var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        _this.indexBuffer = rm.createBuffer(name + "index", WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 1, WebGLRenderingContext.UNSIGNED_SHORT);
        _this.positionBuffer = rm.createBuffer(name + "-pos", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.normalBuffer = rm.createBuffer(name + "-nor", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.uvBuffer = rm.createBuffer(name + "-uv", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 2, WebGLRenderingContext.FLOAT);
        _this.__updateBuffers();
        return _this;
    }

    _createClass(QuadGeometry, [{
        key: "__updateBuffers",
        value: function __updateBuffers() {
            var pos = [];
            var nor = [];
            var uv = [];
            var index = [];
            _GeometryBuilder2.default.addDividedQuad(pos, nor, uv, index, this._divX, this._divY);
            this.positionBuffer.update(new Float32Array(pos), pos.length);
            this.normalBuffer.update(new Float32Array(nor), nor.length);
            this.uvBuffer.update(new Float32Array(uv), uv.length);
            this.__updateIndexBuffer(index, index.length);
        }
    }, {
        key: "DivX",
        set: function set(num) {
            this._divX = num;
            this.__updateBuffers();
        }
    }, {
        key: "DivY",
        set: function set(num) {
            this._divY = num;
            this.__updateBuffers();
        }
    }]);

    return QuadGeometry;
}(_BasicGeometry3.default);

exports.default = QuadGeometry;

},{"../../ContextComponents":8,"../../JThreeContext":267,"./Base/BasicGeometry":21,"./Base/GeometryBuilder":23}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GeometryBuilder = require("./Base/GeometryBuilder");

var _GeometryBuilder2 = _interopRequireDefault(_GeometryBuilder);

var _BasicGeometry2 = require("./Base/BasicGeometry");

var _BasicGeometry3 = _interopRequireDefault(_BasicGeometry2);

var _Vector = require("../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SphereGeometry = function (_BasicGeometry) {
    _inherits(SphereGeometry, _BasicGeometry);

    function SphereGeometry(name) {
        _classCallCheck(this, SphereGeometry);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SphereGeometry).call(this));

        _this._divX = 10;
        _this._divY = 10;
        var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        _this.indexBuffer = rm.createBuffer(name + "index", WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 1, WebGLRenderingContext.UNSIGNED_SHORT);
        _this.positionBuffer = rm.createBuffer(name + "-pos", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.normalBuffer = rm.createBuffer(name + "-nor", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.uvBuffer = rm.createBuffer(name + "-uv", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 2, WebGLRenderingContext.FLOAT);
        _this.__updateBuffers();
        return _this;
    }

    _createClass(SphereGeometry, [{
        key: "__updateBuffers",
        value: function __updateBuffers() {
            var pos = [];
            var normal = [];
            var uv = [];
            var index = [];
            _GeometryBuilder2.default.addSphere(pos, normal, uv, index, this._divY, this._divX, new _Vector2.default(0, 0, 0));
            this.normalBuffer.update(new Float32Array(normal), normal.length);
            this.uvBuffer.update(new Float32Array(uv), uv.length);
            this.positionBuffer.update(new Float32Array(pos), pos.length);
            this.__updateIndexBuffer(index, index.length);
        }
    }, {
        key: "DivX",
        get: function get() {
            return this._divX;
        },
        set: function set(count) {
            this._divX = count;
            this.__updateBuffers();
        }
    }, {
        key: "DivY",
        get: function get() {
            return this._divY;
        },
        set: function set(count) {
            this._divY = count;
            this.__updateBuffers();
        }
    }]);

    return SphereGeometry;
}(_BasicGeometry3.default);

exports.default = SphereGeometry;

},{"../../ContextComponents":8,"../../JThreeContext":267,"../../Math/Vector3":278,"./Base/BasicGeometry":21,"./Base/GeometryBuilder":23}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BasicGeometry2 = require("./Base/BasicGeometry");

var _BasicGeometry3 = _interopRequireDefault(_BasicGeometry2);

var _Vector = require("../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TriangleGeometry = function (_BasicGeometry) {
    _inherits(TriangleGeometry, _BasicGeometry);

    function TriangleGeometry(name) {
        _classCallCheck(this, TriangleGeometry);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TriangleGeometry).call(this));

        _this._first = new _Vector2.default(0, 1, 0);
        _this._second = new _Vector2.default(1, 0, 0);
        _this._third = new _Vector2.default(-1, 0, 0);
        var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        _this.indexBuffer = rm.createBuffer(name + "index", WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 1, WebGLRenderingContext.UNSIGNED_BYTE);
        _this.positionBuffer = rm.createBuffer(name + "-pos", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.normalBuffer = rm.createBuffer(name + "-nor", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.uvBuffer = rm.createBuffer(name + "-uv", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 2, WebGLRenderingContext.FLOAT);
        _this.__updateBuffers();
        return _this;
    }

    _createClass(TriangleGeometry, [{
        key: "__updatePositionBuffer",
        value: function __updatePositionBuffer() {
            this.positionBuffer.update(new Float32Array([this._first.X, this._first.Y, this._first.Z, this._second.X, this._second.Y, this._second.Z, this._third.X, this._third.Y, this._third.Z]), 9);
        }
    }, {
        key: "__updateNormalBuffer",
        value: function __updateNormalBuffer() {
            this.normalBuffer.update(new Float32Array([0, 0, -1, 0, 0, -1, 0, 0, -1]), 9);
        }
    }, {
        key: "__updateUvBuffer",
        value: function __updateUvBuffer() {
            this.uvBuffer.update(new Float32Array([0.5, 0.5, 1, 0, 0, 0]), 6);
        }
    }, {
        key: "__updateIndexBuffer",
        value: function __updateIndexBuffer() {
            this.indexBuffer.update(new Uint8Array([0, 1, 2]), 3);
        }
    }, {
        key: "__updateBuffers",
        value: function __updateBuffers() {
            this.__updatePositionBuffer();
            this.__updateNormalBuffer();
            this.__updateUvBuffer();
            this.__updateIndexBuffer();
        }
    }, {
        key: "First",
        set: function set(vec) {
            this._first = vec;
            this.__updateBuffers();
        }
    }, {
        key: "Second",
        set: function set(vec) {
            this._second = vec;
            this.__updateBuffers();
        }
    }, {
        key: "Third",
        set: function set(vec) {
            this._third = vec;
            this.__updateBuffers();
        }
    }]);

    return TriangleGeometry;
}(_BasicGeometry3.default);

exports.default = TriangleGeometry;

},{"../../ContextComponents":8,"../../JThreeContext":267,"../../Math/Vector3":278,"./Base/BasicGeometry":21}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The class to provide all of loop action stuff in JThree.
 *
 * JThree内のループに関する機能を提供するクラス
 * @type {[type]}
 */

var LoopManager = function () {
    /**
     * Constructor
     */

    function LoopManager() {
        var _this = this;

        _classCallCheck(this, LoopManager);

        /**
         * The list of loop actions already registered.
         *
         * 既に登録されたループアクションのリスト
         * @type {LoopAction[]}
         */
        this._loopActions = [];
        this._registerNextLoop = window.requestAnimationFrame // if window.requestAnimationFrame is defined or undefined
        ? function () {
            window.requestAnimationFrame(_this._loop.bind(_this));
        } : function () {
            window.setTimeout(_this._loop.bind(_this), 1000 / 60);
        };
    }
    /**
     * Begin the loop
     */


    _createClass(LoopManager, [{
        key: "begin",
        value: function begin() {
            this._loop();
        }
        /**
         * Add action to be looped.
         *
         * アクションをループされるよう追加します。
         * @param  {number}           order  the execution order where is criteria for priorty of loop.
         * @param  {Action0} action the function where will be executed in the loop
         */

    }, {
        key: "addAction",
        value: function addAction(order, action) {
            this._loopActions.push({
                order: order,
                action: action
            });
            this._loopActions.sort(function (a1, a2) {
                return a1.order - a2.order;
            });
        }
    }, {
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.LoopManager;
        }
        /**
         * Execute a frame for loop
         *
         * ループの1フレームを実行
         */

    }, {
        key: "_loop",
        value: function _loop() {
            this._loopActions.forEach(function (act) {
                act.action();
            });
            this._registerNextLoop();
        }
    }]);

    return LoopManager;
}();

exports.default = LoopManager;

},{"../ContextComponents":8}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ArgumentMerger = function () {
    function ArgumentMerger() {
        _classCallCheck(this, ArgumentMerger);
    }

    _createClass(ArgumentMerger, null, [{
        key: "merge",

        /**
         * シェーダー引数をマージする
         * @param  {IShaderArgumentContainer} stage    [RenderStageのインスタンス]
         * @param  {IShaderArgumentContainer} material [Materialのインスタンス]
         * @param  {IShaderArgumentContainer} object   [SceneObjectのインスタンス]
         * @return {[type]}                            [description]
         */
        value: function merge(stage, material, object) {
            ArgumentMerger._deleteCache();
            ArgumentMerger._mergeArgument(stage);
            ArgumentMerger._mergeArgument(material);
            if (object) {
                ArgumentMerger._mergeArgument(object);
            }
            return ArgumentMerger._argumentCache;
        }
    }, {
        key: "_deleteCache",
        value: function _deleteCache() {
            for (var key in ArgumentMerger._argumentCache) {
                delete ArgumentMerger._argumentCache[key];
            }
        }
    }, {
        key: "_mergeArgument",
        value: function _mergeArgument(container) {
            for (var key in container.shaderVariables) {
                ArgumentMerger._argumentCache[key] = container.shaderVariables[key];
            }
        }
    }]);

    return ArgumentMerger;
}();

ArgumentMerger._argumentCache = {};
exports.default = ArgumentMerger;

},{}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _ArgumentMerger = require("./ArgumentMerger");

var _ArgumentMerger2 = _interopRequireDefault(_ArgumentMerger);

var _Material2 = require("./Material");

var _Material3 = _interopRequireDefault(_Material2);

var _MaterialPass = require("../Pass/MaterialPass");

var _MaterialPass2 = _interopRequireDefault(_MaterialPass);

var _XMMLParser = require("./Parser/XMMLParser");

var _XMMLParser2 = _interopRequireDefault(_XMMLParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BasicMaterial = function (_Material) {
    _inherits(BasicMaterial, _Material);

    function BasicMaterial(sourceString, name) {
        _classCallCheck(this, BasicMaterial);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BasicMaterial).call(this));

        _this._mergedShaderVariables = {};
        _XMMLParser2.default.parse(name, sourceString).then(function (desc) {
            _this._description = desc;
            _this._passes = desc.pass.map(function (pass) {
                return new _MaterialPass2.default(_this, pass);
            });
            _this.__setLoaded();
        });
        return _this;
    }

    _createClass(BasicMaterial, [{
        key: "dispose",
        value: function dispose() {
            _get(Object.getPrototypeOf(BasicMaterial.prototype), "dispose", this).call(this);
            this._passes.forEach(function (p) {
                p.dispose();
            });
        }
        /**
        * Apply configuration of program.
        * This is used for passing variables,using programs,binding index buffer.
        */

    }, {
        key: "apply",
        value: function apply(matArg) {
            if (!this.Initialized) {
                return;
            }
            _get(Object.getPrototypeOf(BasicMaterial.prototype), "apply", this).call(this, matArg);
            this._mergedShaderVariables = _ArgumentMerger2.default.merge(matArg.renderStage, this, matArg.object); // should be optimized
            var targetPass = this._passes[matArg.passIndex];
            targetPass.apply(matArg, this._description.registerers, this, this._mergedShaderVariables);
        }
        /**
        * Should return how many times required to render this material.
        * If you render some of model with edge,it can be 2 or greater.
        * Because it needs rendering edge first,then rendering forward shading.
        */

    }, {
        key: "getPassCount",
        value: function getPassCount(techniqueIndex) {
            return this._description.pass.length;
        }
    }, {
        key: "MaterialGroup",
        get: function get() {
            return this._description.group;
        }
    }]);

    return BasicMaterial;
}(_Material3.default);

exports.default = BasicMaterial;

},{"../Pass/MaterialPass":62,"./ArgumentMerger":35,"./Material":57,"./Parser/XMMLParser":60}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BasicMaterial2 = require("../BasicMaterial");

var _BasicMaterial3 = _interopRequireDefault(_BasicMaterial2);

var _Vector = require("../../../Math/Vector4");

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HitAreaMaterial = function (_BasicMaterial) {
    _inherits(HitAreaMaterial, _BasicMaterial);

    function HitAreaMaterial() {
        _classCallCheck(this, HitAreaMaterial);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(HitAreaMaterial).call(this, require("../BuiltIn/HitAreaTest.xmml"), "builtin.hitarea"));
    }

    _createClass(HitAreaMaterial, [{
        key: "apply",
        value: function apply(matArg) {
            var r = (0xFF00 & matArg.renderStage.objectIndex) >> 16;
            var g = 0x00FF & matArg.renderStage.objectIndex;
            this.shaderVariables["indexColor"] = new _Vector2.default(r / 0xFF, g / 0xFF, 0, 1);
            _get(Object.getPrototypeOf(HitAreaMaterial.prototype), "apply", this).call(this, matArg);
        }
    }]);

    return HitAreaMaterial;
}(_BasicMaterial3.default);

exports.default = HitAreaMaterial;

},{"../../../Math/Vector4":279,"../BasicMaterial":36,"../BuiltIn/HitAreaTest.xmml":43}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BasicMaterial2 = require("../BasicMaterial");

var _BasicMaterial3 = _interopRequireDefault(_BasicMaterial2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PrimaryBufferMaterial = function (_BasicMaterial) {
    _inherits(PrimaryBufferMaterial, _BasicMaterial);

    function PrimaryBufferMaterial() {
        _classCallCheck(this, PrimaryBufferMaterial);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(PrimaryBufferMaterial).call(this, require("../BuiltIn/GBuffer/PrimaryBuffer.xmml"), "builtin.gbuffer.1"));
    }

    _createClass(PrimaryBufferMaterial, [{
        key: "apply",
        value: function apply(matArg) {
            var fm = matArg.object.getMaterial("builtin.forward"); // brightness
            var brightness = 0;
            var fmArgs = fm.shaderVariables;
            if (fmArgs["brightness"]) {
                brightness = fmArgs["brightness"];
            }
            this.shaderVariables["brightness"] = brightness;
            _get(Object.getPrototypeOf(PrimaryBufferMaterial.prototype), "apply", this).call(this, matArg);
        }
    }]);

    return PrimaryBufferMaterial;
}(_BasicMaterial3.default);

exports.default = PrimaryBufferMaterial;

},{"../BasicMaterial":36,"../BuiltIn/GBuffer/PrimaryBuffer.xmml":41}],39:[function(require,module,exports){
module.exports = "vec4 packUNorm32(const highp float value)\n{\n  const vec4 bitSh = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n  const vec4 bitMsk = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n  vec4 res = fract(value * bitSh);\n  res -= res.xxyz * bitMsk;\n  return res;\n}\n\nvec4 packRanged32(const highp float value,const highp float minimum,const highp float maximum)\n{\n  return packUNorm32((value-minimum)/(maximum - minimum));\n}\n\nhighp float unpackUNorm32(const vec4 value)\n{\n  const vec4 bitSh = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n  return(dot(value, bitSh));\n}\n\nhighp float unpackRanged32(const vec4 value,const highp float minimum,const highp float maximum)\n{\n  return unpackUNorm32(value) * (maximum - minimum) + minimum;\n}\n\nvec3 packUNorm24(const highp float value){\n  const vec3 bitSh = vec3(256.0*256.0, 256.0, 1.0);\n  const vec3 bitMsk = vec3(0.0, 1.0/256.0, 1.0/256.0);\n  highp vec3 res = fract(value * bitSh);\n  res -= res.xxy * bitMsk;\n  return res;\n}\n\nvec3 packRanged24(const highp float value,const highp float minimum,const highp float maximum){\n  return packUNorm24((value - minimum)/(maximum - minimum));\n}\n\nhighp float unpackUNorm24(const vec3 value)\n{\n  const vec3 bitSh = vec3(1.0/(256.0*256.0), 1.0/256.0, 1.0);\n  return(dot(value, bitSh));\n}\n\nhighp float unpackRanged24(const vec3 value,const highp float minimum,const highp float maximum){\n  return unpackUNorm24(value) * (maximum - minimum) + minimum;\n}\n\nvec2 packUNorm16(const highp float value){\n  const highp vec2 bitSh = vec2(256.0, 1.0);\n  const highp vec2 bitMsk = vec2(0.0, 1.0/256.0);\n  vec2 res = fract(value * bitSh);\n  res -= res.xx * bitMsk;\n  return res;\n}\n\nvec2 packRanged16(const highp float value,const highp float minimum,const highp float maximum){\n  return packUNorm16((value - minimum)/(maximum - minimum));\n}\n\nhighp float unpackUNorm16(const highp vec2 value)\n{\n  const highp vec2 bitSh = vec2(1.0/256.0, 1.0);\n  return(dot(value, bitSh));\n}\n\nhighp float unpackRanged16(const vec2 value,const highp float minimum,const highp float maximum){\n  return unpackUNorm16(value) * (maximum - minimum) + minimum;\n}\n"
},{}],40:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<material name=\"builtin.depth\" group=\"builtin.depth\" order=\"300\">\n<registers>\n  <register name=\"builtin.basic\"/>\n</registers>\n<passes>\n  <pass>\n    <glsl>\n      <![CDATA[\n      attribute vec4 position;\n      varying highp vec4 vPosition;\n\n      @vert{\n        uniform mat4 _matPVM;\n\n        void main(void)\n        {\n        \tvPosition = gl_Position  = _matPVM * position;\n        }\n      }\n\n      @frag{\n        @import \"builtin.packing\"\n\n        void main(void)\n        {\n        \tgl_FragColor.rgb = packRanged24(vPosition.z/vPosition.w,-1.,1.);\n        }\n      }\n\n      ]]>\n    </glsl>\n  </pass>\n</passes>\n</material>\n"
},{}],41:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<material name=\"jthree.gbuffer.1\" group=\"jthree.basic.gbuffer.1\" order=\"300\">\n<registers>\n  <register name=\"builtin.basic\"/>\n</registers>\n<passes>\n  <pass>\n    <glsl>\n      <![CDATA[\n      attribute vec4 position;\n      attribute vec3 normal;\n      varying vec3 vNormal;\n\n      @vert{\n        uniform mat4 _matVM;\n        uniform mat4 _matPVM;\n\n        void main(void)\n        {\n        \tgl_Position  = _matPVM * position;\n        \tvNormal =normalize(( _matVM * vec4(normal,0)).xyz);\n        }\n      }\n\n      @frag{\n        @import \"builtin.packing\"\n        @import \"builtin.gbuffer-packing\"\n\n        vec2 compressNormal()\n        {\n        \tfloat p = sqrt(vNormal.z * 8. + 8.);\n        \treturn vNormal.xy/p + 0.5;\n        }\n\n        vec4 packedNormal()\n        {\n          vec2 cNor = compressNormal();\n          return vec4(packRanged16(cNor.x,CNOR_MIN,CNOR_MAX),packRanged16(cNor.y,CNOR_MIN,CNOR_MAX));\n        }\n\n        void main(void)\n        {\n        \tgl_FragColor = packedNormal();\n        }\n      }\n\n      ]]>\n    </glsl>\n  </pass>\n</passes>\n</material>\n"
},{}],42:[function(require,module,exports){
module.exports = "#define CNOR_MIN 0.1464466\n#define CNOR_MAX 0.8535534\n"
},{}],43:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<material name=\"jthree.basic.hitarea\" group=\"jthree.materials.hitarea\" order=\"300\">\n<registers>\n  <register name=\"builtin.basic\"/>\n</registers>\n<passes>\n  <pass>\n    <glsl>\n      <![CDATA[\n      attribute vec4 position;\n\n      @vert{\n        uniform mat4 _matPVM;\n\n        void main(void)\n        {\n        \tgl_Position =_matPVM * position;\n        }\n      }\n\n      @frag{\n        uniform vec4 indexColor;\n\n        void main()\n        {\n        \tgl_FragColor = indexColor;\n        }\n      }\n\n      ]]>\n    </glsl>\n  </pass>\n</passes>\n</material>\n"
},{}],44:[function(require,module,exports){
module.exports = "// builtin.gbuffer-reader\n@import \"builtin.packing\"\n@import \"builtin.gbuffer-packing\"\n\n// Get depth from texture\nfloat getDepth(vec4 rawBuffer)\n{\n  return rawBuffer.z;\n}\n// Get normal from texture\nvec3 getNormal(vec4 rawBuffer)\n{\n  highp vec2 cNor = vec2(unpackRanged16(rawBuffer.xy,CNOR_MIN,CNOR_MAX),unpackRanged16(rawBuffer.zw,CNOR_MIN,CNOR_MAX));\n  highp vec2 compressed = cNor * 4. - vec2(2.,2.);\n  highp vec3 result;\n  highp float f = dot(compressed,compressed);\n  highp float g = sqrt(1. - f/4.);\n  result.z = 1. - f/2.;\n  result.xy = compressed * g;\n  return normalize(result);\n}\n\n// Reconstruct position\nhighp vec3 getPosition(highp float depth,vec4 projectedLightPoint,mat4 invProj)\n{\n  vec4 reconstructed = invProj*vec4(projectedLightPoint.xy/projectedLightPoint.w,depth,1.);\n  return reconstructed.xyz / reconstructed.w;\n}\n\nvec2 calcBufferPosition(vec4 projectedLightPoint)\n{\n  return ((projectedLightPoint.xy/projectedLightPoint.w) + vec2(1.0,1.0)) * 0.5;\n}\n\nvec4 readRawBuffer(sampler2D rawBuffer,vec4 projectedLightPoint)\n{\n  return texture2D(rawBuffer,calcBufferPosition(projectedLightPoint));\n}\n\nfloat lambert(vec3 normal,vec3 p2l){\n  return max(0.0,dot(normal,p2l)) / 3.1415;\n}\n\nfloat halfLambert(vec3 normal,vec3 p2l){\n  float val = max( dot( normal, p2l ), 0.0 ) * 0.5 + 0.5;\n  return val * val * ( 3.0 / ( 4.0 * 3.1415 ) );\n}\n"
},{}],45:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <material name=\"jthree.basic.light.diffuse.area\" group=\"jthree.light.diffuse\" order=\"300\">\n    <registers>\n      <register name=\"builtin.basic\" />\n      <register name=\"builtin.buffer\" />\n    </registers>\n    <passes>\n      <pass>\n        <glsl>\n          <![CDATA[\n      attribute vec3 position;\n      varying vec4 vLightProjectedPosition;\n      @vert{\n        uniform mat4 _matPVM;\n\n        void main(void)\n        {\n          gl_Position = vLightProjectedPosition = _matPVM * vec4(position,1.0);\n        }\n      }\n\n      @frag{\n        uniform vec3 lightColor;\n        uniform mat4 _matIP;\n        uniform mat4 areaMatrix;\n        uniform vec3 basePosition;\n        @{type:\"buffer\",register:0,name:\"PRIMARY\"}\n        uniform sampler2D _gBuffer;\n\n        @import \"builtin.gbuffer-reader\"\n\n        void main(void)\n        {\n          vec4 rawBuffer = readRawBuffer(_gBuffer,vLightProjectedPosition);\n          float depth = getDepth(rawBuffer);\n          vec3 pos = getPosition(depth,vLightProjectedPosition,_matIP);\n          vec4 e = areaMatrix * vec4(pos,1.0);\n          e.xyz /= e.w;\n          if(e.x < 1. && e.x >-1. && e.y <1. && e.y >-1. && e.z < 1. && e.z >-1.)\n          {\n            gl_FragColor = vec4(lightColor,1);\n          }else{\n            gl_FragColor = vec4(0,0,0,1);\n          }\n        }\n      }\n      ]]>\n        </glsl>\n      </pass>\n    </passes>\n  </material>\n"
},{}],46:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <material name=\"jthree.basic.light.diffuse.directional\" group=\"jthree.light.diffuse\" order=\"300\">\n    <registers>\n      <register name=\"builtin.basic\" />\n      <register name=\"builtin.buffer\" />\n    </registers>\n    <passes>\n      <pass>\n        <glsl>\n          <![CDATA[\n      attribute vec3 position;\n      varying vec4 vLightProjectedPosition;\n      @vert{\n        uniform mat4 _matPVM;\n\n        void main(void)\n        {\n          gl_Position = vLightProjectedPosition =  vec4(position,1.0);\n        }\n      }\n\n      @frag{\n        uniform vec3 lightColor;\n        uniform vec3 lightDirection;\n        @{type:\"buffer\",register:0,name:\"PRIMARY\"}\n        uniform sampler2D _gBuffer;\n\n        @import \"builtin.gbuffer-reader\"\n\n        @{type:\"buffer\",register:1,name:\"DEPTH\"}\n        uniform sampler2D _depthBuffer;\n\n        void main(void)\n        {\n          //gl_FragColor.rgb = packRanged24(texture2D(_depthBuffer,calcBufferPosition(vLightProjectedPosition)).r,-1.,1.);\n          //gl_FragColor.a = 1.;\n          //return;\n          vec4 rawBuffer = readRawBuffer(_gBuffer,vLightProjectedPosition);\n          vec3 normal = getNormal(rawBuffer);\n          float power = dot(-lightDirection,normal);\n          gl_FragColor = vec4(lightColor * power,1.0);\n        }\n      }\n      ]]>\n        </glsl>\n      </pass>\n    </passes>\n  </material>\n"
},{}],47:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <material name=\"jthree.basic.light.diffuse.point\" group=\"jthree.light.diffuse\" order=\"300\">\n    <registers>\n      <register name=\"builtin.basic\" />\n      <register name=\"builtin.buffer\" />\n    </registers>\n    <passes>\n      <pass>\n        <glsl>\n          <![CDATA[\n      attribute vec3 position;\n      varying vec4 vLightProjectedPosition;\n      @vert{\n        uniform mat4 _matPVM;\n        void main(void)\n        {\n          gl_Position = vLightProjectedPosition = _matPVM *  vec4(position,1.0);\n        }\n      }\n\n      @frag{\n        uniform vec3 lightColor;\n        uniform float decay;\n        uniform highp float dist;\n        uniform mat4 _matIP;\n        uniform vec3 lightPosition;\n        @{type:\"buffer\",register:0,name:\"PRIMARY\"}\n        uniform sampler2D _gBuffer;\n\n        @{type:\"buffer\",register:1,name:\"DEPTH\"}\n        uniform sampler2D _depthBuffer;\n\n        @import \"builtin.gbuffer-reader\"\n\n        void main(void)\n        {\n          vec2 bufferPos = calcBufferPosition(vLightProjectedPosition);\n          vec4 rawBuffer = readRawBuffer(_gBuffer,vLightProjectedPosition);\n          vec3 normal = getNormal(rawBuffer);\n          highp float depth = unpackRanged24(texture2D(_depthBuffer,bufferPos).rgb,-1.,1.);\n          highp vec3 pos = getPosition( depth, vLightProjectedPosition, _matIP);\n          highp float d = distance( pos, lightPosition) / dist;\n          if(d > 1.)discard;\n          float power = pow(1. - d, decay);\n          float lambart = halfLambert(normal, normalize(lightPosition - pos));\n          gl_FragColor = vec4(lightColor * power * lambart,1.0);\n        }\n      }\n      ]]>\n        </glsl>\n      </pass>\n    </passes>\n  </material>\n"
},{}],48:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <material name=\"jthree.basic.light.diffuse.scene\" group=\"jthree.light.diffuse\" order=\"300\">\n    <registers>\n    </registers>\n    <passes>\n      <pass>\n        <glsl>\n          <![CDATA[\n      attribute vec3 position;\n      @vert{\n\n        void main(void)\n        {\n          gl_Position =  vec4(position,1.0);\n        }\n      }\n\n      @frag{\n        uniform vec3 lightColor;\n        void main(void)\n        {\n          gl_FragColor = vec4(lightColor,1.0);\n        }\n      }\n      ]]>\n        </glsl>\n      </pass>\n    </passes>\n  </material>\n"
},{}],49:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <material name=\"jthree.basic.light.diffuse.spot\" group=\"jthree.light.diffuse\" order=\"300\">\n    <registers>\n      <register name=\"builtin.basic\" />\n      <register name=\"builtin.buffer\" />\n    </registers>\n    <passes>\n      <pass>\n        <glsl>\n          <![CDATA[\n      attribute vec3 position;\n      varying vec4 vLightProjectedPosition;\n      @vert\n      {\n        uniform mat4 _matPVM;\n\n        void main(void)\n        {\n          gl_Position = vLightProjectedPosition = _matPVM * vec4(position + vec3(0,-1,0),1.0);\n        }\n      }\n\n      @frag\n      {\n        uniform vec3 lightColor;\n        uniform float innerAngle;//無減衰角\n        uniform float outerAngle;//最大影響角\n        uniform float innerDistance;//減衰開始距離\n        uniform float outerDistance;//最大影響距離\n        uniform vec3 lightPosition;//ライトの位置\n        uniform vec3 lightDirection;//ライトの向き\n        uniform float angleDecay;\n        uniform float distanceDecay;\n        uniform float dist;\n        uniform mat4 _matIP;\n        @{type:\"buffer\",register:0,name:\"PRIMARY\"}\n        uniform sampler2D _gBuffer;\n\n        @import \"builtin.gbuffer-reader\"\n\n        void main(void)\n        {\n          vec4 rawBuffer = readRawBuffer(_gBuffer,vLightProjectedPosition);\n          vec3 normal = getNormal(rawBuffer);\n          float depth = getDepth(rawBuffer);\n          vec3 pos = getPosition(depth,vLightProjectedPosition,_matIP);\n\n          //法線反射係数\n          float lambart = dot(normal,normalize(lightPosition - pos));\n          if(lambart<0.)discard;\n\n          float outCos=cos(outerAngle);\n          float innCos=cos(innerAngle);\n\n          //範囲外を除外\n          vec3 l2p=normalize(pos-lightPosition);\n          float c=dot(l2p,lightDirection);\n          if(c<outCos){\n            //gl_FragColor = vec4(1,0,0,1);\n            //return;\n            discard;\n          }\n\n          //距離外を除外\n          float d=distance(pos,lightPosition);\n          if(d>outerDistance){\n            //gl_FragColor = vec4(0,1,0,1);\n            //return;\n            discard;\n          }\n\n          float k=1.;//減衰係数\n          if(d<innerDistance){//距離減衰なし\n            if(c<innCos){//角度減衰のみ\n              //gl_FragColor = vec4(0,0,1,1);\n              //return;\n                float pk=(c-outCos)/(innCos-outCos);\n                k = pow(pk,angleDecay);\n            }\n          }else{\n            float pd=(outerDistance-d)/(outerDistance-innerDistance);\n            k=pow(pd,distanceDecay);\n            if(c<innCos){\n              //gl_FragColor = vec4(0,0,1,1);\n              //return;\n                float pk=(c-outCos)/(innCos-outCos);\n                k = k*pow(pk,angleDecay);\n            }\n          }\n\n          gl_FragColor = vec4(lightColor*k*lambart,1.0);\n\n        }\n      }\n      ]]>\n        </glsl>\n      </pass>\n    </passes>\n  </material>\n"
},{}],50:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <material name=\"jthree.basic.light.specular.directional\" group=\"jthree.light.specular\" order=\"300\">\n    <registers>\n      <register name=\"builtin.basic\" />\n      <register name=\"builtin.buffer\" />\n    </registers>\n    <passes>\n      <pass>\n        <glsl>\n          <![CDATA[\n      attribute vec3 position;\n      varying vec4 vLightProjectedPosition;\n      @vert{\n        uniform mat4 _matPVM;\n\n        void main(void)\n        {\n          gl_Position = vLightProjectedPosition =  vec4(position,1.0);\n        }\n      }\n\n      @frag{\n        uniform vec3 lightColor;\n        uniform vec3 lightDirection;\n        @{type:\"buffer\",register:0,name:\"PRIMARY\"}\n        uniform sampler2D _gBuffer;\n        uniform mat4 _matIP;\n\n        @import \"builtin.gbuffer-reader\"\n\n        void main(void)\n        {\n          vec4 rawBuffer = readRawBuffer(_gBuffer,vLightProjectedPosition);\n          if(rawBuffer.w == 0.)discard;\n          vec3 normal = getNormal(rawBuffer);\n          float depth = getDepth(rawBuffer);\n          vec3 pos = getPosition(depth,vLightProjectedPosition,_matIP);\n          float power = dot(-lightDirection,normal);\n          vec3 hv = normalize(normalize(-lightDirection) + normalize(-pos));\n          float brightness = rawBuffer.w;\n          float phong = pow(max(0.,dot(hv,normal)),brightness);\n          gl_FragColor = vec4(lightColor * phong,1.0);\n        }\n      }\n      ]]>\n        </glsl>\n      </pass>\n    </passes>\n  </material>\n"
},{}],51:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<material name=\"jthree.basic.light.specular.point\" group=\"jthree.light.specular\" order=\"300\">\n  <registers>\n    <register name=\"builtin.basic\" />\n    <register name=\"builtin.buffer\" />\n  </registers>\n  <passes>\n    <pass>\n      <glsl>\n        <![CDATA[\n      precision highp float;\n      attribute vec3 position;\n      varying highp vec4 vLightProjectedPosition;\n      @vert{\n        uniform mat4 _matPVM;\n\n        void main(void)\n        {\n          gl_Position = vLightProjectedPosition = _matPVM * vec4(position,1.0);\n        }\n      }\n\n      @frag{\n        uniform vec3 lightColor;\n        uniform float decay;\n        uniform lowp float dist;\n        uniform highp mat4 _matIP;\n        uniform vec3 lightPosition;\n\n        @{type:\"buffer\",register:0,name:\"PRIMARY\"}\n        uniform sampler2D _gBuffer;\n\n        @{type:\"buffer\",register:1,name:\"DEPTH\"}\n        uniform sampler2D _depthBuffer;\n\n        @import \"builtin.gbuffer-reader\"\n\n        void main(void)\n        {\n          vec2 bufferPos = calcBufferPosition(vLightProjectedPosition);\n          vec4 rawBuffer = readRawBuffer(_gBuffer,vLightProjectedPosition);\n          lowp vec3 normal = getNormal(rawBuffer);\n          float depth = unpackRanged24(texture2D(_depthBuffer,bufferPos).rgb,-1.,1.);\n          vec3 pos = getPosition(depth,vLightProjectedPosition,_matIP);\n          if(dot(normal,normalize(lightPosition - pos)) < 0.){\n            discard;\n          }\n          float d=distance(pos,lightPosition)/dist;\n          if(d>1.)discard;\n          float power = pow(1. - d,decay);\n          vec3 hv = normalize(normalize(lightPosition-pos)+normalize(-pos));\n          gl_FragColor = vec4(pow(dot(hv,normal),5.0) * power * lightColor,1.0);\n        }\n      }\n      ]]>\n      </glsl>\n    </pass>\n  </passes>\n</material>\n"
},{}],52:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <material name=\"jthree.basic.light.specular.spot\" group=\"jthree.light.specular\" order=\"300\">\n    <registers>\n      <register name=\"builtin.basic\" />\n      <register name=\"builtin.buffer\" />\n    </registers>\n    <passes>\n      <pass>\n        <glsl>\n          <![CDATA[\n      attribute vec3 position;\n      varying vec4 vLightProjectedPosition;\n      @vert{\n        uniform mat4 _matPVM;\n\n\n        void main(void)\n        {\n          gl_Position = vLightProjectedPosition = _matPVM * vec4(position + vec3(0,-1,0),1.0);\n        }\n      }\n\n      @frag{\n        uniform vec3 lightColor;\n        uniform float angle;\n        uniform vec3 lightPosition;//ライトの位置\n        uniform vec3 lightDirection;//ライトの向き\n        uniform float decay;\n        uniform float dist;\n        uniform mat4 _matIP;\n        @{type:\"buffer\",register:0,name:\"PRIMARY\"}\n        uniform sampler2D _gBuffer;\n\n        @import \"builtin.gbuffer-reader\"\n\n        void main(void)\n        {\n          vec4 rawBuffer = readRawBuffer(_gBuffer,vLightProjectedPosition);\n          if(rawBuffer.w == 0.){//反射係数\n            discard;\n          }\n          vec3 normal = getNormal(rawBuffer);\n          float depth = getDepth(rawBuffer);\n          vec3 pos = getPosition(depth,vLightProjectedPosition,_matIP);\n\n          if(dot(normal,normalize(lightPosition - pos)) < 0.){\n            discard;\n          }\n\n          //範囲外を除外\n          vec3 l2p=normalize(pos-lightPosition);\n          if(dot(l2p,lightDirection)<cos(angle)){\n            discard;\n          }\n\n          //距離外を除外\n          float d=distance(pos,lightPosition);\n          if(d>dist){\n            discard;\n          }\n\n          float power = pow(1. - distance(pos,lightPosition)/dist,decay);\n          vec3 hv = normalize(normalize(-pos)-l2p);\n          gl_FragColor = vec4(pow(dot(hv,normal),rawBuffer.w) * power * lightColor*10.,1.0);\n        }\n      }\n      ]]>\n        </glsl>\n      </pass>\n    </passes>\n  </material>\n"
},{}],53:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<material name=\"builtin.phong\" group=\"builtin.forward\" order=\"300\">\n<registers>\n  <register name=\"builtin.basic\"/>\n  <register name=\"builtin.buffer\"/>\n</registers>\n<passes>\n  <pass>\n    <glsl>\n      <![CDATA[\n      attribute vec3 position;\n      attribute vec3 normal;\n      attribute vec2 uv;\n\n      @vert {\n      @import \"jthree.builtin.vertex\"\n        uniform mat4 _matPVM;\n        uniform mat4 _matVM;\n      }\n\n      varying vec3 vNormal;\n      varying vec2 vUv;\n      varying vec4 vPosition;\n\n      vec2 calcLightUV(vec4 projectionSpacePos)\n      {\n         return (projectionSpacePos.xy/projectionSpacePos.w+vec2(1,1))/2.;\n      }\n\n      @vert{\n        void main(void)\n        {\n          BasicVertexTransformOutput o =  basicVertexTransform(position,normal,uv,_matPVM,_matVM);\n          gl_Position = vPosition = o.position;\n          //gl_Position.xyz *= vec3(position.x,position.x * position.z,position.z);\n          vNormal = o.normal;\n          vUv = o.uv;\n        }\n      }\n\n      @frag{\n        @{register:1,type:\"buffer\",name:\"DLIGHT\"}\n        uniform sampler2D _dlBuffer;\n        @{register:2,type:\"buffer\",name:\"SLIGHT\"}\n        uniform sampler2D _slBuffer;\n        uniform vec4 diffuse;\n        uniform vec3 specular;\n        uniform vec4 ambient;\n        uniform vec3 ambientCoefficient;\n        uniform float brightness;\n        @{register:3,flag:\"_textureUsed\"}\n        uniform sampler2D texture;\n        uniform int _textureUsed;\n        void main(void)\n        {\n          gl_FragColor=vec4(0,0,0,1);\n          gl_FragColor.rgb+=ambient.rgb;\n          ////calculate light uv\n          vec2 lightUV=calcLightUV(vPosition);\n          vec3 d = _textureUsed == 1 ? texture2D(texture,vUv).rgb : diffuse.rgb;\n          gl_FragColor.rgb+= d * texture2D(_dlBuffer,lightUV).rgb+specular.rgb *texture2D(_slBuffer,lightUV).rgb;\n          gl_FragColor.rgb += ambient.rgb;\n        }\n      }\n      ]]>\n    </glsl>\n  </pass>\n</passes>\n</material>\n"
},{}],54:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<material name=\"builtin.solid\" group=\"builtin.forward\" order=\"300\">\n<registers>\n  <register name=\"builtin.basic\"/>\n</registers>\n<passes>\n  <pass>\n    <glsl>\n      <![CDATA[\n      attribute vec3 position;\n      varying vec4 vPosition;\n\n      @vert {\n        uniform mat4 _matPVM;\n\n        void main(void)\n        {\n          gl_Position = vPosition = _matPVM * vec4(position,1.0);\n        }\n      }\n\n      @frag {\n        uniform vec4 color;\n\n        void main(void)\n        {\n          gl_FragColor = color;\n        }\n      }\n\n      ]]>\n    </glsl>\n  </pass>\n</passes>\n</material>\n"
},{}],55:[function(require,module,exports){
module.exports = "vec3 pack_float(float f){\n   const vec3 bit_shift = vec3( 256.0*256.0, 256.0, 1.0);\n   const vec3 bit_mask = vec3(0.0, 1.0/256.0, 1.0/256.0);\n   vec3 res = fract(f * bit_shift);\n   res -= res.xxy * bit_mask;\n   return res;\n}\n\nvoid main(void)\n{\n  gl_FragColor = vec4(pack_float(vPosition.z/vPosition.w/2. + 0.5),1.0);\n}\n"
},{}],56:[function(require,module,exports){
module.exports = "struct BasicVertexTransformOutput\n{\n  vec4 position;\n  vec3 normal;\n  vec2 uv;\n};\n\nBasicVertexTransformOutput basicVertexTransform(vec3 position,vec3 normal,vec2 uv,mat4 mvp,mat4 mv){\n  return BasicVertexTransformOutput(mvp*vec4(position,1.0),normalize((mv*vec4(normal,0)).xyz),uv);\n}\n"
},{}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectEEWithID2 = require("../../Base/JThreeObjectEEWithID");

var _JThreeObjectEEWithID3 = _interopRequireDefault(_JThreeObjectEEWithID2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* Basement class for any Materials.
* Material is basically meaning what shader will be used or what shader variable will passed.
* In jThree v3,these renderer are implemented with deferred rendering method.
* That method needs to use a lot of shaders and shader variables.
* Therefore,materials of jThree is not only visceral Materials.
* Some of materials are intended to use in deferred rendering stage(G-buffer generation stage is one of example).
* This is one of significant difference between jThree and the other Web3D libraries in Material.
*/

var Material = function (_JThreeObjectEEWithID) {
    _inherits(Material, _JThreeObjectEEWithID);

    function Material() {
        var _Object$getPrototypeO;

        _classCallCheck(this, Material);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Material)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.shaderVariables = {};
        /**
        * Whether this material was initialized already or not.
        */
        _this._initialized = false;
        return _this;
    }
    /**
    * Set loaded status of this material.
    * If first argument of boolean was passed,the status of loaded will be changed in that value.
    * If first argument of boolean was not passed, the status of loaded will be changed in true.
    */


    _createClass(Material, [{
        key: "__setLoaded",
        value: function __setLoaded(flag) {
            flag = typeof flag === "undefined" ? true : flag;
            this._initialized = flag;
            if (flag) {
                this.emit("ready", this);
            }
        }
        /**
         * Provides the flag this material finished loading or not.
         */

    }, {
        key: "dispose",
        value: function dispose() {
            return;
        }
        /**
        * Should return how many times required to render this material.
        * If you render some of model with edge,it can be 2 or greater.
        * Because it needs rendering edge first,then rendering forward shading.
        */

    }, {
        key: "getPassCount",
        value: function getPassCount(techniqueIndex) {
            return 1;
        }
        /**
        * Apply configuration of program.
        * This is used for passing variables,using programs,binding index buffer.
        */

    }, {
        key: "apply",
        value: function apply(matArg) {
            if (!this._initialized) {
                return;
            }
            this.emit("apply", matArg);
            return;
        }
    }, {
        key: "registerMaterialVariables",
        value: function registerMaterialVariables(renderer, pWrapper, uniforms, mergedShaderVariables) {
            for (var valName in uniforms) {
                var uniform = uniforms[valName];
                if (valName[0] === "_") {
                    continue;
                }
                var val = mergedShaderVariables[valName];
                if (typeof val === "undefined" || val == null) {
                    this._whenMaterialVariableNotFound(renderer, pWrapper, uniform);
                    continue;
                }
                if (!uniform.isArray) {
                    switch (uniform.variableType) {
                        case "vec2":
                        case "vec3":
                        case "vec4":
                            pWrapper.uniformVector(valName, val);
                            continue;
                        case "mat4":
                            pWrapper.uniformMatrix(valName, val);
                            continue;
                        case "float":
                            pWrapper.uniformFloat(valName, val);
                            continue;
                        case "int":
                            pWrapper.uniformInt(valName, val);
                            continue;
                        case "sampler2D":
                        case "samplerCube":
                            var registerAnnotation = uniform.variableAnnotation["register"];
                            var register = undefined;
                            if (registerAnnotation) {
                                register = parseInt(registerAnnotation, 10);
                            } else {
                                register = 0;
                            }
                            pWrapper.uniformSampler(valName, val, register);
                            if (uniform.variableAnnotation["flag"]) {
                                pWrapper.uniformInt(uniform.variableAnnotation["flag"], 1);
                            }
                            continue;
                        default:
                            console.warn("Unknown variable type " + uniform.variableType);
                    }
                } else {
                    switch (uniform.variableType) {
                        case "vec2":
                        case "vec3":
                        case "vec4":
                            pWrapper.uniformVectorArray(valName, val);
                            continue;
                        case "float":
                            pWrapper.uniformFloatArray(valName, val);
                            continue;
                        case "int":
                            pWrapper.uniformIntArray(valName, val);
                            continue;
                        case "mat4":
                            pWrapper.uniformMatrixArray(valName, val);
                            continue;
                        default:
                            console.warn("Unknown array variable type " + uniform.variableType + "[]");
                    }
                }
            }
        }
    }, {
        key: "getDrawGeometryLength",
        value: function getDrawGeometryLength(geo) {
            return geo.getDrawLength();
        }
    }, {
        key: "getDrawGeometryOffset",
        value: function getDrawGeometryOffset(geo) {
            return geo.GeometryOffset;
        }
    }, {
        key: "_whenMaterialVariableNotFound",
        value: function _whenMaterialVariableNotFound(renderer, pWrapper, uniform) {
            if (!uniform.isArray) {
                switch (uniform.variableType) {
                    case "float":
                        pWrapper.uniformFloat(uniform.variableName, uniform.variableAnnotation["default"]);
                        return;
                    case "vec2":
                        pWrapper.uniformVector(uniform.variableName, uniform.variableAnnotation["default"]);
                        return;
                    case "vec3":
                        pWrapper.uniformVector(uniform.variableName, uniform.variableAnnotation["default"]);
                        return;
                    case "vec4":
                        pWrapper.uniformVector(uniform.variableName, uniform.variableAnnotation["default"]);
                        return;
                    case "sampler2D":
                        var registerAnnotation = uniform.variableAnnotation["register"];
                        var register = undefined;
                        if (registerAnnotation) {
                            register = parseInt(registerAnnotation, 10);
                        } else {
                            register = 0;
                        }
                        var texture = uniform.variableAnnotation.default ? uniform.variableAnnotation.default : renderer.canvas.alternativeTexture;
                        pWrapper.uniformSampler(uniform.variableName, texture, register);
                        if (uniform.variableAnnotation["flag"]) {
                            pWrapper.uniformInt(uniform.variableAnnotation["flag"], 0);
                        }
                        return;
                    case "samplerCube":
                        var registerCubeAnnotation = uniform.variableAnnotation["register"];
                        var registerCube = undefined;
                        if (registerAnnotation) {
                            registerCube = parseInt(registerCubeAnnotation, 10);
                        } else {
                            registerCube = 0;
                        }
                        pWrapper.uniformSampler(uniform.variableName, renderer.canvas.alternativeCubeTexture, registerCube);
                        if (uniform.variableAnnotation["flag"]) {
                            pWrapper.uniformInt(uniform.variableAnnotation["flag"], 0);
                        }
                        return;
                }
            } else {
                switch (uniform.variableType) {
                    case "float":
                        pWrapper.uniformFloatArray(uniform.variableName, uniform.variableAnnotation["default"]);
                        break;
                    case "vec2":
                    case "vec3":
                    case "vec4":
                        pWrapper.uniformVectorArray(uniform.variableName, uniform.variableAnnotation["default"]);
                        break;
                    case "mat4":
                        pWrapper.uniformMatrixArray(uniform.variableName, uniform.variableAnnotation["default"]);
                        break;
                }
            }
        }
        /**
        * The flag whether this material should be called for rendering.
        */

    }, {
        key: "Initialized",
        get: function get() {
            return this._initialized;
        }
        /**
        * Rendering priorty of this material.
        * If render stage request materials of an specific material group, these list is sorted in this priorty value.
        * So any material with same group id having lower priorty will be rendered later.
        */

    }, {
        key: "Priorty",
        get: function get() {
            return this._priorty;
        }
        /**
        * Group name of this material.
        * This main purpose is mainly intended to be used in RenderStage for filtering materials by puropse of material.
        */

    }, {
        key: "MaterialGroup",
        get: function get() {
            return "builtin.forward";
        }
    }, {
        key: "Enabled",
        get: function get() {
            return true;
        }
    }]);

    return Material;
}(_JThreeObjectEEWithID3.default);

exports.default = Material;

},{"../../Base/JThreeObjectEEWithID":5}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Provides feature to use material to draw specific geometry in specified situation.
 * This is most primitive caller for materials and geometries.
 */

var MaterialDrawer = function () {
    function MaterialDrawer() {
        _classCallCheck(this, MaterialDrawer);
    }

    _createClass(MaterialDrawer, null, [{
        key: "drawForMaterials",
        value: function drawForMaterials(scene, renderStage, object, techniqueCount, techniqueIndex, materialGroup, isWireframed) {
            if (!object.isVisible) {
                return;
            }
            var materials = object.getMaterials(materialGroup);
            for (var i = 0; i < materials.length; i++) {
                MaterialDrawer.drawForMaterial(scene, renderStage, object, techniqueCount, techniqueIndex, materials[i], isWireframed);
            }
        }
    }, {
        key: "drawForMaterial",
        value: function drawForMaterial(scene, renderStage, object, techniqueCount, techniqueIndex, material, isWireframed) {
            if (!material || !material.Initialized || !material.Enabled || !object.isVisible) {
                return;
            }
            var passCount = material.getPassCount(techniqueIndex);
            for (var pass = 0; pass < passCount; pass++) {
                material.apply({
                    scene: scene,
                    renderStage: renderStage,
                    object: object,
                    techniqueIndex: techniqueIndex,
                    techniqueCount: techniqueCount,
                    passIndex: pass,
                    passCount: passCount
                });
                if (isWireframed) {
                    object.Geometry.drawWireframe(renderStage.renderer.canvas, material);
                    return;
                }
                object.Geometry.drawElements(renderStage.renderer.canvas, material);
            }
        }
    }]);

    return MaterialDrawer;
}();

exports.default = MaterialDrawer;

},{}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ImportTransformer = require("../ProgramTransformer/Transformer/ImportTransformer");

var _ImportTransformer2 = _interopRequireDefault(_ImportTransformer);

var _BasicRegisterer = require("../Pass/Registerer/BasicRegisterer");

var _BasicRegisterer2 = _interopRequireDefault(_BasicRegisterer);

var _StageDescriptionRegisterer = require("../Pass/Registerer/StageDescriptionRegisterer");

var _StageDescriptionRegisterer2 = _interopRequireDefault(_StageDescriptionRegisterer);

var _BasicMaterial = require("./BasicMaterial");

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _ProgramTranspiler = require("../ProgramTransformer/ProgramTranspiler");

var _ProgramTranspiler2 = _interopRequireDefault(_ProgramTranspiler);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _BufferRegisterer = require("../Pass/Registerer/BufferRegisterer");

var _BufferRegisterer2 = _interopRequireDefault(_BufferRegisterer);

var _TimeRegisterer = require("../Pass/Registerer/TimeRegisterer");

var _TimeRegisterer2 = _interopRequireDefault(_TimeRegisterer);

var _BasicCacheResolver = require("../Resources/BasicCacheResolver");

var _BasicCacheResolver2 = _interopRequireDefault(_BasicCacheResolver);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A ContextComponent provides the feature to manage materials.
 * @type {[type]}
 */

var MaterialManager = function () {
    function MaterialManager() {
        _classCallCheck(this, MaterialManager);

        this._uniformRegisters = {};
        this._materialDocuments = {};
        this._chunkLoader = new _BasicCacheResolver2.default();
        this.addShaderChunk("builtin.packing", require("./BuiltIn/Chunk/_Packing.glsl"));
        this.addShaderChunk("builtin.gbuffer-packing", require("./BuiltIn/GBuffer/_GBufferPacking.glsl"));
        this.addShaderChunk("jthree.builtin.vertex", require("./BuiltIn/Vertex/_BasicVertexTransform.glsl"));
        this.addShaderChunk("jthree.builtin.shadowfragment", require("./BuiltIn/ShadowMap/_ShadowMapFragment.glsl"));
        this.addShaderChunk("builtin.gbuffer-reader", require("./BuiltIn/Light/Chunk/_LightAccumulation.glsl"));
        this.addUniformRegister(_BasicRegisterer2.default);
        this.addUniformRegister(_TimeRegisterer2.default);
        // this.addUniformRegister(TextureRegister);
        this.addUniformRegister(_BufferRegisterer2.default);
        this.addUniformRegister(_StageDescriptionRegisterer2.default);
        this.registerMaterial(require("./BuiltIn/Materials/Phong.xmml"));
        this.registerMaterial(require("./BuiltIn/Materials/SolidColor.xmml"));
    }

    _createClass(MaterialManager, [{
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.MaterialManager;
        }
        /**
         * Add shader chunk code to be stored.
         * @param {string} key shader chunk key
         * @param {string} val shader chunk code
         */

    }, {
        key: "addShaderChunk",
        value: function addShaderChunk(key, val) {
            this._chunkLoader.pushLoaded(key, _ProgramTranspiler2.default.parseInternalImport(val, this));
        }
    }, {
        key: "loadChunks",
        value: function loadChunks(srcs) {
            var _this = this;

            return Promise.all(srcs.map(function (src) {
                return _this._loadChunk(src);
            }));
        }
        /**
         * Get shader chunk code from storage
         * @param  {string} key shader chunk key
         * @return {string}     stored shader chunk code
         */

    }, {
        key: "getShaderChunk",
        value: function getShaderChunk(key) {
            return this._chunkLoader.fromCache(key);
        }
    }, {
        key: "addUniformRegister",
        value: function addUniformRegister(registerer) {
            this._uniformRegisters[registerer.prototype["getName"]()] = registerer;
        }
    }, {
        key: "getUniformRegister",
        value: function getUniformRegister(key) {
            return this._uniformRegisters[key];
        }
        /**
         * Register material document(XMML) in material manager
         * @param {string} matDocument Raw xmml parsable string
         * @return {string}             material tag's name attribute
         */

    }, {
        key: "registerMaterial",
        value: function registerMaterial(matDocument) {
            var dom = new DOMParser().parseFromString(matDocument, "text/xml");
            var matTag = dom.querySelector("material");
            var matName = matTag.getAttribute("name");
            if (!matName) {
                console.error("Material name is required attribute,but name was not specified!");
            } else {
                this._materialDocuments[matName] = matDocument;
            }
            return matName;
        }
    }, {
        key: "registerCondition",
        value: function registerCondition(type, checker) {
            // TODO:implement
        }
    }, {
        key: "getConditionChecker",
        value: function getConditionChecker(type) {
            return null;
            // todo:implement
        }
        /**
         * Construct BasicMaterial instance with registered xmml
         * @param  {string}        matName name of the xmml
         * @return {BasicMaterial}         [description]
         */

    }, {
        key: "constructMaterial",
        value: function constructMaterial(matName) {
            var matDoc = this._materialDocuments[matName];
            if (!matDoc) {
                // console.error(`Specified material name '${matName}' was not found!`);
                return undefined;
            } else {
                return new _BasicMaterial2.default(matDoc, matName);
            }
        }
    }, {
        key: "_loadChunk",
        value: function _loadChunk(src) {
            var _this2 = this;

            return this._chunkLoader.fetch(src, function (absPath) {
                var deferred = _q2.default.defer();
                var xhr = new XMLHttpRequest();
                xhr.open("GET", absPath, true);
                xhr.setRequestHeader("Accept", "text");
                xhr.onload = function () {
                    _this2.loadChunks(_ImportTransformer2.default.getImports(xhr.responseText));
                    _ImportTransformer2.default.parseImport(xhr.responseText).then(function (source) {
                        deferred.resolve(source);
                    });
                };
                xhr.onerror = function (err) {
                    deferred.reject(err);
                };
                xhr.send(null);
                return deferred.promise;
            });
        }
    }]);

    return MaterialManager;
}();

exports.default = MaterialManager;

},{"../../ContextComponents":8,"../Pass/Registerer/BasicRegisterer":63,"../Pass/Registerer/BufferRegisterer":64,"../Pass/Registerer/StageDescriptionRegisterer":66,"../Pass/Registerer/TimeRegisterer":67,"../ProgramTransformer/ProgramTranspiler":69,"../ProgramTransformer/Transformer/ImportTransformer":73,"../Resources/BasicCacheResolver":112,"./BasicMaterial":36,"./BuiltIn/Chunk/_Packing.glsl":39,"./BuiltIn/GBuffer/_GBufferPacking.glsl":42,"./BuiltIn/Light/Chunk/_LightAccumulation.glsl":44,"./BuiltIn/Materials/Phong.xmml":53,"./BuiltIn/Materials/SolidColor.xmml":54,"./BuiltIn/ShadowMap/_ShadowMapFragment.glsl":55,"./BuiltIn/Vertex/_BasicVertexTransform.glsl":56,"q":338}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DefaultValuePreProcessor = require("../../Pass/DefaultValuePreProcessor");

var _DefaultValuePreProcessor2 = _interopRequireDefault(_DefaultValuePreProcessor);

var _ProgramTranspiler = require("../../ProgramTransformer/ProgramTranspiler");

var _ProgramTranspiler2 = _interopRequireDefault(_ProgramTranspiler);

var _XMLRenderConfigUtility = require("../../Pass/XMLRenderConfigUtility");

var _XMLRenderConfigUtility2 = _interopRequireDefault(_XMLRenderConfigUtility);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _BasicCacheResolver = require("../../Resources/BasicCacheResolver");

var _BasicCacheResolver2 = _interopRequireDefault(_BasicCacheResolver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The static class to parse XMML.
 */

var XMMLParser = function () {
    function XMMLParser() {
        _classCallCheck(this, XMMLParser);
    }

    _createClass(XMMLParser, null, [{
        key: "parse",

        /**
         * Parse the xmml document.
         * @return {IXMMLDescription} [description]
         */
        value: function parse(name, source) {
            return new Promise(function (resolve, reject) {
                XMMLParser._resolver.fetch(name, function (identity) {
                    return XMMLParser._parseXMML(name, source);
                }).then(function (result) {
                    resolve(result);
                });
            });
        }
    }, {
        key: "_parseXMML",
        value: function _parseXMML(name, source) {
            return new Promise(function (resolve, reject) {
                var dom = XMMLParser._domParser.parseFromString(source, "text/xml");
                var result = {
                    name: name
                };
                // Parse material element
                var materialElem = XMMLParser._getSingleElement("material", dom);
                result.group = materialElem.getAttribute("group");
                result.order = parseFloat(materialElem.getAttribute("order"));
                // Parse registers
                var registersElem = XMMLParser._getSingleElement("registers", materialElem);
                result.registerers = XMMLParser._initializeUniformRegisters(registersElem);
                // Parse passes
                var passesElem = XMMLParser._getSingleElement("passes", materialElem);
                XMMLParser._instanciatePasses(passesElem, name, result.registerers).then(function (p) {
                    result.pass = p;
                    resolve(result);
                });
            });
        }
    }, {
        key: "_initializeUniformRegisters",
        value: function _initializeUniformRegisters(elem) {
            var mm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.MaterialManager);
            var registerElems = XMMLParser._getElements("register", elem);
            return registerElems.map(function (r) {
                return new (mm.getUniformRegister(r.getAttribute("name")))();
            });
        }
    }, {
        key: "_instanciatePasses",
        value: function _instanciatePasses(passes, materialName, registerers) {
            var pass = XMMLParser._getElements("pass", passes);
            return Promise.all(pass.map(function (p, i) {
                return new Promise(function (resolve, reject) {
                    var renderconfig = _XMLRenderConfigUtility2.default.parseRenderConfig(p);
                    var glsl = XMMLParser._getSingleElement("glsl", p);
                    var result = {
                        renderConfig: renderconfig,
                        passIndex: i
                    };
                    _ProgramTranspiler2.default.parseCombined(glsl.textContent).then(function (desc) {
                        result.programDescription = desc;
                        result.program = XMMLParser._constructProgram(materialName, i, desc);
                        return _DefaultValuePreProcessor2.default.preprocess(desc.uniforms);
                    }).then(function () {
                        return Promise.all(registerers.map(function (r) {
                            return r.preprocess(result, result.programDescription.uniforms);
                        }));
                    }).then(function () {
                        resolve(result);
                    });
                });
            }));
        }
    }, {
        key: "_constructProgram",
        value: function _constructProgram(name, index, desc) {
            var idPrefix = name + index;
            var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
            var fs = rm.createShader(idPrefix + "-fs", desc.fragment, WebGLRenderingContext.FRAGMENT_SHADER);
            var vs = rm.createShader(idPrefix + "-vs", desc.vertex, WebGLRenderingContext.VERTEX_SHADER);
            fs.loadAll();
            vs.loadAll();
            return rm.createProgram(idPrefix + "-program", [vs, fs]);
        }
    }, {
        key: "_getElements",
        value: function _getElements(name, elem) {
            var result = [];
            var elems = elem.getElementsByTagName(name);
            for (var i = 0; i < elems.length; i++) {
                result.push(elems.item(i));
            }
            return result;
        }
    }, {
        key: "_getSingleElement",
        value: function _getSingleElement(name, elem) {
            var result = XMMLParser._getElements(name, elem);
            if (result.length === 1) {
                return result[0];
            } else if (result.length === 0) {
                throw new Error("The mandatory element " + name + " was required, but not found");
            } else {
                throw new Error("The element " + name + " requires to exist in single. But there is " + result.length + " count of elements");
            }
        }
    }]);

    return XMMLParser;
}();

XMMLParser._resolver = new _BasicCacheResolver2.default();
XMMLParser._domParser = new DOMParser();
exports.default = XMMLParser;

},{"../../../ContextComponents":8,"../../../JThreeContext":267,"../../Pass/DefaultValuePreProcessor":61,"../../Pass/XMLRenderConfigUtility":68,"../../ProgramTransformer/ProgramTranspiler":69,"../../Resources/BasicCacheResolver":112}],61:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _MatrixArray = require("../../Math/MatrixArray");

var _MatrixArray2 = _interopRequireDefault(_MatrixArray);

var _VectorArray = require("../../Math/VectorArray");

var _VectorArray2 = _interopRequireDefault(_VectorArray);

var _Matrix = require("../../Math/Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

var _Vector = require("../../Math/Vector2");

var _Vector2 = _interopRequireDefault(_Vector);

var _Vector3 = require("../../Math/Vector3");

var _Vector4 = _interopRequireDefault(_Vector3);

var _Vector5 = require("../../Math/Vector4");

var _Vector6 = _interopRequireDefault(_Vector5);

var _lodash = require("lodash.isarray");

var _lodash2 = _interopRequireDefault(_lodash);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DefaultValuePreProcessor = function () {
    function DefaultValuePreProcessor() {
        _classCallCheck(this, DefaultValuePreProcessor);
    }

    _createClass(DefaultValuePreProcessor, null, [{
        key: "preprocess",
        value: function preprocess(uniforms) {
            var tasks = [];

            var _loop = function _loop(variableName) {
                var uniform = uniforms[variableName];
                if (!uniform.isArray) {
                    switch (uniform.variableType) {
                        case "float":
                            tasks.push(DefaultValuePreProcessor._syncPromise(function () {
                                DefaultValuePreProcessor._forFloat(uniform);
                            }));
                            break;
                        case "vec2":
                            tasks.push(DefaultValuePreProcessor._syncPromise(function () {
                                DefaultValuePreProcessor._forVec2(uniform);
                            }));
                            break;
                        case "vec3":
                            tasks.push(DefaultValuePreProcessor._syncPromise(function () {
                                DefaultValuePreProcessor._forVec3(uniform);
                            }));
                            break;
                        case "vec4":
                            tasks.push(DefaultValuePreProcessor._syncPromise(function () {
                                DefaultValuePreProcessor._forVec4(uniform);
                            }));
                            break;
                        case "mat4":
                            tasks.push(DefaultValuePreProcessor._syncPromise(function () {
                                DefaultValuePreProcessor._forMat4(uniform);
                            }));
                            break;
                        case "sampler2D":
                            tasks.push(DefaultValuePreProcessor._forSampler2D(uniform));
                    }
                } else {
                    // When this uniform is array.
                    switch (uniform.variableType) {
                        case "float":
                            tasks.push(DefaultValuePreProcessor._syncPromise(function () {
                                DefaultValuePreProcessor._forFloatArray(uniform);
                            }));
                            break;
                        case "vec2":
                            tasks.push(DefaultValuePreProcessor._syncPromise(function () {
                                DefaultValuePreProcessor._forVectorarray(2, uniform);
                            }));
                            break;
                        case "vec3":
                            tasks.push(DefaultValuePreProcessor._syncPromise(function () {
                                DefaultValuePreProcessor._forVectorarray(3, uniform);
                            }));
                            break;
                        case "vec4":
                            tasks.push(DefaultValuePreProcessor._syncPromise(function () {
                                DefaultValuePreProcessor._forVectorarray(4, uniform);
                            }));
                            break;
                        case "mat4":
                            tasks.push(DefaultValuePreProcessor._syncPromise(function () {
                                DefaultValuePreProcessor._forMat4Array(uniform);
                            }));
                            break;
                    }
                }
            };

            for (var variableName in uniforms) {
                _loop(variableName);
            }
            return _q2.default.all(tasks).then(function () {
                for (var name in uniforms) {
                    uniforms[name].value = uniforms[name].variableAnnotation.default;
                }
            });
        }
    }, {
        key: "_syncPromise",
        value: function _syncPromise(fn) {
            var defer = _q2.default.defer();
            process.nextTick(function () {
                try {
                    fn();
                } catch (e) {
                    defer.reject(e);
                }
                defer.resolve(null);
            });
            return defer.promise;
        }
    }, {
        key: "_forFloat",
        value: function _forFloat(uniform) {
            if (!uniform.variableAnnotation.default) {
                uniform.variableAnnotation.default = 0;
            }
        }
    }, {
        key: "_forFloatArray",
        value: function _forFloatArray(uniform) {
            var defaultArray = uniform.variableAnnotation.default;
            if (defaultArray) {
                if (defaultArray.length !== uniform.arrayLength) {
                    throw new Error("specified array length is unmatch!");
                }
                uniform.variableAnnotation.default = defaultArray;
            } else {
                uniform.variableAnnotation.default = new Array(uniform.arrayLength);
                for (var i = 0; i < uniform.arrayLength; i++) {
                    uniform.variableAnnotation.default[i] = 0; // [0,0,0.....0,0] will be used as default
                }
            }
        }
    }, {
        key: "_forVectorarray",
        value: function _forVectorarray(dimension, uniform) {
            var defaultArray = _VectorArray2.default.zeroVectorArray(dimension, uniform.arrayLength);
            var defaultValue = uniform.variableAnnotation.default;
            if (defaultArray) {
                if ((0, _lodash2.default)(defaultValue)) {
                    if ((0, _lodash2.default)(defaultValue[0])) {
                        for (var i = 0; i < defaultValue.length; i++) {
                            defaultArray.setRawArray(i, defaultValue[i]);
                        }
                    } else {
                        for (var _i = 0; _i < defaultValue.length; _i++) {
                            defaultArray.rawElements[_i] = defaultValue[_i];
                        }
                    }
                } else {
                    throw new Error("Unknown default value '" + defaultValue + "' was specified for variable '" + uniform.variableType + "[] " + uniform.variableName + "'");
                }
            }
            uniform.variableAnnotation.default = defaultArray;
        }
    }, {
        key: "_forVec2",
        value: function _forVec2(uniform) {
            var defaultValue = uniform.variableAnnotation.default;
            var annotations = uniform.variableAnnotation;
            if (defaultValue) {
                if (Array.isArray(defaultValue)) {
                    annotations.default = new _Vector2.default(defaultValue[0], defaultValue[1]); // parse array as vector
                } else if (typeof defaultValue === "string") {
                        annotations.default = _Vector2.default.parse(defaultValue); // parse string representation as vector
                    } else {
                            throw new Error("Unknown default value '" + defaultValue + "' was specified for variable '" + uniform.variableType + " " + uniform.variableName + "'");
                        }
            } else {
                annotations.default = new _Vector2.default(0, 0); // use (0,0) as default when the default annotation was not specified
            }
        }
    }, {
        key: "_forVec3",
        value: function _forVec3(uniform) {
            var defaultValue = uniform.variableAnnotation.default;
            var annotations = uniform.variableAnnotation;
            if (defaultValue) {
                if (Array.isArray(defaultValue)) {
                    annotations.default = new _Vector4.default(defaultValue[0], defaultValue[1], defaultValue[2]); // parse array as vector
                } else if (typeof defaultValue === "string") {
                        annotations.default = _Vector4.default.parse(defaultValue); // parse string representation as vector
                    } else {
                            throw new Error("Unknown default value '" + defaultValue + "' was specified for variable '" + uniform.variableType + " " + uniform.variableName + "'");
                        }
            } else {
                annotations.default = new _Vector4.default(0, 0, 0); // use (0,0,0) as default when the default annotation was not specified
            }
        }
    }, {
        key: "_forVec4",
        value: function _forVec4(uniform) {
            var defaultValue = uniform.variableAnnotation.default;
            var annotations = uniform.variableAnnotation;
            if (defaultValue) {
                if (Array.isArray(defaultValue)) {
                    annotations.default = new _Vector6.default(defaultValue[0], defaultValue[1], defaultValue[2], defaultValue[3]); // parse array as vector
                } else if (typeof defaultValue === "string") {
                        annotations.default = _Vector6.default.parse(defaultValue); // parse string representation as vector
                    } else {
                            throw new Error("Unknown default value '" + defaultValue + "' was specified for variable '" + uniform.variableType + " " + uniform.variableName + "'");
                        }
            } else {
                annotations.default = new _Vector6.default(0, 0, 0, 0); // use (0,0,0,0) as default when the default annotation was not specified
            }
        }
    }, {
        key: "_forMat4",
        value: function _forMat4(uniform) {
            var defaultValue = uniform.variableAnnotation.default;
            var annotations = uniform.variableAnnotation;
            if (defaultValue) {
                if (Array.isArray(defaultValue)) {
                    if (defaultValue.length !== 16) {
                        throw new Error("Default value for mat4 must have 16 elements");
                    }
                    annotations.default = _Matrix2.default.fromElements.apply(_Matrix2.default, defaultValue);
                } else {
                    throw new Error("Unknown default value '" + defaultValue + "' was specified for variable '" + uniform.variableType + " " + uniform.variableName + "'");
                }
            } else {
                annotations.default = _Matrix2.default.identity();
            }
        }
    }, {
        key: "_forMat4Array",
        value: function _forMat4Array(uniform) {
            var defaultValue = uniform.variableAnnotation.default;
            uniform.variableAnnotation.default = _MatrixArray2.default.getIdentityMatrixArray(uniform.arrayLength);
            if (defaultValue) {
                if ((0, _lodash2.default)(defaultValue)) {
                    for (var i = 0; i < defaultValue.length; i++) {
                        uniform.variableAnnotation.default.rawElements[i] = defaultValue[i];
                    }
                }
            }
        }
    }, {
        key: "_forSampler2D",
        value: function _forSampler2D(uniform) {
            var defaultValue = uniform.variableAnnotation.default;
            if (defaultValue) {
                return DefaultValuePreProcessor._resourceManager.loadTexture(defaultValue).then(function (texture) {
                    uniform.variableAnnotation.default = texture;
                });
            } else {
                return DefaultValuePreProcessor._syncPromise(function () {
                    uniform.variableAnnotation.default = null;
                });
            }
        }
    }, {
        key: "_resourceManager",
        get: function get() {
            return _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        }
    }]);

    return DefaultValuePreProcessor;
}();

exports.default = DefaultValuePreProcessor;

}).call(this,require('_process'))

},{"../../ContextComponents":8,"../../JThreeContext":267,"../../Math/Matrix":271,"../../Math/MatrixArray":272,"../../Math/Vector2":277,"../../Math/Vector3":278,"../../Math/Vector4":279,"../../Math/VectorArray":280,"_process":319,"lodash.isarray":331,"q":338}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectWithID2 = require("../../Base/JThreeObjectWithID");

var _JThreeObjectWithID3 = _interopRequireDefault(_JThreeObjectWithID2);

var _XMLRenderConfigUtility = require("./XMLRenderConfigUtility");

var _XMLRenderConfigUtility2 = _interopRequireDefault(_XMLRenderConfigUtility);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MaterialPass = function (_JThreeObjectWithID) {
    _inherits(MaterialPass, _JThreeObjectWithID);

    function MaterialPass(material, pass) {
        _classCallCheck(this, MaterialPass);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MaterialPass).call(this));

        _this._renderConfigureCache = {};
        _this._material = material;
        _this.passDescription = pass;
        return _this;
    }

    _createClass(MaterialPass, [{
        key: "dispose",
        value: function dispose() {
            return;
        }
    }, {
        key: "apply",
        value: function apply(matArg, uniformRegisters, material, shaderVariables) {
            var _this2 = this;

            var gl = matArg.renderStage.gl;
            var pWrapper = this.passDescription.program.getForGL(gl);
            var renderConfig = this._fetchRenderConfigure(matArg);
            _XMLRenderConfigUtility2.default.applyAll(gl, renderConfig);
            // Declare using program before assigning material variables
            pWrapper.useProgram();
            // Apply attribute variables by geometries
            matArg.object.Geometry.useGeometry(pWrapper, this.passDescription.programDescription.attributes);
            // Apply uniform variables
            uniformRegisters.forEach(function (r) {
                r.register(gl, pWrapper, matArg, _this2.passDescription.programDescription.uniforms);
            });
            material.registerMaterialVariables(matArg.renderStage.renderer, pWrapper, this.passDescription.programDescription.uniforms, shaderVariables);
        }
    }, {
        key: "_fetchRenderConfigure",
        value: function _fetchRenderConfigure(matArg) {
            var id = matArg.renderStage.id + matArg.techniqueIndex;
            var result = undefined;
            if (this._renderConfigureCache[id]) {
                result = this._renderConfigureCache[id];
            } else {
                var configure = this._renderConfigureCache[id] = _XMLRenderConfigUtility2.default.mergeRenderConfigure(this.passDescription.renderConfig, matArg.renderStage.getDefaultRendererConfigure(matArg.techniqueIndex));
                result = configure;
            }
            this._material.emit("configure", {
                pass: this,
                passIndex: this.passDescription.passIndex,
                material: this._material,
                configure: result
            });
            return result;
        }
    }]);

    return MaterialPass;
}(_JThreeObjectWithID3.default);

exports.default = MaterialPass;

},{"../../Base/JThreeObjectWithID":6,"./XMLRenderConfigUtility":68}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = require("../../../Math/Vector2");

var _Vector2 = _interopRequireDefault(_Vector);

var _Matrix = require("../../../Math/Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

var _RegistererBase2 = require("./RegistererBase");

var _RegistererBase3 = _interopRequireDefault(_RegistererBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BasicRegisterer = function (_RegistererBase) {
    _inherits(BasicRegisterer, _RegistererBase);

    function BasicRegisterer() {
        _classCallCheck(this, BasicRegisterer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(BasicRegisterer).apply(this, arguments));
    }

    _createClass(BasicRegisterer, [{
        key: "getName",
        value: function getName() {
            return "builtin.basic";
        }
    }, {
        key: "register",
        value: function register(gl, pWrapper, matArg, uniforms) {
            if (uniforms["_matM"]) {
                pWrapper.uniformMatrix("_matM", matArg.object.Transformer.localToGlobal);
            }
            if (uniforms["_matV"]) {
                pWrapper.uniformMatrix("_matV", matArg.renderStage.renderer.camera.viewMatrix);
            }
            if (uniforms["_matP"]) {
                pWrapper.uniformMatrix("_matP", matArg.renderStage.renderer.camera.projectionMatrix);
            }
            if (uniforms["_matVM"]) {
                pWrapper.uniformMatrix("_matVM", _Matrix2.default.multiply(matArg.renderStage.renderer.camera.viewMatrix, matArg.object.Transformer.localToGlobal));
            }
            if (uniforms["_matPV"]) {
                pWrapper.uniformMatrix("_matPV", matArg.renderStage.renderer.camera.viewProjectionMatrix);
            }
            if (uniforms["_matPVM"]) {
                pWrapper.uniformMatrix("_matPVM", matArg.object.Transformer.calculateMVPMatrix(matArg.renderStage.renderer));
            }
            if (uniforms["_matIP"]) {
                pWrapper.uniformMatrix("_matIP", matArg.renderStage.renderer.camera.invProjectionMatrix);
            }
            if (uniforms["_eyePosition"]) {
                pWrapper.uniformVector("_eyePosition", matArg.renderStage.renderer.camera.Transformer.GlobalPosition);
            }
            if (uniforms["_farClip"]) {
                pWrapper.uniformFloat("_farClip", matArg.renderStage.renderer.camera.Far);
            }
            if (uniforms["_nearClip"]) {
                pWrapper.uniformFloat("_nearClip", matArg.renderStage.renderer.camera.Near);
            }
            if (uniforms["_resolution"]) {
                var region = matArg.renderStage.renderer.region;
                pWrapper.uniformVector("_resolution", new _Vector2.default(region.Width, region.Height));
            }
        }
    }]);

    return BasicRegisterer;
}(_RegistererBase3.default);

exports.default = BasicRegisterer;

},{"../../../Math/Matrix":271,"../../../Math/Vector2":277,"./RegistererBase":65}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RBO = require("../../Resources/RBO/RBO");

var _RBO2 = _interopRequireDefault(_RBO);

var _RegistererBase2 = require("./RegistererBase");

var _RegistererBase3 = _interopRequireDefault(_RegistererBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BufferRegitserer = function (_RegistererBase) {
    _inherits(BufferRegitserer, _RegistererBase);

    function BufferRegitserer() {
        _classCallCheck(this, BufferRegitserer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(BufferRegitserer).apply(this, arguments));
    }

    _createClass(BufferRegitserer, [{
        key: "getName",
        value: function getName() {
            return "builtin.buffer";
        }
    }, {
        key: "register",
        value: function register(gl, pWrapper, matArg, uniforms) {
            for (var variableName in uniforms) {
                var uniform = uniforms[variableName];
                if (variableName[0] !== "_" || uniform.variableType !== "sampler2D") {
                    continue;
                }
                if (uniform.variableAnnotation["type"] === "buffer") {
                    var bufferName = uniform.variableAnnotation["name"];
                    if (!bufferName || !matArg.renderStage.bufferTextures[bufferName]) {
                        continue;
                    }
                    var register = uniform.variableAnnotation["register"];
                    if (!register) {
                        register = 0;
                    }
                    if (matArg.renderStage.bufferTextures[bufferName] instanceof _RBO2.default) {
                        throw new Error("RBO can not be acceptable for shader argument");
                    }
                    pWrapper.uniformSampler(variableName, matArg.renderStage.bufferTextures[bufferName], register);
                }
            }
        }
    }]);

    return BufferRegitserer;
}(_RegistererBase3.default);

exports.default = BufferRegitserer;

},{"../../Resources/RBO/RBO":122,"./RegistererBase":65}],65:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Uniform variable registerer base. This class process uniform variables with '_' as initial.
 *
 * Uniform変数の登録クラスの基底クラス。このクラスは_から始まる変数名を持つuniform変数を処理する。
 */

var RegistererBase = function () {
    function RegistererBase() {
        _classCallCheck(this, RegistererBase);
    }

    _createClass(RegistererBase, [{
        key: "preprocess",

        /**
         * Preprocessing for uniform variables.
         * @param {WebGLRenderingContext}   gl       [description]
         * @param {ProgramWrapper}          pWrapper [description]
         * @param {IVariableDescription }}      uniforms      [description]
         */
        value: function preprocess(pass, uniforms) {
            var defer = _q2.default.defer();
            process.nextTick(function () {
                defer.resolve(null);
            });
            return defer.promise;
        }
    }]);

    return RegistererBase;
}();

exports.default = RegistererBase;

}).call(this,require('_process'))

},{"_process":319,"q":338}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RegistererBase2 = require("./RegistererBase");

var _RegistererBase3 = _interopRequireDefault(_RegistererBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var StageDescriptionRegisterer = function (_RegistererBase) {
    _inherits(StageDescriptionRegisterer, _RegistererBase);

    function StageDescriptionRegisterer() {
        _classCallCheck(this, StageDescriptionRegisterer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(StageDescriptionRegisterer).apply(this, arguments));
    }

    _createClass(StageDescriptionRegisterer, [{
        key: "getName",
        value: function getName() {
            return "builtin.stageInfo";
        }
    }, {
        key: "register",
        value: function register(gl, pWrapper, matArg, uniforms) {
            if (uniforms["_techniqueIndex"]) {
                pWrapper.uniformInt("_techniqueIndex", matArg.techniqueIndex);
            }
            if (uniforms["_passIndex"]) {
                pWrapper.uniformInt("_passIndex", matArg.passIndex);
            }
            if (uniforms["_techniqueCount"]) {
                pWrapper.uniformInt("_techniqueCount", matArg.techniqueCount);
            }
            if (uniforms["_passCount"]) {
                pWrapper.uniformInt("_passCount", matArg.passCount);
            }
        }
    }]);

    return StageDescriptionRegisterer;
}(_RegistererBase3.default);

exports.default = StageDescriptionRegisterer;

},{"./RegistererBase":65}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RegistererBase2 = require("./RegistererBase");

var _RegistererBase3 = _interopRequireDefault(_RegistererBase2);

var _Vector = require("../../../Math/Vector4");

var _Vector2 = _interopRequireDefault(_Vector);

var _JThreeContext = require("../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TimeRegisterer = function (_RegistererBase) {
    _inherits(TimeRegisterer, _RegistererBase);

    function TimeRegisterer() {
        _classCallCheck(this, TimeRegisterer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(TimeRegisterer).apply(this, arguments));
    }

    _createClass(TimeRegisterer, [{
        key: "getName",
        value: function getName() {
            return "builtin.time";
        }
    }, {
        key: "register",
        value: function register(gl, pWrapper, matArg, uniforms) {
            if (uniforms["_Time"]) {
                var timer = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.Timer);
                if (uniforms["_Time"].variableType === "float") {
                    pWrapper.uniformFloat("_Time", timer.time);
                } else if (uniforms["_Time"].variableType === "vec4") {
                    var time = timer.time;
                    pWrapper.uniformVector("_Time", new _Vector2.default(time / 20, time, time * 2, time * 3));
                }
            }
            if (uniforms["_SinTime"]) {
                var _timer = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.Timer);
                if (uniforms["_SinTime"].variableType === "float") {
                    pWrapper.uniformFloat("_SinTime", Math.sin(_timer.time));
                } else if (uniforms["_SinTime"].variableType === "vec4") {
                    var _time = _timer.time;
                    pWrapper.uniformVector("_SinTime", new _Vector2.default(Math.sin(_time / 8), Math.sin(_time / 4), Math.sin(_time / 2), Math.sin(_time)));
                }
            }
            if (uniforms["_CosTime"]) {
                var _timer2 = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.Timer);
                if (uniforms["_CosTime"].variableType === "float") {
                    var _time2 = _timer2.time;
                    pWrapper.uniformFloat("_CosTime", Math.cos(_time2));
                } else if (uniforms["_CosTime"].variableType === "vec4") {
                    var _time3 = _timer2.time;
                    pWrapper.uniformVector("_CosTime", new _Vector2.default(Math.cos(_time3 / 8), Math.cos(_time3 / 4), Math.cos(_time3 / 2), Math.cos(_time3)));
                }
            }
        }
    }]);

    return TimeRegisterer;
}(_RegistererBase3.default);

exports.default = TimeRegisterer;

},{"../../../ContextComponents":8,"../../../JThreeContext":267,"../../../Math/Vector4":279,"./RegistererBase":65}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLEnumParser = require("../Canvas/GL/GLEnumParser");

var _GLEnumParser2 = _interopRequireDefault(_GLEnumParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var XMLRenderConfigureUtility = function () {
    function XMLRenderConfigureUtility() {
        _classCallCheck(this, XMLRenderConfigureUtility);
    }

    _createClass(XMLRenderConfigureUtility, null, [{
        key: "parseRenderConfig",

        /**
         * Construct renderer configuration preferences from element containing render configuration tags as children.
         * @param  {Element}                     parent    [description]
         * @return {IRenderStageRenderConfigure}           [description]
         */
        value: function parseRenderConfig(parent) {
            var target = {};
            XMLRenderConfigureUtility._parseCullConfigure(parent, target);
            XMLRenderConfigureUtility._parseBlendConfigure(parent, target);
            XMLRenderConfigureUtility._parseDepthConfigure(parent, target);
            XMLRenderConfigureUtility._parseMaskConfigure(parent, target);
            return target;
        }
    }, {
        key: "applyAll",
        value: function applyAll(gl, config) {
            XMLRenderConfigureUtility._applyCullConfigureToGL(gl, config.cullOrientation !== "NONE", config.cullOrientation);
            XMLRenderConfigureUtility._applyBlendFunConfigureToGL(gl, config.blendEnabled, config.blendSrcFactor, config.blendDstFactor);
            XMLRenderConfigureUtility._applyDepthTestConfigureToGL(gl, config.depthEnabled, config.depthMode);
            XMLRenderConfigureUtility._applyMaskConfigureToGL(gl, config.redMask, config.greenMask, config.blueMask, config.alphaMask, config.depthMask);
        }
    }, {
        key: "mergeRenderConfigure",
        value: function mergeRenderConfigure(config, base) {
            var result = {};
            for (var paramName in base) {
                if (typeof config[paramName] === "undefined") {
                    result[paramName] = base[paramName];
                } else {
                    result[paramName] = config[paramName];
                }
            }
            return result;
        }
    }, {
        key: "_parseBoolean",
        value: function _parseBoolean(val, def) {
            if (!val) {
                return def;
            }
            if (val === "true") {
                return true;
            }
            return false;
        }
    }, {
        key: "_parseMaskConfigure",
        value: function _parseMaskConfigure(elem, target) {
            var maskNode = elem.getElementsByTagName("mask").item(0);
            if (maskNode) {
                var redMaskStr = maskNode.getAttribute("red");
                var greenMaskStr = maskNode.getAttribute("green");
                var blueMaskStr = maskNode.getAttribute("blue");
                var alphaMaskStr = maskNode.getAttribute("alpha");
                var depthMaskStr = maskNode.getAttribute("depth");
                target.redMask = XMLRenderConfigureUtility._parseBoolean(redMaskStr, undefined);
                target.greenMask = XMLRenderConfigureUtility._parseBoolean(greenMaskStr, undefined);
                target.blueMask = XMLRenderConfigureUtility._parseBoolean(blueMaskStr, undefined);
                target.alphaMask = XMLRenderConfigureUtility._parseBoolean(alphaMaskStr, undefined);
                target.depthMask = XMLRenderConfigureUtility._parseBoolean(depthMaskStr, undefined);
            }
        }
    }, {
        key: "_parseCullConfigure",
        value: function _parseCullConfigure(elem, target) {
            var cullNode = elem.getElementsByTagName("cull").item(0);
            if (cullNode) {
                var mode = cullNode.getAttribute("mode");
                if (!mode) {
                    target.cullOrientation = "BACK";
                } else {
                    target.cullOrientation = mode;
                }
            }
        }
    }, {
        key: "_parseBlendConfigure",
        value: function _parseBlendConfigure(elem, target) {
            var blendNode = elem.getElementsByTagName("blend").item(0);
            if (blendNode) {
                var enabledStr = blendNode.getAttribute("enabled");
                var srcFactorStr = blendNode.getAttribute("src");
                var dstFactorStr = blendNode.getAttribute("dst");
                target.blendEnabled = XMLRenderConfigureUtility._parseBoolean(enabledStr, true);
                target.blendSrcFactor = srcFactorStr || undefined;
                target.blendDstFactor = dstFactorStr || undefined;
            }
        }
    }, {
        key: "_parseDepthConfigure",
        value: function _parseDepthConfigure(elem, target) {
            var depthNode = elem.getElementsByTagName("depth").item(0);
            if (depthNode) {
                var enabledStr = depthNode.getAttribute("enabled");
                var modeStr = depthNode.getAttribute("mode");
                target.depthEnabled = XMLRenderConfigureUtility._parseBoolean(enabledStr, true);
                target.depthMode = modeStr || undefined;
            }
        }
    }, {
        key: "_applyCullConfigureToGL",
        value: function _applyCullConfigureToGL(gl, enabled, mode) {
            if (enabled) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(_GLEnumParser2.default.parseCullMode(mode));
            } else {
                gl.disable(gl.CULL_FACE);
            }
        }
    }, {
        key: "_applyDepthTestConfigureToGL",
        value: function _applyDepthTestConfigureToGL(gl, enabled, mode) {
            if (enabled) {
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(_GLEnumParser2.default.parseDepthFunc(mode));
            } else {
                gl.disable(gl.DEPTH_TEST);
            }
        }
    }, {
        key: "_applyBlendFunConfigureToGL",
        value: function _applyBlendFunConfigureToGL(gl, enabled, src, dst) {
            if (enabled) {
                gl.enable(gl.BLEND);
                gl.blendFunc(_GLEnumParser2.default.parseBlendFunc(src), _GLEnumParser2.default.parseBlendFunc(dst));
            } else {
                gl.disable(gl.BLEND);
            }
        }
    }, {
        key: "_applyMaskConfigureToGL",
        value: function _applyMaskConfigureToGL(gl, red, green, blue, alpha, depth) {
            gl.colorMask(red, green, blue, alpha);
            gl.depthMask(depth);
        }
    }]);

    return XMLRenderConfigureUtility;
}();

exports.default = XMLRenderConfigureUtility;

},{"../Canvas/GL/GLEnumParser":19}],69:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RemoveAttributeVariableTransformer = require("./Transformer/RemoveAttributeVariableTransformer");

var _RemoveAttributeVariableTransformer2 = _interopRequireDefault(_RemoveAttributeVariableTransformer);

var _RemoveVariableAnnotationsTransformer = require("./Transformer/RemoveVariableAnnotationsTransformer");

var _RemoveVariableAnnotationsTransformer2 = _interopRequireDefault(_RemoveVariableAnnotationsTransformer);

var _SourceSeparateTransformer = require("./Transformer/SourceSeparateTransformer");

var _SourceSeparateTransformer2 = _interopRequireDefault(_SourceSeparateTransformer);

var _PrecisionComplementTransformer = require("./Transformer/PrecisionComplementTransformer");

var _PrecisionComplementTransformer2 = _interopRequireDefault(_PrecisionComplementTransformer);

var _PrecisionParser = require("./Transformer/PrecisionParser");

var _PrecisionParser2 = _interopRequireDefault(_PrecisionParser);

var _VariableParser = require("./Transformer/VariableParser");

var _VariableParser2 = _interopRequireDefault(_VariableParser);

var _ImportTransformer = require("./Transformer/ImportTransformer");

var _ImportTransformer2 = _interopRequireDefault(_ImportTransformer);

var _RemoveCommentTransformer = require("./Transformer/RemoveCommentTransformer");

var _RemoveCommentTransformer2 = _interopRequireDefault(_RemoveCommentTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Static parsing methods for XMML (eXtended Material Markup Language).
 * This class provides all useful methods for parsing XMML.
 */

var ProgramTranspiler = function () {
    function ProgramTranspiler() {
        _classCallCheck(this, ProgramTranspiler);
    }

    _createClass(ProgramTranspiler, null, [{
        key: "transform",
        value: function transform(source, transformers) {
            var obj = {
                initialSource: source,
                transformSource: source,
                description: {
                    fragment: null,
                    vertex: null,
                    uniforms: null,
                    attributes: null,
                    fragmentPrecisions: null,
                    vertexPrecisions: null,
                    functions: null
                }
            };
            var promise = new Promise(function (resolve, reject) {
                process.nextTick(function () {
                    resolve(obj);
                });
            });

            var _loop = function _loop(i) {
                promise = promise.then(function (result) {
                    result.initialSource = source;
                    var t = transformers[i];
                    return t.transform(result);
                });
            };

            for (var i = 0; i < transformers.length; i++) {
                _loop(i);
            }
            return promise;
        }
        /**
         * Parse raw XMML
         * @param  {string}               whole string code of XMML
         * @return {IProgramDescription} information of parsed codes.
         */

    }, {
        key: "parseCombined",
        value: function parseCombined(codeString) {
            return ProgramTranspiler.transform(codeString, ProgramTranspiler.transformerGenerator()).then(function (arg) {
                return arg.description;
            });
        }
    }, {
        key: "parseInternalImport",
        value: function parseInternalImport(source, materialManager) {
            while (true) {
                var regexResult = /\s*@import\s+"([^"]+)"/.exec(source);
                if (!regexResult) {
                    break;
                }
                var importContent = undefined;
                importContent = materialManager.getShaderChunk(regexResult[1]);
                if (!importContent) {
                    console.error("Required shader chunk '" + regexResult[1] + "' was not found!!");
                    importContent = "";
                }
                source = source.replace(regexResult[0], "\n" + importContent + "\n");
            }
            return source;
        }
    }]);

    return ProgramTranspiler;
}();

ProgramTranspiler.transformerGenerator = function () {
    var transformers = [];
    transformers.push(new _RemoveCommentTransformer2.default());
    transformers.push(new _ImportTransformer2.default());
    transformers.push(new _VariableParser2.default("uniform"));
    transformers.push(new _VariableParser2.default("attribute"));
    transformers.push(new _SourceSeparateTransformer2.default());
    transformers.push(new _RemoveAttributeVariableTransformer2.default());
    transformers.push(new _RemoveVariableAnnotationsTransformer2.default());
    transformers.push(new _PrecisionParser2.default());
    transformers.push(new _PrecisionComplementTransformer2.default("mediump"));
    return transformers;
};
exports.default = ProgramTranspiler;

}).call(this,require('_process'))

},{"./Transformer/ImportTransformer":73,"./Transformer/PrecisionComplementTransformer":74,"./Transformer/PrecisionParser":75,"./Transformer/RemoveAttributeVariableTransformer":76,"./Transformer/RemoveCommentTransformer":77,"./Transformer/RemoveVariableAnnotationsTransformer":78,"./Transformer/SourceSeparateTransformer":79,"./Transformer/VariableParser":80,"_process":319}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ProgramTransformer2 = require("./ProgramTransformer");

var _ProgramTransformer3 = _interopRequireDefault(_ProgramTransformer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DescriptionTransformer = function (_ProgramTransformer) {
    _inherits(DescriptionTransformer, _ProgramTransformer);

    function DescriptionTransformer(descriptionTransform) {
        _classCallCheck(this, DescriptionTransformer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(DescriptionTransformer).call(this, function (input) {
            var nextDescription = descriptionTransform(input);
            var pt = {
                initialSource: input.initialSource,
                transformSource: input.transformSource,
                description: nextDescription
            };
            return Promise.resolve(pt);
        }));
    }

    return DescriptionTransformer;
}(_ProgramTransformer3.default);

exports.default = DescriptionTransformer;

},{"./ProgramTransformer":71}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ProgramTransformer = function () {
    function ProgramTransformer(_func) {
        _classCallCheck(this, ProgramTransformer);

        this._func = _func;
    }

    _createClass(ProgramTransformer, [{
        key: "transform",
        value: function transform(input) {
            return this._func(input);
        }
    }]);

    return ProgramTransformer;
}();

exports.default = ProgramTransformer;

},{}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ProgramTransformer2 = require("./ProgramTransformer");

var _ProgramTransformer3 = _interopRequireDefault(_ProgramTransformer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SourceTransformer = function (_ProgramTransformer) {
    _inherits(SourceTransformer, _ProgramTransformer);

    function SourceTransformer(sourceTransformer) {
        _classCallCheck(this, SourceTransformer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SourceTransformer).call(this, function (input) {
            var pt = {
                initialSource: input.initialSource,
                transformSource: sourceTransformer(input.transformSource),
                description: input.description
            };
            return Promise.resolve(pt);
        }));
    }

    return SourceTransformer;
}(_ProgramTransformer3.default);

exports.default = SourceTransformer;

},{"./ProgramTransformer":71}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeContext = require("../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _ProgramTransformer2 = require("./Base/ProgramTransformer");

var _ProgramTransformer3 = _interopRequireDefault(_ProgramTransformer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ImportTransformer = function (_ProgramTransformer) {
    _inherits(ImportTransformer, _ProgramTransformer);

    function ImportTransformer() {
        _classCallCheck(this, ImportTransformer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ImportTransformer).call(this, function (transform) {
            return ImportTransformer.parseImport(transform.transformSource).then(function (transformed) {
                return {
                    initialSource: transform.initialSource,
                    transformSource: transformed,
                    description: transform.description
                };
            });
        }));
    }

    _createClass(ImportTransformer, null, [{
        key: "getImports",
        value: function getImports(source) {
            var importArgs = [];
            var importRegex = /\s*@import\s+"([^"]+)"/g;
            while (true) {
                var importEnum = importRegex.exec(source);
                if (!importEnum) {
                    break;
                }
                importArgs.push(importEnum[1]);
            }
            return importArgs;
        }
        /**
         * Parse @import syntax and replace them with corresponded codes.
         * @param  {string}          source          source code XMML to be processed for @import.
         * @param  {MaterialManager} materialManager the material manager instance containing imported codes.
         * @return {string}                          replaced codes.
         */

    }, {
        key: "parseImport",
        value: function parseImport(source) {
            return ImportTransformer._materialManager.loadChunks(ImportTransformer.getImports(source)).then(function () {
                while (true) {
                    var regexResult = /\s*@import\s+"([^"]+)"/.exec(source);
                    if (!regexResult) {
                        break;
                    }
                    var importContent = undefined;
                    importContent = ImportTransformer._materialManager.getShaderChunk(regexResult[1]);
                    if (!importContent) {
                        throw new Error("Required shader chunk '" + regexResult[1] + "' was not found!!");
                    }
                    source = source.replace(regexResult[0], "\n" + importContent + "\n");
                }
                return source;
            });
        }
    }, {
        key: "_materialManager",
        get: function get() {
            return _JThreeContext2.default.getContextComponent(_ContextComponents2.default.MaterialManager);
        }
    }]);

    return ImportTransformer;
}(_ProgramTransformer3.default);

exports.default = ImportTransformer;

},{"../../../ContextComponents":8,"../../../JThreeContext":267,"./Base/ProgramTransformer":71}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DescriptionTransformer = require("./Base/DescriptionTransformer");

var _DescriptionTransformer2 = _interopRequireDefault(_DescriptionTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PrecisionComplementTransformer = function (_DescriptionTransform) {
    _inherits(PrecisionComplementTransformer, _DescriptionTransform);

    function PrecisionComplementTransformer(defaultPrecision) {
        _classCallCheck(this, PrecisionComplementTransformer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(PrecisionComplementTransformer).call(this, function (transform) {
            var description = {
                fragment: transform.description.fragment,
                vertex: transform.description.vertex,
                uniforms: transform.description.uniforms,
                attributes: transform.description.attributes,
                fragmentPrecisions: transform.description.fragmentPrecisions,
                vertexPrecisions: transform.description.vertexPrecisions,
                functions: transform.description.functions
            };
            if (!transform.description.fragmentPrecisions["float"]) {
                description.fragment = PrecisionComplementTransformer._addPrecision(description.fragment, "float", "mediump");
                description.fragmentPrecisions["float"] = defaultPrecision;
            }
            return description;
        }));
    }

    _createClass(PrecisionComplementTransformer, null, [{
        key: "_addPrecision",
        value: function _addPrecision(source, targetType, precision) {
            return "precision " + precision + " " + targetType + ";\n" + source;
        }
    }]);

    return PrecisionComplementTransformer;
}(_DescriptionTransformer2.default);

exports.default = PrecisionComplementTransformer;

},{"./Base/DescriptionTransformer":70}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DescriptionTransformer = require("./Base/DescriptionTransformer");

var _DescriptionTransformer2 = _interopRequireDefault(_DescriptionTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PrecisionParser = function (_DescriptionTransform) {
    _inherits(PrecisionParser, _DescriptionTransform);

    function PrecisionParser() {
        _classCallCheck(this, PrecisionParser);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(PrecisionParser).call(this, function (transform) {
            return {
                fragment: transform.description.fragment,
                vertex: transform.description.vertex,
                uniforms: transform.description.uniforms,
                attributes: transform.description.attributes,
                fragmentPrecisions: PrecisionParser._obtainPrecisions(transform.description.fragment),
                vertexPrecisions: PrecisionParser._obtainPrecisions(transform.description.vertex),
                functions: transform.description.functions
            };
        }));
    }

    _createClass(PrecisionParser, null, [{
        key: "_obtainPrecisions",
        value: function _obtainPrecisions(source) {
            var regex = /\s*precision\s+([a-z]+)\s+([a-z0-9]+)/g;
            var result = {};
            while (true) {
                var found = regex.exec(source);
                if (!found) {
                    break;
                }
                result[found[2]] = found[1];
            }
            return result;
        }
    }]);

    return PrecisionParser;
}(_DescriptionTransformer2.default);

exports.default = PrecisionParser;

},{"./Base/DescriptionTransformer":70}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DescriptionTransformer = require("./Base/DescriptionTransformer");

var _DescriptionTransformer2 = _interopRequireDefault(_DescriptionTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RemoveAttributeVariableTransformer = function (_DescriptionTransform) {
    _inherits(RemoveAttributeVariableTransformer, _DescriptionTransform);

    function RemoveAttributeVariableTransformer() {
        _classCallCheck(this, RemoveAttributeVariableTransformer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(RemoveAttributeVariableTransformer).call(this, function (transform) {
            return {
                fragment: RemoveAttributeVariableTransformer._removeAttributeVariables(transform.description.fragment),
                vertex: transform.description.vertex,
                uniforms: transform.description.uniforms,
                attributes: transform.description.attributes,
                fragmentPrecisions: transform.description.fragmentPrecisions,
                vertexPrecisions: transform.description.vertexPrecisions,
                functions: transform.description.functions
            };
        }));
    }

    _createClass(RemoveAttributeVariableTransformer, null, [{
        key: "_removeAttributeVariables",
        value: function _removeAttributeVariables(source) {
            var regex = /(\s*attribute\s+[a-zA-Z0-9_]+\s+[a-zA-Z0-9_]+;)/;
            while (true) {
                var found = regex.exec(source);
                if (!found) {
                    break;
                }
                source = source.replace(found[0], "");
            }
            return source;
        }
    }]);

    return RemoveAttributeVariableTransformer;
}(_DescriptionTransformer2.default);

exports.default = RemoveAttributeVariableTransformer;

},{"./Base/DescriptionTransformer":70}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SourceTransformer2 = require("./Base/SourceTransformer");

var _SourceTransformer3 = _interopRequireDefault(_SourceTransformer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RemoveCommentTransformer = function (_SourceTransformer) {
    _inherits(RemoveCommentTransformer, _SourceTransformer);

    function RemoveCommentTransformer() {
        _classCallCheck(this, RemoveCommentTransformer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(RemoveCommentTransformer).call(this, function (source) {
            source = RemoveCommentTransformer._removeMultiLineComment(source);
            return RemoveCommentTransformer._removeLineComment(source);
        }));
    }

    _createClass(RemoveCommentTransformer, null, [{
        key: "_removeLineComment",
        value: function _removeLineComment(source) {
            var text = source;
            var regex = /(\/\/.*)/g;
            while (true) {
                var found = regex.exec(text);
                if (!found) {
                    break;
                }
                var beginPoint = found.index;
                text = text.substr(0, beginPoint) + text.substring(beginPoint + found[0].length, text.length);
            }
            return text;
        }
    }, {
        key: "_removeMultiLineComment",
        value: function _removeMultiLineComment(source) {
            while (true) {
                var found = source.indexOf("/*", 0);
                if (found < 0) {
                    break; // When there was no more found
                }
                var beginPoint = found;
                var endPoint = source.indexOf("*/", beginPoint);
                if (endPoint < 1) {
                    // error no bracket matching
                    console.error("Invalid bracket matching!");
                    return source;
                }
                source = source.substr(0, beginPoint) + source.substring(endPoint + 2, source.length);
            }
            return source;
        }
    }]);

    return RemoveCommentTransformer;
}(_SourceTransformer3.default);

exports.default = RemoveCommentTransformer;

},{"./Base/SourceTransformer":72}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DescriptionTransformer = require("./Base/DescriptionTransformer");

var _DescriptionTransformer2 = _interopRequireDefault(_DescriptionTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RemoveVariableAttributeTransformer = function (_DescriptionTransform) {
    _inherits(RemoveVariableAttributeTransformer, _DescriptionTransform);

    function RemoveVariableAttributeTransformer() {
        _classCallCheck(this, RemoveVariableAttributeTransformer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(RemoveVariableAttributeTransformer).call(this, function (transform) {
            return {
                fragment: RemoveVariableAttributeTransformer._removeVariableAnnotations(transform.description.fragment),
                vertex: RemoveVariableAttributeTransformer._removeVariableAnnotations(transform.description.vertex),
                uniforms: transform.description.uniforms,
                attributes: transform.description.attributes,
                fragmentPrecisions: transform.description.fragmentPrecisions,
                vertexPrecisions: transform.description.vertexPrecisions,
                functions: transform.description.functions
            };
        }));
    }

    _createClass(RemoveVariableAttributeTransformer, null, [{
        key: "_removeVariableAnnotations",
        value: function _removeVariableAnnotations(source) {
            var regexResult = undefined;
            while (regexResult = /@\{.+\}/g.exec(source)) {
                source = source.substr(0, regexResult.index) + source.substring(regexResult.index + regexResult[0].length, source.length);
            }
            return source;
        }
    }]);

    return RemoveVariableAttributeTransformer;
}(_DescriptionTransformer2.default);

exports.default = RemoveVariableAttributeTransformer;

},{"./Base/DescriptionTransformer":70}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DescriptionTransformer = require("./Base/DescriptionTransformer");

var _DescriptionTransformer2 = _interopRequireDefault(_DescriptionTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SourceSeparateTransformer = function (_DescriptionTransform) {
    _inherits(SourceSeparateTransformer, _DescriptionTransform);

    function SourceSeparateTransformer() {
        _classCallCheck(this, SourceSeparateTransformer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SourceSeparateTransformer).call(this, function (transform) {
            var fragment = SourceSeparateTransformer._removeSelfOnlyTag(SourceSeparateTransformer._removeOtherPart(transform.transformSource, "vert"), "frag");
            var vertex = SourceSeparateTransformer._removeSelfOnlyTag(SourceSeparateTransformer._removeOtherPart(transform.transformSource, "frag"), "vert");
            return {
                fragment: fragment,
                vertex: vertex,
                uniforms: transform.description.uniforms,
                attributes: transform.description.attributes,
                fragmentPrecisions: transform.description.fragmentPrecisions,
                vertexPrecisions: transform.description.vertexPrecisions,
                functions: transform.description.functions
            };
        }));
    }

    _createClass(SourceSeparateTransformer, null, [{
        key: "_removeOtherPart",
        value: function _removeOtherPart(source, partFlag) {
            var regex = new RegExp("s*(?://+)?s*@" + partFlag, "g");
            while (true) {
                var found = regex.exec(source);
                if (!found) {
                    break; // When there was no more found
                }
                var beginPoint = found.index;
                var index = source.indexOf("{", beginPoint); // ignore next {
                var endPoint = this._getEndBracketIndex(source, index, "{", "}") + 1;
                if (endPoint < 1) {
                    // error no bracket matching
                    console.error("Invalid bracket matching!");
                    return source;
                }
                source = source.substr(0, beginPoint) + source.substring(endPoint, source.length);
            }
            return source;
        }
    }, {
        key: "_removeSelfOnlyTag",
        value: function _removeSelfOnlyTag(source, partFlag) {
            var regex = new RegExp("(s*(?://+)?s*@" + partFlag + ")", "g");
            while (true) {
                var found = regex.exec(source);
                if (!found) {
                    break; // When there was no more found
                }
                var index = source.indexOf("{", found.index); // ignore next {
                var beginPoint = index;
                var endPoint = this._getEndBracketIndex(source, index, "{", "}") + 1;
                if (endPoint < 1) {
                    // error no bracket matching
                    console.error("Invalid bracket matching!");
                    return source;
                }
                source = source.substr(0, found.index) + source.substring(beginPoint + 1, endPoint - 1) + source.substring(endPoint + 1, source.length);
            }
            return source;
        }
    }, {
        key: "_getEndBracketIndex",
        value: function _getEndBracketIndex(source, startIndex, beginBracket, endBracket) {
            // get index of matching endBracket
            var index = startIndex;
            var bracketCount = 1;
            while (true) {
                if (bracketCount === 0) {
                    break;
                }
                index++;
                var nextEndBlacket = source.indexOf(endBracket, index);
                var nextBeginBlacket = source.indexOf(beginBracket, index);
                if (nextEndBlacket < 0) {
                    // error no bracket matching
                    console.error("Invalid bracket matching!");
                    return -1;
                }
                if (nextBeginBlacket < 0) {
                    index = nextEndBlacket;
                    bracketCount--;
                    continue;
                }
                if (nextEndBlacket < nextBeginBlacket) {
                    index = nextEndBlacket;
                    bracketCount--;
                    continue;
                } else {
                    index = nextBeginBlacket;
                    bracketCount++;
                    continue;
                }
            }
            return index;
        }
    }]);

    return SourceSeparateTransformer;
}(_DescriptionTransformer2.default);

exports.default = SourceSeparateTransformer;

},{"./Base/DescriptionTransformer":70}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DescriptionTransformer = require("./Base/DescriptionTransformer");

var _DescriptionTransformer2 = _interopRequireDefault(_DescriptionTransformer);

var _json = require("json5");

var _json2 = _interopRequireDefault(_json);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VariableParser = function (_DescriptionTransform) {
    _inherits(VariableParser, _DescriptionTransform);

    function VariableParser(target) {
        _classCallCheck(this, VariableParser);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(VariableParser).call(this, function (transform) {
            var input = {
                fragment: transform.description.fragment,
                vertex: transform.description.vertex,
                uniforms: transform.description.uniforms,
                attributes: transform.description.attributes,
                fragmentPrecisions: transform.description.fragmentPrecisions,
                vertexPrecisions: transform.description.vertexPrecisions,
                functions: transform.description.functions
            };
            var variables = VariableParser._parseVariables(transform.transformSource, target);
            switch (target) {
                case "uniform":
                    input.uniforms = variables;
                    break;
                case "attribute":
                    input.attributes = variables;
                    break;
                default:
                    throw new Error("Unknown variable type!!");
            }
            return input;
        }));
    }

    _createClass(VariableParser, null, [{
        key: "_parseVariableAttributes",
        value: function _parseVariableAttributes(attributes) {
            return _json2.default.parse(attributes);
        }
    }, {
        key: "_generateVariableFetchRegex",
        value: function _generateVariableFetchRegex(variableType) {
            return new RegExp("(?:@(\\{.+\\}))?\\s*" + variableType + "\\s+(?:(lowp|mediump|highp)\\s+)?([a-z0-9A-Z]+)\\s+([a-zA-Z0-9_]+)(?:\\s*\\[\\s*(\\d+)\\s*\\]\\s*)?\\s*;", "g");
        }
    }, {
        key: "_parseVariables",
        value: function _parseVariables(source, variableType) {
            var result = {};
            var regex = VariableParser._generateVariableFetchRegex(variableType);
            var regexResult = undefined;
            while (regexResult = regex.exec(source)) {
                var name = regexResult[4];
                var type = regexResult[3];
                var precision = regexResult[2];
                var rawAnnotations = regexResult[1];
                result[name] = {
                    variableName: name,
                    variableType: type,
                    variablePrecision: precision,
                    variableAnnotation: rawAnnotations ? VariableParser._parseVariableAttributes(rawAnnotations) : {},
                    isArray: typeof regexResult[5] !== "undefined",
                    arrayLength: typeof regexResult[5] !== "undefined" ? parseInt(regexResult[5], 10) : undefined
                };
            }
            return result;
        }
    }]);

    return VariableParser;
}(_DescriptionTransformer2.default);

exports.default = VariableParser;

},{"./Base/DescriptionTransformer":70,"json5":330}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RendererBase2 = require("./RendererBase");

var _RendererBase3 = _interopRequireDefault(_RendererBase2);

var _BufferSet = require("./BufferSet");

var _BufferSet2 = _interopRequireDefault(_BufferSet);

var _RenderPathExecutor = require("./RenderPathExecutor");

var _RenderPathExecutor2 = _interopRequireDefault(_RenderPathExecutor);

var _BasicRendererConfigurator = require("./RendererConfigurator/BasicRendererConfigurator");

var _BasicRendererConfigurator2 = _interopRequireDefault(_BasicRendererConfigurator);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* Provides base class feature for renderer classes.
*/

var BasicRenderer = function (_RendererBase) {
    _inherits(BasicRenderer, _RendererBase);

    /**
     * Constructor of RenderBase
     * @param canvas
     * @param viewportArea
     * @returns {}
     */

    function BasicRenderer(canvas, viewportArea, configurator) {
        _classCallCheck(this, BasicRenderer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BasicRenderer).call(this, canvas));

        configurator = configurator || new _BasicRendererConfigurator2.default();
        _this.region = viewportArea;
        _this.renderPath.fromPathTemplate(configurator.getStageChain(_this));
        _this.bufferSet = new _BufferSet2.default(_this);
        _this.bufferSet.appendBuffers(configurator.TextureBuffers);
        return _this;
    }
    /**
     * Initialize renderer to be rendererd.
     * Basically, this method are used for initializing GL resources, the other variable and any resources will be initialized when constructor was called.
     * This method is not intended to be called by user manually.
     */


    _createClass(BasicRenderer, [{
        key: "initialize",
        value: function initialize() {
            var _this2 = this;

            var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
            this.defaultRenderBuffer = rm.createRBO(this.id + ".rbo.default", this.region.Width, this.region.Height);
            this.on("resize", function () {
                _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager).getRBO(_this2.id + ".rbo.default").resize(_this2.region.Width, _this2.region.Height);
            });
            this._remapBuffers();
            this.bufferSet.on("changed", function () {
                return _this2._remapBuffers();
            });
        }
    }, {
        key: "dispose",
        value: function dispose() {
            this.defaultRenderBuffer.dispose();
            this.bufferSet.dispose();
        }
    }, {
        key: "render",
        value: function render(scene) {
            _RenderPathExecutor2.default.processRender(this, scene);
        }
        /**
         * It will be called before processing renderer.
         * If you need to override this method, you need to call same method of super class first.
         */

    }, {
        key: "beforeRender",
        value: function beforeRender() {
            this.applyViewport(true);
            this.canvas.beforeRender(this);
        }
        /**
         * It will be called after processing renderer.
         * If you need to override this method, you need to call same method of super class first.
         */

    }, {
        key: "afterRender",
        value: function afterRender() {
            this.gl.flush();
            this.canvas.afterRender(this);
        }
        /**
         * Apply viewport configuration
         */

    }, {
        key: "applyViewport",
        value: function applyViewport(isDefaultBuffer) {
            if (isDefaultBuffer) {
                this.gl.viewport(this.region.Left, this.canvas.region.Height - this.region.Bottom, this.region.Width, this.region.Height);
            } else {
                this.gl.viewport(0, 0, this.region.Width, this.region.Height);
            }
        }
    }, {
        key: "_remapBuffers",
        value: function _remapBuffers() {
            var _this3 = this;

            this.renderPath.path.forEach(function (chain) {
                chain.stage.bufferTextures.defaultRenderBuffer = _this3.defaultRenderBuffer;
                for (var bufferName in chain.buffers) {
                    chain.stage.bufferTextures[bufferName] = _this3.bufferSet.getColorBuffer(chain.buffers[bufferName]);
                }
            });
        }
    }]);

    return BasicRenderer;
}(_RendererBase3.default);

exports.default = BasicRenderer;

},{"../../ContextComponents":8,"../../JThreeContext":267,"./BufferSet":82,"./RenderPathExecutor":84,"./RendererBase":101,"./RendererConfigurator/BasicRendererConfigurator":102}],82:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectEE2 = require("../../Base/JThreeObjectEE");

var _JThreeObjectEE3 = _interopRequireDefault(_JThreeObjectEE2);

var _TextureGenerater = require("./TextureGenerater");

var _TextureGenerater2 = _interopRequireDefault(_TextureGenerater);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The class managing all buffer textures used for rendering in a BasicRenderer.
 */

var BufferSet = function (_JThreeObjectEE) {
    _inherits(BufferSet, _JThreeObjectEE);

    function BufferSet(_renderer) {
        _classCallCheck(this, BufferSet);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BufferSet).call(this));

        _this._renderer = _renderer;
        /**
         * The color buffers managed by this class.
         */
        _this._colorBuffers = {};
        return _this;
    }

    _createClass(BufferSet, [{
        key: "dispose",
        value: function dispose() {
            var _this2 = this;

            Object.keys(this._colorBuffers).forEach(function (k) {
                _this2._colorBuffers[k].dispose();
            });
        }
        /**
         * Generate new buffer and append list.
         * @param {GeneraterInfoChunk} argument [description]
         */

    }, {
        key: "appendBuffer",
        value: function appendBuffer(argument) {
            if (this._colorBuffers[argument.name]) {
                console.error("The color buffer " + argument.name + " is already exist.");
                return;
            } else {
                this._colorBuffers[argument.name] = _TextureGenerater2.default.generateTexture(this._renderer, argument);
                this.emit("changed", {});
            }
        }
    }, {
        key: "appendBuffers",
        value: function appendBuffers(args) {
            for (var i = 0; i < args.length; i++) {
                this.appendBuffer(args[i]);
            }
        }
        /**
         * Remove buffer and dispose.
         * @param {string} name [description]
         */

    }, {
        key: "removeBuffer",
        value: function removeBuffer(name) {
            if (this._colorBuffers[name]) {
                this._colorBuffers[name].dispose();
                delete this._colorBuffers[name];
                this.emit("changed", {});
            }
        }
    }, {
        key: "getColorBuffer",
        value: function getColorBuffer(name) {
            return this._colorBuffers[name];
        }
    }]);

    return BufferSet;
}(_JThreeObjectEE3.default);

exports.default = BufferSet;

},{"../../Base/JThreeObjectEE":4,"./TextureGenerater":106}],83:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * レンダリングの順序を管理しているクラス
 */

var RenderPath = function () {
    function RenderPath(_renderer) {
        _classCallCheck(this, RenderPath);

        this._renderer = _renderer;
        /**
         * レンダリングの順序の配列
         * @type {RenderStageChain[]}
         */
        this.path = [];
    }

    _createClass(RenderPath, [{
        key: "pushStage",
        value: function pushStage(stage) {
            this.path.push(this._fromTemplate(stage));
        }
    }, {
        key: "fromPathTemplate",
        value: function fromPathTemplate(templates) {
            var _this = this;

            templates.forEach(function (e) {
                _this.path.push(_this._fromTemplate(e));
            });
        }
    }, {
        key: "insertWithIndex",
        value: function insertWithIndex(index, stage) {
            if (index >= 0 && index <= this.path.length) {
                var newStageChain = new Array(this.path.length + 1);
                for (var i = 0; i < index; i++) {
                    newStageChain[i] = this.path[i];
                }
                newStageChain[index] = this._fromTemplate(stage);
                for (var _i = index + 1; _i < newStageChain.length; _i++) {
                    newStageChain[_i] = this.path[_i - 1];
                }
                this.path = newStageChain;
            } else {
                console.error("Invalid render stage index : " + index + ", Current length of stage chain is $" + this.path.length);
            }
        }
    }, {
        key: "deleteWithIndex",
        value: function deleteWithIndex(index) {
            if (index >= 0 && index < this.path.length && this.path.length > 0) {
                var newStageChain = new Array(this.path.length - 1);
                for (var i = 0; i < index; i++) {
                    newStageChain[i] = this.path[i];
                }
                for (var _i2 = index; _i2 < newStageChain.length; _i2++) {
                    newStageChain[_i2] = this.path[_i2 + 1];
                }
                this.path = newStageChain;
            } else {
                console.error("Invalid render stage index:" + index + ", Current length of stage chain is " + this.path.length);
            }
        }
    }, {
        key: "_fromTemplate",
        value: function _fromTemplate(template) {
            var rr = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.RenderStageRegistory);
            return {
                buffers: template.buffers,
                stage: rr.construct(template.stage, this._renderer),
                variables: template.variables || {}
            };
        }
    }]);

    return RenderPath;
}();

exports.default = RenderPath;

},{"../../ContextComponents":8,"../../JThreeContext":267}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _Mesh = require("../SceneObjects/Mesh");

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * All rendering path should be executed with this class.
 *
 * @type {[type]}
 */

var RenderPathExecutor = function () {
    function RenderPathExecutor() {
        _classCallCheck(this, RenderPathExecutor);
    }

    _createClass(RenderPathExecutor, null, [{
        key: "processRender",
        value: function processRender(renderer, scene) {
            var stageIndex = 0;
            renderer.renderPath.path.forEach(function (chain) {
                var stage = chain.stage;
                var techniqueCount = stage.getTechniqueCount(scene);
                var targetObjects = undefined;
                stage.preStage(scene);
                for (var techniqueIndex = 0; techniqueIndex < techniqueCount; techniqueIndex++) {
                    if (stage.getTarget(techniqueIndex) === "scene") {
                        targetObjects = scene.children;
                    } else {
                        var pr = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.PrimitiveRegistory);
                        var geometry = pr.getPrimitive(stage.getTarget(techniqueIndex));
                        if (!geometry) {
                            console.error("Unknown primitive " + stage.getTarget(techniqueIndex) + " was specified!");
                            continue;
                        } else {
                            targetObjects = [new _Mesh2.default(geometry, null)];
                        }
                    }
                    stage.shaderVariables = chain.variables;
                    stage.preTechnique(scene, techniqueIndex);
                    RenderPathExecutor._renderObjects(renderer, targetObjects, stage, scene, techniqueCount, techniqueIndex, chain);
                    stage.postTechnique(scene, techniqueIndex);
                }
                stage.postStage(scene);
                renderer.emit("rendered-stage", {
                    completedChain: chain,
                    bufferTextures: stage.bufferTextures,
                    index: stageIndex
                });
                stageIndex++;
            });
            renderer.emit("rendered-path", {
                owner: this,
                scene: scene
            });
        }
    }, {
        key: "_renderObjects",
        value: function _renderObjects(renderer, targetObjects, stage, scene, techniqueCount, techniqueIndex, chain) {
            var _this = this;

            targetObjects.forEach(function (v) {
                v.callRecursive(function (_v) {
                    if (_v.Geometry) {
                        stage.render(scene, _v, techniqueCount, techniqueIndex);
                        renderer.emit("rendered-object", {
                            owner: _this,
                            renderedObject: _v,
                            stage: stage,
                            stageChain: chain,
                            bufferTextures: stage.bufferTextures,
                            technique: techniqueIndex
                        });
                    }
                });
            });
        }
    }]);

    return RenderPathExecutor;
}();

exports.default = RenderPathExecutor;

},{"../../ContextComponents":8,"../../JThreeContext":267,"../SceneObjects/Mesh":150}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _HitAreaRenderStage = require("./RenderStages/HitAreaRenderStage");

var _HitAreaRenderStage2 = _interopRequireDefault(_HitAreaRenderStage);

var _BasicRenderStage = require("./RenderStages/Base/BasicRenderStage");

var _BasicRenderStage2 = _interopRequireDefault(_BasicRenderStage);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RenderStageRegistory = function () {
    function RenderStageRegistory() {
        _classCallCheck(this, RenderStageRegistory);

        this._renderStageFactoryFunctions = {};
        this.register("jthree.hitarea", function (renderer) {
            return new _HitAreaRenderStage2.default(renderer);
        });
        this.register(require("./RenderStages/BuiltIn/GBuffer.rsml"));
        this.register(require("./RenderStages/BuiltIn/LightAccumulationStage.rsml"));
        this.register(require("./RenderStages/BuiltIn/ForwardShading.rsml"));
        this.register(require("./RenderStages/BuiltIn/Fog.rsml"));
        this.register(require("./RenderStages/BuiltIn/FogExp2.rsml"));
        this.register(require("./RenderStages/BuiltIn/Skybox.rsml"));
        this.register(require("./RenderStages/BuiltIn/FXAA.rsml"));
        this.register(require("./RenderStages/BuiltIn/Sobel.rsml"));
        this.register(require("./RenderStages/BuiltIn/Gaussian.rsml"));
    }

    _createClass(RenderStageRegistory, [{
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.RenderStageRegistory;
        }
    }, {
        key: "register",
        value: function register(nameOrsource, factory) {
            if (factory) {
                this._renderStageFactoryFunctions[nameOrsource] = factory;
                return;
            }
            var parser = new DOMParser();
            var rsmlRoot = parser.parseFromString(nameOrsource, "text/xml");
            var stageRoot = rsmlRoot.querySelector("rsml > stage");
            var name = stageRoot.getAttribute("name");
            if (!name) {
                console.error("The name field was not found in RSML file.\n" + nameOrsource);
                return;
            }
            this._renderStageFactoryFunctions[name] = function (renderer) {
                return new _BasicRenderStage2.default(renderer, nameOrsource);
            };
        }
        /**
         * Construct new render stage related to specifed key.
         * @param  {string}          name     the key to identify render stage
         * @param  {BasicRenderer}   renderer the renderer being going to hold generated render stage base
         * @return {RenderStageBase}          generated render stage base
         */

    }, {
        key: "construct",
        value: function construct(name, renderer) {
            return this._renderStageFactoryFunctions[name](renderer);
        }
    }]);

    return RenderStageRegistory;
}();

exports.default = RenderStageRegistory;

},{"../../ContextComponents":8,"./RenderStages/Base/BasicRenderStage":86,"./RenderStages/BuiltIn/FXAA.rsml":89,"./RenderStages/BuiltIn/Fog.rsml":90,"./RenderStages/BuiltIn/FogExp2.rsml":91,"./RenderStages/BuiltIn/ForwardShading.rsml":92,"./RenderStages/BuiltIn/GBuffer.rsml":93,"./RenderStages/BuiltIn/Gaussian.rsml":94,"./RenderStages/BuiltIn/LightAccumulationStage.rsml":96,"./RenderStages/BuiltIn/Skybox.rsml":97,"./RenderStages/BuiltIn/Sobel.rsml":98,"./RenderStages/HitAreaRenderStage":99}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BasicTechnique = require("./BasicTechnique");

var _BasicTechnique2 = _interopRequireDefault(_BasicTechnique);

var _RenderStageBase2 = require("../RenderStageBase");

var _RenderStageBase3 = _interopRequireDefault(_RenderStageBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BasicRenderStage = function (_RenderStageBase) {
    _inherits(BasicRenderStage, _RenderStageBase);

    function BasicRenderStage(renderer, rsmlSource) {
        _classCallCheck(this, BasicRenderStage);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BasicRenderStage).call(this, renderer));

        _this._parseRSML(rsmlSource);
        return _this;
    }

    _createClass(BasicRenderStage, [{
        key: "getDefaultRendererConfigure",
        value: function getDefaultRendererConfigure(techniqueIndex) {
            return this.techniques[techniqueIndex].defaultRenderConfigure;
        }
    }, {
        key: "getSuperRendererConfigure",
        value: function getSuperRendererConfigure() {
            return _RenderStageBase3.default.defaultRendererConfigure;
        }
    }, {
        key: "preTechnique",
        value: function preTechnique(scene, techniqueIndex) {
            this.techniques[techniqueIndex].preTechnique(scene);
        }
    }, {
        key: "render",
        value: function render(scene, object, techniqueCount, techniqueIndex) {
            this.techniques[techniqueIndex].render(scene, object, techniqueCount, techniqueIndex);
        }
    }, {
        key: "getTechniqueCount",
        value: function getTechniqueCount(scene) {
            return this._techniqueCount;
        }
    }, {
        key: "getTarget",
        value: function getTarget(techniqueIndex) {
            return this.techniques[techniqueIndex].Target;
        }
    }, {
        key: "_parseRSML",
        value: function _parseRSML(source) {
            this._parsedRSML = new DOMParser().parseFromString(source, "text/xml");
            var stageTag = this._parsedRSML.querySelector("rsml > stage");
            if (!stageTag) {
                console.error("Stage tag was not found in RSML");
                return;
            }
            this._stageName = stageTag.getAttribute("name");
            var techniqueTags = stageTag.querySelectorAll("technique");
            this._techniqueCount = techniqueTags.length;
            this.techniques = new Array(this._techniqueCount);
            for (var techniqueIndex = 0; techniqueIndex < this._techniqueCount; techniqueIndex++) {
                this.techniques[techniqueIndex] = new _BasicTechnique2.default(this, techniqueTags.item(techniqueIndex), techniqueIndex);
            }
        }
    }, {
        key: "stageName",
        get: function get() {
            return this._stageName;
        }
    }]);

    return BasicRenderStage;
}(_RenderStageBase3.default);

exports.default = BasicRenderStage;

},{"../RenderStageBase":100,"./BasicTechnique":87}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MaterialDrawer = require("../../../Materials/MaterialDrawer");

var _MaterialDrawer2 = _interopRequireDefault(_MaterialDrawer);

var _RenderStageConfigUtility = require("./RenderStageConfigUtility");

var _RenderStageConfigUtility2 = _interopRequireDefault(_RenderStageConfigUtility);

var _XMLRenderConfigUtility = require("../../../Pass/XMLRenderConfigUtility");

var _XMLRenderConfigUtility2 = _interopRequireDefault(_XMLRenderConfigUtility);

var _BasicMaterial = require("../../../Materials/BasicMaterial");

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _JThreeObjectWithID2 = require("../../../../Base/JThreeObjectWithID");

var _JThreeObjectWithID3 = _interopRequireDefault(_JThreeObjectWithID2);

var _ContextComponents = require("../../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BasicTechnique = function (_JThreeObjectWithID) {
    _inherits(BasicTechnique, _JThreeObjectWithID);

    function BasicTechnique(renderStage, technique, techniqueIndex) {
        _classCallCheck(this, BasicTechnique);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BasicTechnique).call(this));

        _this.__fboInitialized = false;
        _this._wireFramed = false;
        _this.__renderStage = renderStage;
        _this.__renderer = renderStage.renderer;
        _this.gl = renderStage.gl;
        _this._techniqueDocument = technique;
        _this._techniqueIndex = techniqueIndex;
        var rc = _XMLRenderConfigUtility2.default.parseRenderConfig(technique);
        _this.defaultRenderConfigure = _XMLRenderConfigUtility2.default.mergeRenderConfigure(rc, _this.__renderStage.getSuperRendererConfigure());
        _this._target = _this._techniqueDocument.getAttribute("target");
        _this._wireFramed = _this._techniqueDocument.getAttribute("wireframe") === "true";
        if (!_this._target) {
            _this._target = "scene";
        }
        _this._fboBindingInfo = _RenderStageConfigUtility2.default.parseFBOConfiguration(_this._techniqueDocument.getElementsByTagName("fbo").item(0), renderStage.renderer.canvas);
        if (_this._target !== "scene") {
            _this.defaultMaterial = _this._getMaterial();
        }
        return _this;
    }

    _createClass(BasicTechnique, [{
        key: "preTechnique",
        value: function preTechnique(scene) {
            this._applyBufferConfiguration(scene);
        }
    }, {
        key: "render",
        value: function render(scene, object, techniqueCount, techniqueIndex) {
            switch (this.Target) {
                case "scene":
                    var materialGroup = this._techniqueDocument.getAttribute("materialGroup");
                    _MaterialDrawer2.default.drawForMaterials(scene, this.__renderStage, object, techniqueCount, techniqueIndex, materialGroup, this._wireFramed);
                    break;
                default:
                    _XMLRenderConfigUtility2.default.applyAll(this.gl, this.defaultRenderConfigure);
                    _MaterialDrawer2.default.drawForMaterial(scene, this.__renderStage, object, techniqueCount, techniqueIndex, this.defaultMaterial, this._wireFramed);
            }
        }
    }, {
        key: "__initializeFBO",
        value: function __initializeFBO(texs) {
            this.__fboInitialized = true;
            var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
            this.__fbo = rm.createFBO("jthree.technique." + this.id);
            var fboWrapper = this.__fbo.getForGL(this.gl);
            this._attachRBOConfigure(fboWrapper);
            this._attachTextureConfigure(fboWrapper);
        }
    }, {
        key: "_getMaterial",
        value: function _getMaterial() {
            var rawMaterials = this._techniqueDocument.getElementsByTagName("material");
            if (rawMaterials.length > 0) {
                var materialDocument = rawMaterials.item(0);
                return new _BasicMaterial2.default(materialDocument.outerHTML, this.__renderStage.stageName + this._techniqueIndex);
            }
            var mm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.MaterialManager);
            var matName = this._techniqueDocument.getAttribute("material");
            if (!matName) {
                console.error("material name was not specified.");
            }
            return mm.constructMaterial(matName);
        }
    }, {
        key: "_attachTextureConfigure",
        value: function _attachTextureConfigure(fboWrapper) {
            // TODO support for multiple rendering buffer
            var colorConfigure = this._fboBindingInfo[0];
            fboWrapper.attachTexture(WebGLRenderingContext.COLOR_ATTACHMENT0, this.__renderStage.bufferTextures[colorConfigure.name]);
        }
    }, {
        key: "_attachRBOConfigure",
        value: function _attachRBOConfigure(fboWrapper) {
            var texs = this.__renderStage.bufferTextures;
            if (!this._fboBindingInfo.rbo) {
                fboWrapper.attachRBO(WebGLRenderingContext.DEPTH_ATTACHMENT, null); // Unbind render buffer
            } else {
                    var rboConfigure = this._fboBindingInfo.rbo;
                    var targetBuffer = undefined;
                    var isRBO = true;
                    if (rboConfigure.name === "default") {
                        targetBuffer = texs.defaultRenderBuffer;
                    } else {
                        if (!texs[rboConfigure.name]) {
                            throw new Error("Specified render buffer was not found");
                        } else {
                            targetBuffer = texs[rboConfigure.name];
                            isRBO = false;
                        }
                    }
                    if (isRBO) {
                        switch (rboConfigure.type) {
                            case "stencil":
                                fboWrapper.attachRBO(WebGLRenderingContext.STENCIL_ATTACHMENT, targetBuffer);
                                break;
                            case "depthstencil":
                                fboWrapper.attachRBO(WebGLRenderingContext.DEPTH_STENCIL_ATTACHMENT, targetBuffer);
                                break;
                            default:
                            case "depth":
                                fboWrapper.attachRBO(WebGLRenderingContext.DEPTH_ATTACHMENT, targetBuffer);
                                break;
                        }
                    } else {
                        switch (rboConfigure.type) {
                            case "stencil":
                                fboWrapper.attachTexture(WebGLRenderingContext.STENCIL_ATTACHMENT, targetBuffer);
                                break;
                            case "depthstencil":
                                fboWrapper.attachTexture(WebGLRenderingContext.DEPTH_STENCIL_ATTACHMENT, targetBuffer);
                                break;
                            default:
                            case "depth":
                                fboWrapper.attachTexture(WebGLRenderingContext.DEPTH_ATTACHMENT, targetBuffer);
                                break;
                        }
                    }
                }
        }
    }, {
        key: "_applyBufferConfiguration",
        value: function _applyBufferConfiguration(scene) {
            var texs = this.__renderStage.bufferTextures;
            if (!this._fboBindingInfo || !this._fboBindingInfo[0]) {
                // if there was no fbo configuration, use screen buffer as default
                this._applyViewport(true);
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
                return;
            } else {
                // Check primary buffer was specified
                if (this._fboBindingInfo.primaryName && !texs[this._fboBindingInfo.primaryName]) {
                    this._onPrimaryBufferFail();
                    return;
                }
                this._applyViewport(false);
                if (!this.__fboInitialized) {
                    this.__initializeFBO(texs);
                }
                this.__fbo.getForGL(this.gl).bind();
                this._clearBuffers();
            }
        }
        /**
         * When primary buffer was failed to bind, this method bind default buffer as drawing target.
         */

    }, {
        key: "_onPrimaryBufferFail",
        value: function _onPrimaryBufferFail() {
            this._applyViewport(true);
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            if (this._fboBindingInfo.rbo && this._fboBindingInfo.rbo.needClear) {
                this.gl.depthMask(true);
                this.gl.clearDepth(this._fboBindingInfo.rbo.clearDepth);
                this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
            }
        }
    }, {
        key: "_clearBuffers",
        value: function _clearBuffers() {
            // Clear color buffer
            // TODO: support for multiple buffers
            if (this._fboBindingInfo[0] && this._fboBindingInfo[0].needClear) {
                var buffer = this._fboBindingInfo[0];
                var col = buffer.clearColor;
                this.gl.colorMask(true, true, true, true);
                this.gl.clearColor(col.X, col.Y, col.Z, col.W);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            }
            if (this._fboBindingInfo.rbo && this._fboBindingInfo.rbo.needClear) {
                this.gl.depthMask(true);
                this.gl.clearDepth(this._fboBindingInfo.rbo.clearDepth);
                this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
            }
        }
    }, {
        key: "_applyViewport",
        value: function _applyViewport(isDefault) {
            this.__renderStage.renderer.applyViewport(isDefault);
        }
    }, {
        key: "Target",
        get: function get() {
            return this._target;
        }
    }]);

    return BasicTechnique;
}(_JThreeObjectWithID3.default);

exports.default = BasicTechnique;

},{"../../../../Base/JThreeObjectWithID":6,"../../../../ContextComponents":8,"../../../../JThreeContext":267,"../../../Materials/BasicMaterial":36,"../../../Materials/MaterialDrawer":58,"../../../Pass/XMLRenderConfigUtility":68,"./RenderStageConfigUtility":88}],88:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = require("../../../../Math/Vector4");

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RenderStageConfigUtility = function () {
    function RenderStageConfigUtility() {
        _classCallCheck(this, RenderStageConfigUtility);
    }

    _createClass(RenderStageConfigUtility, null, [{
        key: "parseFBOConfiguration",
        value: function parseFBOConfiguration(fboElement, canvas) {
            if (!fboElement) {
                return undefined;
            }
            var result = {};
            var primary = fboElement.getAttribute("primary");
            var colorNodes = fboElement.getElementsByTagName("color");
            var rboNode = fboElement.getElementsByTagName("rbo").item(0);
            result.primaryName = primary;
            for (var i = 0; i < colorNodes.length; i++) {
                var colorBuffer = RenderStageConfigUtility._parseColorBuffer(colorNodes.item(i), canvas);
                result[colorBuffer.registerIndex] = colorBuffer;
                if (colorBuffer.name === primary) {
                    result.primaryIndex = colorBuffer.registerIndex;
                }
            }
            result.rbo = RenderStageConfigUtility._parseRenderBuffer(rboNode);
            return result;
        }
    }, {
        key: "_parseColorBuffer",
        value: function _parseColorBuffer(colorElement, canvas) {
            // Retrive buffer name to be bound
            var name = colorElement.getAttribute("name");
            if (!name) {
                console.error("The name attribute in color node must be specified!");
                return null;
            }
            // Retrive register index
            var registerStr = colorElement.getAttribute("register");
            var registerIndex = 0;
            if (registerStr) {
                registerIndex = parseInt(registerStr, 10);
            }
            // Retrive clear flag
            var clearStr = colorElement.getAttribute("clear");
            var clearFlag = clearStr !== "false";
            // Retrive clear color
            var clearColor = undefined;
            if (clearFlag) {
                var colorStr = colorElement.getAttribute("clearColor");
                clearColor = new _Vector2.default(0, 0, 0, 0);
                if (colorStr) {
                    if (colorStr === "default") {
                        clearColor = canvas.clearColor.toVector();
                    } else {
                        clearColor = _Vector2.default.parse(colorStr);
                    }
                }
            }
            return {
                name: name,
                registerIndex: registerIndex,
                clearColor: clearColor,
                needClear: clearFlag
            };
        }
    }, {
        key: "_parseRenderBuffer",
        value: function _parseRenderBuffer(rboElement) {
            if (!rboElement) {
                return undefined;
            }
            // Retrive buffer name to be bound
            var name = rboElement.getAttribute("name");
            if (!name) {
                name = "default";
            }
            var type = rboElement.getAttribute("type");
            if (!type) {
                type = "depth";
            }
            var clearStr = rboElement.getAttribute("clear");
            var clearFlag = clearStr !== "false";
            var clearDepth = undefined;
            if (clearFlag) {
                var depthStr = rboElement.getAttribute("clearDepth");
                clearDepth = 1.0;
                if (depthStr) {
                    clearDepth = parseFloat(depthStr);
                }
            }
            return {
                name: name,
                type: type,
                needClear: clearFlag,
                clearDepth: clearDepth
            };
        }
    }]);

    return RenderStageConfigUtility;
}();

exports.default = RenderStageConfigUtility;

},{"../../../../Math/Vector4":279}],89:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <rsml>\n    <stage name=\"jthree.basic.fxaa\">\n      <technique target=\"quad\">\n        <fbo primary=\"OUT\">\n          <color name=\"OUT\" register=\"0\"/>\n        </fbo>\n        <material name=\"jthree.basic.fxaa\" group=\"jthree.materials.fxaa\" order=\"300\">\n          <registers>\n            <register name=\"builtin.basic\" />\n            <register name=\"builtin.buffer\" />\n          </registers>\n          <passes>\n            <pass>\n              <blend enabled=\"false\" />\n              <glsl>\n                <![CDATA[\n            attribute vec4 position;\n\n            varying vec2 vMUv;\n            varying vec2 vSWUv;\n            varying vec2 vSEUv;\n            varying vec2 vNWUv;\n            varying vec2 vNEUv;\n            varying vec2 vUv;\n\n            uniform mediump vec2 _resolution;\n\n            @vert{\n\n            void texcoords(vec2 fragCoord, vec2 resolution, out vec2 NW, out vec2 NE, out vec2 SW, out vec2 SE, out vec2 M) {\n      \t        vec2 inverseVP = 1.0 / resolution.xy;\n      \t        NW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n      \t        NE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n      \t        SW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n      \t        SE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n      \t        M = vec2(fragCoord * inverseVP);\n              }\n\n              void main(void)\n              {\n              \tgl_Position = position;\n                vUv = (position.xy + vec2(1.0,1.0)) * 0.5;\n                texcoords(vUv * _resolution,_resolution,vNWUv,vNEUv,vSWUv,vSEUv,vMUv);\n              }\n            }\n\n            @frag{\n\n              @{type:\"buffer\",name:\"INPUT\",register:0}\n              uniform sampler2D _inputBuffer;\n\n              @{default:0.0078125}\n              uniform float reduceMin;\n              @{default:0.125}\n              uniform float reduceMul;\n              @{default:8}\n              uniform float spanMax;\n\n              vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,vec2 v_rgbNW, vec2 v_rgbNE, vec2 v_rgbSW, vec2 v_rgbSE, vec2 v_rgbM) {\n                vec4 color;\n                mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n                vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n                vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n                vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n                vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n                vec4 texColor = texture2D(tex, v_rgbM);\n                vec3 rgbM  = texColor.xyz;\n                vec3 luma = vec3(0.299, 0.587, 0.114);\n                float lumaNW = dot(rgbNW, luma);\n                float lumaNE = dot(rgbNE, luma);\n                float lumaSW = dot(rgbSW, luma);\n                float lumaSE = dot(rgbSE, luma);\n                float lumaM  = dot(rgbM,  luma);\n                float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n                float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n                mediump vec2 dir;\n                dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n                dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n                float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * 0.25 * reduceMul, reduceMin);\n\n                float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n                dir = min(vec2(spanMax, spanMax), max(vec2(-spanMax, -spanMax), dir * rcpDirMin)) * inverseVP;\n\n                vec4 rgbA = 0.5 * (\n                texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)) +\n                texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)));\n                vec4 rgbB = rgbA * 0.5 + 0.25 * (\n                texture2D(tex, fragCoord * inverseVP + dir * -0.5) +\n                texture2D(tex, fragCoord * inverseVP + dir * 0.5));\n\n                float lumaB = dot(rgbB.rgb, luma);\n                if ((lumaB < lumaMin) || (lumaB > lumaMax))\n                color = rgbA;\n                else\n                color = rgbB;\n                return color;\n              }\n\n              void main(void){\n                gl_FragColor = fxaa(_inputBuffer,vUv * _resolution,_resolution, vNWUv,vNEUv,vSWUv,vSEUv,vMUv);\n              }\n            }\n\n            ]]>\n              </glsl>\n            </pass>\n          </passes>\n        </material>\n      </technique>\n    </stage>\n  </rsml>\n"
},{}],90:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <rsml>\n    <stage name=\"jthree.basic.fog\">\n      <technique target=\"quad\">\n        <fbo primar=\"OUT\">\n          <color name=\"OUT\" register=\"0\" />\n        </fbo>\n        <material name=\"jthree.basic.fog\" group=\"jthree.materials.fog\" order=\"300\">\n          <registers>\n            <register name=\"builtin.buffer\" />\n            <register name=\"builtin.basic\" />\n          </registers>\n          <passes>\n            <pass>\n              <depth enabled=\"false\" />\n              <glsl>\n                <![CDATA[\n            attribute vec3 position;\n            varying vec4 vPosition;\n\n            @vert{\n              uniform mat4 _matV;\n\n              void main(void)\n              {\n              \tvPosition = vec4(position,1.0);\n                gl_Position = vec4(position,1.0);\n              }\n            }\n\n            @frag{\n              @import \"builtin.gbuffer-reader\"\n\n              @{register:0,type:\"buffer\",name:\"PRIMARY\"}\n              uniform mediump sampler2D _buffer;\n\n              @{register:1,type:\"buffer\",name:\"MAIN\"}\n              uniform sampler2D _mainBuffer;\n\n              uniform mat4 _matIP;\n\n              @{default:0.4}\n              uniform float fogStart;\n\n              @{default:1.0}\n              uniform float fogEnd;\n\n              @{default:[1,1,1]}\n              uniform vec3 fogColor;\n\n              uniform float _nearClip;\n\n              uniform float _farClip;\n\n              void main()\n              {\n                vec4 rawBuffer = readRawBuffer(_buffer,vPosition);\n                float depth = getDepth(rawBuffer);\n                vec3 pos = getPosition(depth,vPosition,_matIP);\n                vec2 uv = vPosition.xy /2. + vec2(0.5,0.5);\n              \tgl_FragColor=texture2D( _mainBuffer, uv);\n                float d = -pos.z / (_farClip - _nearClip);\n                float fogFactor;\n                if (d == 1.) {\n                  fogFactor = 0.0;\n                } else {\n                  if (fogEnd - fogStart <= 0.) {\n                    fogFactor = d >= fogEnd ? 1.0 : 0.0;\n                  } else {\n                    fogFactor = max(0.,min(1.,d / (fogEnd - fogStart) - fogStart / (fogEnd - fogStart)));\n                  }\n                }\n                gl_FragColor.rgb = mix(gl_FragColor.rgb,fogColor,fogFactor);\n              }\n            }\n\n            ]]>\n              </glsl>\n            </pass>\n          </passes>\n        </material>\n      </technique>\n    </stage>\n  </rsml>\n"
},{}],91:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<rsml>\n  <stage name=\"jthree.basic.fogExp2\">\n    <technique target=\"quad\">\n      <fbo primary=\"OUT\">\n        <color name=\"OUT\" register=\"0\"/>\n      </fbo>\n      <material order=\"300\">\n        <registers>\n          <register name=\"builtin.buffer\" />\n          <register name=\"builtin.basic\" />\n        </registers>\n        <passes>\n          <pass>\n            <depth enabled=\"false\" />\n            <glsl>\n              <![CDATA[\n            attribute vec3 position;\n            varying vec4 vPosition;\n\n            @vert{\n              uniform mat4 _matV;\n\n              void main(void)\n              {\n                vPosition = vec4(position,1.0);\n                gl_Position = vec4(position,1.0);\n              }\n            }\n\n            @frag{\n              @import \"builtin.gbuffer-reader\"\n\n              @{register:0,type:\"buffer\",name:\"PRIMARY\"}\n              uniform mediump sampler2D _buffer;\n\n              @{register:1,type:\"buffer\",name:\"MAIN\"}\n              uniform sampler2D _mainBuffer;\n\n              uniform mat4 _matIP;\n\n              @{default:0.4}\n              uniform float density;\n\n              @{default:[1,1,1]}\n              uniform vec3 fogColor;\n\n              uniform float _nearClip;\n\n              uniform float _farClip;\n\n              float fogFactorExp2(const float dist) {\n                const float LOG2 = -1.442695;\n                float d = density * dist;\n                return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n              }\n\n              void main()\n              {\n                vec4 rawBuffer = readRawBuffer(_buffer,vPosition);\n                float depth = getDepth(rawBuffer);\n                vec3 pos = getPosition(depth,vPosition,_matIP);\n                vec2 uv = vPosition.xy /2. + vec2(0.5,0.5);\n                gl_FragColor=texture2D( _mainBuffer, uv);\n                float d = -pos.z / (_farClip - _nearClip);\n                float fogFactor = fogFactorExp2(d);\n                gl_FragColor.rgb = mix(gl_FragColor.rgb,fogColor,fogFactor);\n              }\n            }\n\n            ]]>\n            </glsl>\n          </pass>\n        </passes>\n      </material>\n    </technique>\n  </stage>\n</rsml>\n"
},{}],92:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<rsml>\n  <stage name=\"jthree.basic.foward\">\n    <technique target=\"scene\" materialGroup=\"builtin.forward\">\n      <fbo primary=\"OUT\">\n        <color name=\"OUT\" register=\"0\" clearColor=\"default\" clear=\"true\"/>\n        <rbo clear=\"true\" type=\"depth\"/>\n      </fbo>\n      <cull enabled=\"false\" mode=\"BACK\"/>\n    </technique>\n  </stage>\n</rsml>\n"
},{}],93:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<rsml>\n  <stage name=\"jthree.basic.gbuffer\">\n    <technique target=\"scene\" materialGroup=\"builtin.depth\">\n      <fbo>\n        <color name=\"DEPTH\" clearColor=\"0,0,0,0\" register=\"0\" />\n        <rbo type=\"depth\" clearDepth=\"1.0\" />\n      </fbo>\n      <cull enabled=\"true\" mode=\"BACK\" />\n      <blend enabled=\"true\" src=\"ONE\" dst=\"ZERO\" />\n      <depth enabled=\"true\" mode=\"LESS\" />\n    </technique>\n    <technique target=\"scene\" materialGroup=\"jthree.basic.gbuffer.1\">\n      <fbo>\n        <color name=\"PRIMARY\" clearColor=\"0,0,0,0\" register=\"0\" />\n        <rbo type=\"depth\" clearDepth=\"1.0\" />\n      </fbo>\n      <cull enabled=\"true\" mode=\"BACK\" />\n      <blend enabled=\"true\" src=\"ONE\" dst=\"ZERO\" />\n      <depth enabled=\"true\" mode=\"LESS\" />\n    </technique>\n    <!--\n    <technique target=\"scene\" materialGroup=\"jthree.basic.gbuffer.3\">\n      <cull enabled=\"true\" mode=\"BACK\"/>\n      <blend enabled=\"true\" src=\"ONE\" dst=\"ZERO\"/>\n      <depth enabled=\"true\" mode=\"LESS\"/>\n    </technique> -->\n  </stage>\n</rsml>\n"
},{}],94:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <rsml>\n    <stage name=\"jthree.basic.gaussian\">\n      <technique target=\"quad\">\n        <fbo>\n          <color name=\"BUF\" register=\"0\" />\n        </fbo>\n        <material name=\"jthree.basic.gaussian.1\" order=\"300\">\n          <registers>\n            <register name=\"builtin.buffer\" />\n            <register name=\"builtin.basic\" />\n          </registers>\n          <passes>\n            <pass>\n              <depth enabled=\"false\" />\n              <glsl><![CDATA[\n            attribute vec3 position;\n            varying vec4 vPosition;\n\n            @vert{\n              uniform mat4 _matV;\n\n              void main(void)\n              {\n              \tvPosition = vec4(position,1.0);\n                gl_Position = vec4(position,1.0);\n              }\n            }\n\n            @frag{\n\n              uniform vec2 _resolution;\n\n              uniform float weight[10];\n\n              @{type:\"buffer\",name:\"INPUT\",register:0}\n              uniform sampler2D _texture;\n              void main(void){\n                fc = gl_FragCoord.st;\n                destColor += texture2D(_texture, (fc + vec2(-9.0, 0.0)) * tFrag).rgb * weight[9];\n                destColor += texture2D(_texture, (fc + vec2(-8.0, 0.0)) * tFrag).rgb * weight[8];\n                destColor += texture2D(_texture, (fc + vec2(-7.0, 0.0)) * tFrag).rgb * weight[7];\n                destColor += texture2D(_texture, (fc + vec2(-6.0, 0.0)) * tFrag).rgb * weight[6];\n                destColor += texture2D(_texture, (fc + vec2(-5.0, 0.0)) * tFrag).rgb * weight[5];\n                destColor += texture2D(_texture, (fc + vec2(-4.0, 0.0)) * tFrag).rgb * weight[4];\n                destColor += texture2D(_texture, (fc + vec2(-3.0, 0.0)) * tFrag).rgb * weight[3];\n                destColor += texture2D(_texture, (fc + vec2(-2.0, 0.0)) * tFrag).rgb * weight[2];\n                destColor += texture2D(_texture, (fc + vec2(-1.0, 0.0)) * tFrag).rgb * weight[1];\n                destColor += texture2D(_texture, (fc + vec2( 0.0, 0.0)) * tFrag).rgb * weight[0];\n                destColor += texture2D(_texture, (fc + vec2( 1.0, 0.0)) * tFrag).rgb * weight[1];\n                destColor += texture2D(_texture, (fc + vec2( 2.0, 0.0)) * tFrag).rgb * weight[2];\n                destColor += texture2D(_texture, (fc + vec2( 3.0, 0.0)) * tFrag).rgb * weight[3];\n                destColor += texture2D(_texture, (fc + vec2( 4.0, 0.0)) * tFrag).rgb * weight[4];\n                destColor += texture2D(_texture, (fc + vec2( 5.0, 0.0)) * tFrag).rgb * weight[5];\n                destColor += texture2D(_texture, (fc + vec2( 6.0, 0.0)) * tFrag).rgb * weight[6];\n                destColor += texture2D(_texture, (fc + vec2( 7.0, 0.0)) * tFrag).rgb * weight[7];\n                destColor += texture2D(_texture, (fc + vec2( 8.0, 0.0)) * tFrag).rgb * weight[8];\n                destColor += texture2D(_texture, (fc + vec2( 9.0, 0.0)) * tFrag).rgb * weight[9];\n                gl_FragColor = vec4(destColor,1.0);\n              }\n            }\n            ]]>\n              </glsl>\n            </pass>\n          </passes>\n        </material>\n      </technique>\n    </stage>\n  </rsml>\n"
},{}],95:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<rsml>\n  <stage name=\"jthree.basic.hitarea\">\n    <technique target=\"scene\" materialGroup=\"jthree.materials.hitarea\">\n      <fbo>\n        <rbo clearDepth=\"1.0\" type=\"depth\"/>\n        <color name=\"OUT\" clearColor=\"0,0,0,0\" register=\"0\"/>\n      </fbo>\n      <blend enabled=\"true\" src=\"ONE\" dst=\"ZERO\"/>\n    </technique>\n  </stage>\n</rsml>\n"
},{}],96:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<rsml>\n  <stage name=\"jthree.basic.light\">\n    <technique target=\"scene\" materialGroup=\"jthree.light.diffuse\">\n      <fbo>\n        <rbo clearDepth=\"1.0\" clear=\"false\"/>\n        <color name=\"DIFFUSE\" clearColor=\"0,0,0,0\" register=\"0\"/>\n      </fbo>\n      <cull enabled=\"true\" mode=\"BACK\"/>\n      <blend enabled=\"true\" src=\"ONE\" dst=\"ONE\"/>\n      <depth enabled=\"true\" mode=\"LEQUAL\"/>\n      <mask depth=\"false\"/>\n    </technique>\n    <technique target=\"scene\" materialGroup=\"jthree.light.specular\">\n      <fbo>\n        <rbo clearDepth=\"1.0\" clear=\"false\"/>\n        <color name=\"SPECULAR\" clearColor=\"0,0,0,0\" register=\"0\"/>\n      </fbo>\n      <cull enabled=\"true\" mode=\"BACK\"/>\n      <blend enabled=\"true\" src=\"ONE\" dst=\"ONE\"/>\n      <depth enabled=\"true\" mode=\"LEQUAL\"/>\n      <mask depth=\"false\"/>\n    </technique>\n  </stage>\n</rsml>\n"
},{}],97:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <rsml>\n    <stage name=\"jthree.basic.skybox\">\n      <technique target=\"cube\">\n        <cull enabled=\"true\" mode=\"FRONT\" />\n        <fbo primary=\"OUT\">\n          <color register=\"0\" name=\"OUT\" clearColor=\"0,0,0,1\"/>\n        </fbo>\n        <material>\n          <registers>\n            <register name=\"builtin.basic\" />\n          </registers>\n          <passes>\n            <pass>\n              <depth enabled=\"false\" />\n              <glsl>\n                <![CDATA[\n            attribute vec3 position;\n            varying vec3 vPosition;\n\n            @vert{\n              uniform mat4 _matV;\n\n              void main(void)\n              {\n              \tvPosition = (vec4(position,1.0) * _matV).xyz;\n                gl_Position = vec4(position,1.0);\n              }\n            }\n\n            @frag{\n              @{register:0}\n              uniform samplerCube skybox;\n\n              void main()\n              {\n              \t\tgl_FragColor=textureCube(skybox,vPosition);\n              }\n            }\n\n            ]]>\n              </glsl>\n            </pass>\n          </passes>\n        </material>\n      </technique>\n    </stage>\n  </rsml>\n"
},{}],98:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <rsml>\n    <stage name=\"jthree.basic.sobel\">\n      <technique target=\"quad\">\n        <fbo primary=\"OUT\">\n          <color name=\"OUT\" register=\"0\" />\n        </fbo>\n        <material order=\"300\">\n          <registers>\n            <register name=\"builtin.buffer\" />\n            <register name=\"builtin.basic\" />\n          </registers>\n          <passes>\n            <pass>\n              <depth enabled=\"false\" />\n              <glsl><![CDATA[\n            attribute vec3 position;\n            varying vec4 vPosition;\n\n            @vert{\n              uniform mat4 _matV;\n\n              void main(void)\n              {\n              \tvPosition = vec4(position,1.0);\n                gl_Position = vec4(position,1.0);\n              }\n            }\n\n            @frag{\n\n              uniform vec2 _resolution;\n\n              @{default:[1.0,0.0,-1.0,2.0,0.0,-2.0,1.0,0.0,-1.0]}\n              uniform float xKernel[9];\n\n              @{default:[1.0,2.0,1.0,0.0,0.0,0.0,-1.0,-2.0,-1.0]}\n              uniform float yKernel[9];\n\n              @{type:\"buffer\",name:\"INPUT\",register:0}\n              uniform sampler2D _texture;\n\n              void main(void){\n                vec2 offset[9];\n                offset[0] = vec2(-1.0, -1.0);\n                offset[1] = vec2( 0.0, -1.0);\n                offset[2] = vec2( 1.0, -1.0);\n                offset[3] = vec2(-1.0,  0.0);\n                offset[4] = vec2( 0.0,  0.0);\n                offset[5] = vec2( 1.0,  0.0);\n                offset[6] = vec2(-1.0,  1.0);\n                offset[7] = vec2( 0.0,  1.0);\n                offset[8] = vec2( 1.0,  1.0);\n                float tFrag = 1.0 / _resolution.x;\n                vec2  fc = vec2(gl_FragCoord.s, gl_FragCoord.t);\n                vec3  horizonColor = vec3(0.0);\n                vec3  verticalColor = vec3(0.0);\n                horizonColor  += texture2D(_texture, (fc + offset[0]) * tFrag).rgb * xKernel[0];\n                horizonColor  += texture2D(_texture, (fc + offset[1]) * tFrag).rgb * xKernel[1];\n                horizonColor  += texture2D(_texture, (fc + offset[2]) * tFrag).rgb * xKernel[2];\n                horizonColor  += texture2D(_texture, (fc + offset[3]) * tFrag).rgb * xKernel[3];\n                horizonColor  += texture2D(_texture, (fc + offset[4]) * tFrag).rgb * xKernel[4];\n                horizonColor  += texture2D(_texture, (fc + offset[5]) * tFrag).rgb * xKernel[5];\n                horizonColor  += texture2D(_texture, (fc + offset[6]) * tFrag).rgb * xKernel[6];\n                horizonColor  += texture2D(_texture, (fc + offset[7]) * tFrag).rgb * xKernel[7];\n                horizonColor  += texture2D(_texture, (fc + offset[8]) * tFrag).rgb * xKernel[8];\n\n                verticalColor += texture2D(_texture, (fc + offset[0]) * tFrag).rgb * yKernel[0];\n                verticalColor += texture2D(_texture, (fc + offset[1]) * tFrag).rgb * yKernel[1];\n                verticalColor += texture2D(_texture, (fc + offset[2]) * tFrag).rgb * yKernel[2];\n                verticalColor += texture2D(_texture, (fc + offset[3]) * tFrag).rgb * yKernel[3];\n                verticalColor += texture2D(_texture, (fc + offset[4]) * tFrag).rgb * yKernel[4];\n                verticalColor += texture2D(_texture, (fc + offset[5]) * tFrag).rgb * yKernel[5];\n                verticalColor += texture2D(_texture, (fc + offset[6]) * tFrag).rgb * yKernel[6];\n                verticalColor += texture2D(_texture, (fc + offset[7]) * tFrag).rgb * yKernel[7];\n                verticalColor += texture2D(_texture, (fc + offset[8]) * tFrag).rgb * yKernel[8];\n\n                gl_FragColor = vec4(vec3(sqrt(horizonColor*horizonColor + verticalColor * verticalColor)),1.0);\n              }\n            }\n            ]]>\n              </glsl>\n            </pass>\n          </passes>\n        </material>\n      </technique>\n    </stage>\n  </rsml>\n"
},{}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _TextureBase = require("../../Resources/Texture/TextureBase");

var _TextureBase2 = _interopRequireDefault(_TextureBase);

var _BasicRenderStage2 = require("./Base/BasicRenderStage");

var _BasicRenderStage3 = _interopRequireDefault(_BasicRenderStage2);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HitAreaRenderStage = function (_BasicRenderStage) {
    _inherits(HitAreaRenderStage, _BasicRenderStage);

    function HitAreaRenderStage(renderer) {
        _classCallCheck(this, HitAreaRenderStage);

        /**
         * Object index for rendering hit area.
         * (This is internal use)
         * @type {number}
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(HitAreaRenderStage).call(this, renderer, require("./BuiltIn/HitAreaRenderingStage.rsml")));

        _this.objectIndex = 1;
        _this.indexObjectPair = {};
        _this.hitTestQueries = [];
        return _this;
    }

    _createClass(HitAreaRenderStage, [{
        key: "preTechnique",
        value: function preTechnique(scene, techniqueIndex) {
            _get(Object.getPrototypeOf(HitAreaRenderStage.prototype), "preTechnique", this).call(this, scene, techniqueIndex);
            this.objectIndex = 1;
        }
    }, {
        key: "render",
        value: function render(scene, object, techniqueCount, techniqueIndex) {
            this.indexObjectPair[this.objectIndex] = object;
            _get(Object.getPrototypeOf(HitAreaRenderStage.prototype), "render", this).call(this, scene, object, techniqueCount, techniqueIndex);
            this.objectIndex++;
        }
    }, {
        key: "postTechnique",
        value: function postTechnique(scene, techniqueIndex) {
            if (this.bufferTextures["OUT"]) {
                if (!(this.bufferTextures["OUT"] instanceof _TextureBase2.default)) {
                    throw new Error("OUT argument cannnot acceptable except TextureBase");
                }
                for (var i = 0; i < this.hitTestQueries.length; i++) {
                    var query = this.hitTestQueries[i];
                    var fetchedPixel = this.bufferTextures["OUT"].getForGL(this.gl).getPixel(query.x, this.renderer.region.Height - query.y);
                    var object = this._fetchRelatedObject(fetchedPixel);
                    query.deferred.resolve(object);
                }
                this.hitTestQueries.splice(0);
            }
        }
    }, {
        key: "queryHitTest",
        value: function queryHitTest(x, y) {
            var deferred = _q2.default.defer();
            this.hitTestQueries.push({
                x: x,
                y: y,
                deferred: deferred
            });
            return deferred.promise;
        }
    }, {
        key: "_fetchRelatedObject",
        value: function _fetchRelatedObject(pixel) {
            var id = pixel[0] << 16 | pixel[1];
            return this.indexObjectPair[id];
        }
    }]);

    return HitAreaRenderStage;
}(_BasicRenderStage3.default);

exports.default = HitAreaRenderStage;

},{"../../Resources/Texture/TextureBase":134,"./Base/BasicRenderStage":86,"./BuiltIn/HitAreaRenderingStage.rsml":95,"q":338}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectWithID2 = require("../../../Base/JThreeObjectWithID");

var _JThreeObjectWithID3 = _interopRequireDefault(_JThreeObjectWithID2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RenderStageBase = function (_JThreeObjectWithID) {
    _inherits(RenderStageBase, _JThreeObjectWithID);

    function RenderStageBase(renderer) {
        _classCallCheck(this, RenderStageBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RenderStageBase).call(this));

        _this.renderer = renderer;
        _this.shaderVariables = {};
        _this.bufferTextures = { defaultRenderBuffer: null };
        _this.gl = renderer.gl;
        return _this;
    }

    _createClass(RenderStageBase, [{
        key: "preStage",
        value: function preStage(scene) {
            return;
        }
    }, {
        key: "postStage",
        value: function postStage(scene) {
            return;
        }
        /**
         * This method will be called before process render in each pass
         */

    }, {
        key: "preTechnique",
        value: function preTechnique(scene, techniqueIndex) {
            return;
        }
        /**
         * This method will be called after process render in each pass.
         */

    }, {
        key: "postTechnique",
        value: function postTechnique(scene, techniqueIndex) {
            return;
        }
    }]);

    return RenderStageBase;
}(_JThreeObjectWithID3.default);

RenderStageBase.defaultRendererConfigure = {
    cullOrientation: "BACK",
    depthEnabled: true,
    depthMode: "LESS",
    depthMask: true,
    blendEnabled: true,
    blendSrcFactor: "SRC_ALPHA",
    blendDstFactor: "ONE_MINUS_SRC_ALPHA",
    redMask: true,
    greenMask: true,
    blueMask: true,
    alphaMask: true
};
exports.default = RenderStageBase;

},{"../../../Base/JThreeObjectWithID":6}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Rectangle = require("../../Math/Rectangle");

var _Rectangle2 = _interopRequireDefault(_Rectangle);

var _CanvasRegion2 = require("../Canvas/CanvasRegion");

var _CanvasRegion3 = _interopRequireDefault(_CanvasRegion2);

var _RenderPath = require("./RenderPath");

var _RenderPath2 = _interopRequireDefault(_RenderPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RendererBase = function (_CanvasRegion) {
    _inherits(RendererBase, _CanvasRegion);

    function RendererBase(canvas) {
        _classCallCheck(this, RendererBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RendererBase).call(this, canvas.canvasElement));

        _this.canvas = canvas;
        _this.renderPath = new _RenderPath2.default(_this);
        _this._region = new _Rectangle2.default(0, 0, 512, 512);
        _this.gl = canvas.gl;
        return _this;
    }

    _createClass(RendererBase, [{
        key: "setCamera",
        value: function setCamera(cam) {
            if (this.camera) {
                this.camera.ParentScene.removeRenderer(this);
            }
            cam.ParentScene.addRenderer(this);
            this.camera = cam;
        }
    }, {
        key: "region",
        get: function get() {
            return this._region;
        }
        /**
         * Setter for viewport area. viewport area is the area to render.
         * @param area {Rectangle} the rectangle to render.
         */
        ,
        set: function set(area) {
            if (!_Rectangle2.default.equals(area, this.region) && typeof area.Width !== "undefined" && typeof area.Height !== "undefined") {
                if (isNaN(area.Height + area.Width)) {
                    return;
                }
                this._region = area;
                this.emit("resize", area);
            }
        }
    }]);

    return RendererBase;
}(_CanvasRegion3.default);

exports.default = RendererBase;

},{"../../Math/Rectangle":276,"../Canvas/CanvasRegion":12,"./RenderPath":83}],102:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RendererConfiguratorBase = require("./RendererConfiguratorBase");

var _RendererConfiguratorBase2 = _interopRequireDefault(_RendererConfiguratorBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BasicRendererConfigurator = function (_ConfiguratorBase) {
    _inherits(BasicRendererConfigurator, _ConfiguratorBase);

    function BasicRendererConfigurator() {
        _classCallCheck(this, BasicRendererConfigurator);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(BasicRendererConfigurator).apply(this, arguments));
    }

    _createClass(BasicRendererConfigurator, [{
        key: "getStageChain",
        value: function getStageChain(target) {
            return [{
                buffers: {
                    OUT: "hitarea"
                },
                stage: "jthree.hitarea"
            }, {
                buffers: {
                    DEPTH: "depth",
                    PRIMARY: "gbuffer.primary"
                },
                stage: "jthree.basic.gbuffer"
            }, {
                buffers: {
                    DEPTH: "depth",
                    PRIMARY: "gbuffer.primary",
                    DIFFUSE: "light.diffuse",
                    SPECULAR: "light.specular"
                },
                stage: "jthree.basic.light"
            }, {
                buffers: {
                    GBUFFER: "gbuffer.primary",
                    DLIGHT: "light.diffuse",
                    SLIGHT: "light.specular",
                    OUT: "output"
                },
                stage: "jthree.basic.foward"
            }, {
                buffers: {
                    INPUT: "output",
                    OUT: "default"
                },
                stage: "jthree.basic.fxaa",
                variables: {
                    reduceMin: 0.05,
                    reduceMul: 0.1,
                    spanMax: 3
                }
            }];
            // },
            // {
            //   buffers: {
            //     MAIN: "main",
            //     PRIMARY: "gbuffer.primary",
            //     OUT: "output"
            //   },
            //   stage: "jthree.basic.fogExp2",
            //   variables: {
            //     density: 2.0,
            //   }
            // },
            // {
            //   buffers: {
            //     INPUT: "output",
            //     OUT: "default"
            //   },
            //   stage: "jthree.basic.fxaa",
            //   variables: {
            //     reduceMin: 0.05,
            //     reduceMul: 0.1,
            //     spanMax: 3
            //   }
            // }];
        }
    }, {
        key: "TextureBuffers",
        get: function get() {
            return [{
                name: "depth",
                generater: "rendererfit",
                layout: "RGB",
                format: "UBYTE"
            }, {
                name: "gbuffer.primary",
                generater: "rendererfit",
                layout: "RGBA",
                format: "UBYTE"
            }, {
                name: "light.diffuse",
                generater: "rendererfit",
                layout: "RGB",
                format: "UBYTE"
            }, {
                name: "light.specular",
                generater: "rendererfit",
                layout: "RGB",
                format: "UBYTE"
            }, {
                name: "hitarea",
                generater: "rendererfit",
                layout: "RGBA",
                format: "UBYTE"
            }, {
                name: "main",
                generater: "rendererfit",
                layout: "RGBA",
                format: "UBYTE"
            }, {
                name: "output",
                generater: "rendererfit",
                layout: "RGBA",
                format: "UBYTE"
            }];
        }
    }]);

    return BasicRendererConfigurator;
}(_RendererConfiguratorBase2.default);

exports.default = BasicRendererConfigurator;

},{"./RendererConfiguratorBase":103}],103:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RendererConfiguratorBase = function () {
    function RendererConfiguratorBase() {
        _classCallCheck(this, RendererConfiguratorBase);
    }

    _createClass(RendererConfiguratorBase, [{
        key: "getStageChain",
        value: function getStageChain(target) {
            return null;
        }
    }, {
        key: "TextureBuffers",
        get: function get() {
            return null;
        }
    }]);

    return RendererConfiguratorBase;
}();

exports.default = RendererConfiguratorBase;

},{}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RendererConfiguratorBase = require("./RendererConfiguratorBase");

var _RendererConfiguratorBase2 = _interopRequireDefault(_RendererConfiguratorBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BasicRendererConfigurator = function (_ConfiguratorBase) {
    _inherits(BasicRendererConfigurator, _ConfiguratorBase);

    function BasicRendererConfigurator() {
        _classCallCheck(this, BasicRendererConfigurator);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(BasicRendererConfigurator).apply(this, arguments));
    }

    _createClass(BasicRendererConfigurator, [{
        key: "getStageChain",
        value: function getStageChain(target) {
            return [{
                buffers: {
                    DLIGHT: "light.diffuse",
                    SLIGHT: "light.specular",
                    OUT: "default"
                },
                stage: "jthree.basic.foward"
            }];
        }
    }, {
        key: "TextureBuffers",
        get: function get() {
            return [];
        }
    }]);

    return BasicRendererConfigurator;
}(_RendererConfiguratorBase2.default);

exports.default = BasicRendererConfigurator;

},{"./RendererConfiguratorBase":103}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BasicRenderer = require("./BasicRenderer");

var _BasicRenderer2 = _interopRequireDefault(_BasicRenderer);

var _BasicRendererConfigurator = require("./RendererConfigurator/BasicRendererConfigurator");

var _BasicRendererConfigurator2 = _interopRequireDefault(_BasicRendererConfigurator);

var _SpriteRendererConfigurator = require("./RendererConfigurator/SpriteRendererConfigurator");

var _SpriteRendererConfigurator2 = _interopRequireDefault(_SpriteRendererConfigurator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RendererFactory = function () {
    function RendererFactory() {
        _classCallCheck(this, RendererFactory);
    }

    _createClass(RendererFactory, null, [{
        key: "generateRenderer",
        value: function generateRenderer(canvas, drawRect, configureName) {
            configureName = configureName || "default";
            var renderer = new _BasicRenderer2.default(canvas, drawRect, new RendererFactory.rendererConfigurations[configureName]());
            renderer.initialize();
            return renderer;
        }
    }]);

    return RendererFactory;
}();

RendererFactory.rendererConfigurations = {
    "default": _BasicRendererConfigurator2.default,
    "sprite": _SpriteRendererConfigurator2.default
};
exports.default = RendererFactory;

},{"./BasicRenderer":81,"./RendererConfigurator/BasicRendererConfigurator":102,"./RendererConfigurator/SpriteRendererConfigurator":104}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _GeneraterList = require("./TextureGeneraters/GeneraterList");

var _GeneraterList2 = _interopRequireDefault(_GeneraterList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TextureGenerater = function () {
    function TextureGenerater() {
        _classCallCheck(this, TextureGenerater);
    }

    _createClass(TextureGenerater, null, [{
        key: "generateTexture",
        value: function generateTexture(renderer, generaterInfo) {
            var generaters = TextureGenerater._getGeneraters(renderer);
            var generater = generaters[generaterInfo.generater];
            generater.generate(generaterInfo);
            return TextureGenerater.getTexture(renderer, generaterInfo.name);
        }
    }, {
        key: "getTexture",
        value: function getTexture(renderer, bufferName) {
            return _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager).getTexture(renderer.id + "." + bufferName);
        }
    }, {
        key: "_getGeneraters",
        value: function _getGeneraters(renderer) {
            if (TextureGenerater._generaters[renderer.id]) {
                return TextureGenerater._generaters[renderer.id];
            }
            return TextureGenerater._initializeGeneraters(renderer);
        }
    }, {
        key: "_initializeGeneraters",
        value: function _initializeGeneraters(renderer) {
            var targetArray = {};
            var generaters = _GeneraterList2.default;
            for (var key in generaters) {
                if (generaters.hasOwnProperty(key)) {
                    var element = generaters[key];
                    targetArray[key] = new element(renderer);
                }
            }
            TextureGenerater._generaters[renderer.id] = targetArray;
            return targetArray;
        }
    }]);

    return TextureGenerater;
}();

TextureGenerater._generaters = {};
exports.default = TextureGenerater;

},{"../../ContextComponents":8,"../../JThreeContext":267,"./TextureGeneraters/GeneraterList":108}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Provides abstraction for texture generation.
 * By overriding, it is able to manage texture buffer in your way.
 */

var GeneraterBase = function GeneraterBase(parent) {
    _classCallCheck(this, GeneraterBase);

    this.__parentRenderer = parent;
};

exports.default = GeneraterBase;

},{}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _RendererFit = require("./RendererFit");

var _RendererFit2 = _interopRequireDefault(_RendererFit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    "rendererfit": _RendererFit2.default
};

},{"./RendererFit":109}],109:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLEnumParser = require("../../Canvas/GL/GLEnumParser");

var _GLEnumParser2 = _interopRequireDefault(_GLEnumParser);

var _GeneraterBase2 = require("./GeneraterBase");

var _GeneraterBase3 = _interopRequireDefault(_GeneraterBase2);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RendererFit = function (_GeneraterBase) {
    _inherits(RendererFit, _GeneraterBase);

    function RendererFit(parent) {
        _classCallCheck(this, RendererFit);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(RendererFit).call(this, parent));
    }

    _createClass(RendererFit, [{
        key: "generate",
        value: function generate(texInfo) {
            var rect = this.ParentRenderRectangle;
            var width = rect.Width,
                height = rect.Height;
            var elementLayout = undefined;
            texInfo["layout"] = texInfo["layout"] || "RGBA";
            elementLayout = _GLEnumParser2.default.parseTextureLayout(texInfo["layout"]);
            var elementFormat = undefined;
            texInfo["format"] = texInfo["format"] || "UBYTE";
            elementFormat = _GLEnumParser2.default.parseTextureFormat(texInfo["format"]);
            var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
            var resource = rm.createTexture(this.__parentRenderer.id + "." + texInfo.name, width, height, elementLayout, elementFormat);
            this.__parentRenderer.on("resize", function (s) {
                var bufTex = resource;
                if (s.Width !== bufTex.Width || s.Height !== bufTex.Height) {
                    resource.resize(s.Width, s.Height);
                }
            });
            return resource;
        }
    }, {
        key: "ParentRenderRectangle",
        get: function get() {
            return this.__parentRenderer.region;
        }
    }]);

    return RendererFit;
}(_GeneraterBase3.default);

exports.default = RendererFit;

},{"../../../ContextComponents":8,"../../../JThreeContext":267,"../../Canvas/GL/GLEnumParser":19,"./GeneraterBase":107}],110:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResourceLoader = function () {
    function ResourceLoader() {
        _classCallCheck(this, ResourceLoader);

        this.resourceCount = 0;
        this.loadedResourceCount = 0;
        this.completedResourceCount = 0;
        this.erroredResourceCount = 0;
        this.currentLoadingMessage = "";
        this._resourceLoadingDeferred = _q2.default.defer();
    }

    _createClass(ResourceLoader, [{
        key: "getResourceLoadingDeffered",
        value: function getResourceLoadingDeffered() {
            this.resourceCount++;
            var d = _q2.default.defer();
            this._registerForResourceLoaded(d.promise);
            return d;
        }
    }, {
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.ResourceLoader;
        }
        /**
         * INTERNAL USE
         * Register promise to be able to check status when the promise notify state.
         * @param {Q.Promise<void>} promise [description]
         */

    }, {
        key: "_registerForResourceLoaded",
        value: function _registerForResourceLoaded(promise) {
            var _this = this;

            promise.then(function () {
                _this.loadedResourceCount++;
                _this.completedResourceCount++;
                _this._checkResourceLoaded();
            }, function () {
                _this.completedResourceCount++;
                _this.erroredResourceCount++;
                _this._checkResourceLoaded();
            }, function (s) {
                _this.currentLoadingMessage = s;
            });
        }
        /**
         * Check whether all resources was loaded after fulfilled or errored subscribed deffereds.
         */

    }, {
        key: "_checkResourceLoaded",
        value: function _checkResourceLoaded() {
            if (this.completedResourceCount === this.resourceCount) {
                this._resourceLoadingDeferred.resolve({
                    hasNoError: this.erroredResourceCount > 0,
                    erroredResource: this.erroredResourceCount,
                    loadedResource: this.loadedResourceCount,
                    completedResource: this.completedResourceCount,
                    lastLoadMessage: this.currentLoadingMessage,
                    resourceCount: this.resourceCount
                });
                this._resourceLoadingDeferred = null;
            } else {
                this._resourceLoadingDeferred.notify({
                    hasNoError: this.erroredResourceCount > 0,
                    erroredResource: this.erroredResourceCount,
                    loadedResource: this.loadedResourceCount,
                    completedResource: this.completedResourceCount,
                    lastLoadMessage: this.currentLoadingMessage,
                    resourceCount: this.resourceCount
                });
            }
        }
    }, {
        key: "isLoading",
        get: function get() {
            return !!this._resourceLoadingDeferred;
        }
    }, {
        key: "promise",
        get: function get() {
            return this._resourceLoadingDeferred.promise;
        }
    }]);

    return ResourceLoader;
}();

exports.default = ResourceLoader;

},{"../ContextComponents":8,"q":338}],111:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ResourceResolver = require("./Resources/ResourceResolver");

var _ResourceResolver2 = _interopRequireDefault(_ResourceResolver);

var _ImageLoader = require("./Resources/ImageLoader");

var _ImageLoader2 = _interopRequireDefault(_ImageLoader);

var _JThreeObject = require("../Base/JThreeObject");

var _JThreeObject2 = _interopRequireDefault(_JThreeObject);

var _Buffer = require("./Resources/Buffer/Buffer");

var _Buffer2 = _interopRequireDefault(_Buffer);

var _Shader = require("./Resources/Shader/Shader");

var _Shader2 = _interopRequireDefault(_Shader);

var _Program = require("./Resources/Program/Program");

var _Program2 = _interopRequireDefault(_Program);

var _Texture = require("./Resources/Texture/Texture");

var _Texture2 = _interopRequireDefault(_Texture);

var _RBO = require("./Resources/RBO/RBO");

var _RBO2 = _interopRequireDefault(_RBO);

var _ResourceArray = require("./Resources/ResourceArray");

var _ResourceArray2 = _interopRequireDefault(_ResourceArray);

var _FBO = require("./Resources/FBO/FBO");

var _FBO2 = _interopRequireDefault(_FBO);

var _BufferTexture = require("./Resources/Texture/BufferTexture");

var _BufferTexture2 = _interopRequireDefault(_BufferTexture);

var _CubeTexture = require("./Resources/Texture/CubeTexture");

var _CubeTexture2 = _interopRequireDefault(_CubeTexture);

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * コンテキストを跨いでリソースを管理するクラスをまとめているクラス
 */

var ResourceManager = function (_jThreeObject) {
    _inherits(ResourceManager, _jThreeObject);

    function ResourceManager() {
        var _Object$getPrototypeO;

        _classCallCheck(this, ResourceManager);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(ResourceManager)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this._buffers = new _ResourceArray2.default();
        _this._shaders = new _ResourceArray2.default();
        _this._programs = new _ResourceArray2.default();
        _this._textures = new _ResourceArray2.default();
        _this._rbos = new _ResourceArray2.default();
        _this._fbos = new _ResourceArray2.default();
        return _this;
    }

    _createClass(ResourceManager, [{
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.ResourceManager;
        }
    }, {
        key: "loadTexture",
        value: function loadTexture(src) {
            var _this2 = this;

            var deferred = _q2.default.defer();
            if (this.getTexture(src)) {
                process.nextTick(function () {
                    deferred.resolve(_this2.getTexture(src));
                });
            }
            _ImageLoader2.default.loadImage(src).then(function (tag) {
                var texture = _this2.createTextureWithSource(src, tag);
                deferred.resolve(texture);
            }, function (error) {
                console.error(error);
                deferred.reject(error);
            });
            return deferred.promise;
        }
    }, {
        key: "loadCubeTexture",
        value: function loadCubeTexture(srcs) {
            var _this3 = this;

            var deferred = _q2.default.defer();
            var id = "";
            var absPaths = [,,,,,];
            for (var i = 0; i < 6; i++) {
                absPaths[i] = _ResourceResolver2.default.getAbsolutePath(srcs[i]);
                id += absPaths[i];
            }
            if (this.getTexture(id)) {
                process.nextTick(function () {
                    deferred.resolve(_this3.getTexture(id));
                });
            } else {
                var promises = [,,,,,];
                for (var _i = 0; _i < 6; _i++) {
                    promises[_i] = _ImageLoader2.default.loadImage(absPaths[_i]);
                }
                _q2.default.all(promises).then(function (textures) {
                    deferred.resolve(_this3.createCubeTextureWithSource(id, textures, false));
                });
            }
            return deferred.promise;
        }
    }, {
        key: "createBuffer",
        value: function createBuffer(id, target, usage, unitCount, elementType) {
            return this._buffers.create(id, function () {
                return new _Buffer2.default(target, usage, unitCount, elementType);
            });
        }
    }, {
        key: "getBuffer",
        value: function getBuffer(id) {
            return this._buffers.get(id);
        }
    }, {
        key: "createShader",
        value: function createShader(id, source, shaderType) {
            return this._shaders.create(id, function () {
                return _Shader2.default.createShader(source, shaderType);
            });
        }
    }, {
        key: "getShader",
        value: function getShader(id) {
            return this._shaders.get(id);
        }
    }, {
        key: "hasShader",
        value: function hasShader(id) {
            return this._shaders.has(id);
        }
    }, {
        key: "createProgram",
        value: function createProgram(id, shaders) {
            return this._programs.create(id, function () {
                return _Program2.default.createProgram(shaders);
            });
        }
    }, {
        key: "getProgram",
        value: function getProgram(id) {
            return this._programs.get(id);
        }
    }, {
        key: "createTextureWithSource",
        value: function createTextureWithSource(id, source) {
            return this._textures.create(id, function () {
                var tex = new _Texture2.default(source, id);
                tex.each(function (v) {
                    return v.init();
                }); // TODO no need?
                return tex;
            });
        }
    }, {
        key: "getTexture",
        value: function getTexture(id) {
            return this._textures.get(id);
        }
    }, {
        key: "createCubeTextureWithSource",
        value: function createCubeTextureWithSource(id, sources) {
            var flipY = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

            return this._textures.create(id, function () {
                var cubeTexture = new _CubeTexture2.default(sources, id, flipY);
                cubeTexture.each(function (v) {
                    return v.init();
                });
                return cubeTexture;
            });
        }
    }, {
        key: "createRBO",
        value: function createRBO(id, width, height) {
            return this._rbos.create(id, function () {
                var r = new _RBO2.default(width, height);
                r.each(function (v) {
                    return v.init();
                });
                return r;
            });
        }
    }, {
        key: "getRBO",
        value: function getRBO(id) {
            return this._rbos.get(id);
        }
    }, {
        key: "createFBO",
        value: function createFBO(id) {
            return this._fbos.create(id, function () {
                var fbo = new _FBO2.default();
                fbo.each(function (v) {
                    return v.init();
                });
                return fbo;
            });
        }
    }, {
        key: "getFBO",
        value: function getFBO(id) {
            return this._fbos.get(id);
        }
    }, {
        key: "createTexture",
        value: function createTexture(id, width, height) {
            var texType = arguments.length <= 3 || arguments[3] === undefined ? WebGLRenderingContext.RGBA : arguments[3];
            var elemType = arguments.length <= 4 || arguments[4] === undefined ? WebGLRenderingContext.UNSIGNED_BYTE : arguments[4];

            return this._textures.create(id, function () {
                var bt = new _BufferTexture2.default(width, height, texType, elemType, id);
                bt.each(function (v) {
                    return v.init();
                });
                return bt;
            });
        }
    }]);

    return ResourceManager;
}(_JThreeObject2.default);

exports.default = ResourceManager;

}).call(this,require('_process'))

},{"../Base/JThreeObject":3,"../ContextComponents":8,"./Resources/Buffer/Buffer":113,"./Resources/FBO/FBO":117,"./Resources/ImageLoader":119,"./Resources/Program/Program":120,"./Resources/RBO/RBO":122,"./Resources/ResourceArray":124,"./Resources/ResourceResolver":125,"./Resources/Shader/Shader":127,"./Resources/Texture/BufferTexture":129,"./Resources/Texture/CubeTexture":131,"./Resources/Texture/Texture":133,"_process":319,"q":338}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CacheResolver2 = require("./CacheResolver");

var _CacheResolver3 = _interopRequireDefault(_CacheResolver2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BasicCacheResolver = function (_CacheResolver) {
    _inherits(BasicCacheResolver, _CacheResolver);

    function BasicCacheResolver() {
        _classCallCheck(this, BasicCacheResolver);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(BasicCacheResolver).apply(this, arguments));
    }

    _createClass(BasicCacheResolver, [{
        key: "getIdentityName",
        value: function getIdentityName(name) {
            return name;
        }
    }]);

    return BasicCacheResolver;
}(_CacheResolver3.default);

exports.default = BasicCacheResolver;

},{"./CacheResolver":115}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextSafeResourceContainer = require("../ContextSafeResourceContainer");

var _ContextSafeResourceContainer2 = _interopRequireDefault(_ContextSafeResourceContainer);

var _BufferWrapper = require("./BufferWrapper");

var _BufferWrapper2 = _interopRequireDefault(_BufferWrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides buffer resource without considering context.
 */

var Buffer = function (_ContextSafeResourceC) {
    _inherits(Buffer, _ContextSafeResourceC);

    function Buffer(target, usage, unitCount, elementType) {
        _classCallCheck(this, Buffer);

        /**
         * This elements are normalized or not.
         * It must be false in WebGL1.0.
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Buffer).call(this));

        _this._normalized = false;
        _this._stride = 0;
        _this._offset = 0;
        /**
        * Length of this buffer.
        */
        _this._length = 0;
        _this._target = target;
        _this._usage = usage;
        _this._unitCount = unitCount;
        _this._elementType = elementType;
        _this.__initializeForFirst();
        return _this;
    }
    /**
    * Buffer target.
    * ArrayBuffer => VertexBuffer, ArrayElementBuffer => IndexBuffer
    */


    _createClass(Buffer, [{
        key: "update",
        value: function update(array, length) {
            this._elementCache = array;
            this._length = length;
            this.each(function (a) {
                return a.update(array, length);
            });
        }
    }, {
        key: "__createWrapperForCanvas",
        value: function __createWrapperForCanvas(canvas) {
            return new _BufferWrapper2.default(this, canvas);
        }
    }, {
        key: "Target",
        get: function get() {
            return this._target;
        }
        /**
        * Buffer usage.
        * StaticDraw,DynamicDraw,StreamDraw
        */

    }, {
        key: "Usage",
        get: function get() {
            return this._usage;
        }
    }, {
        key: "ElementType",
        get: function get() {
            return this._elementType;
        },
        set: function set(type) {
            this._elementType = type;
        }
        /**
        * This elements are normalized or not.
        * It must be false in WebGL1.0.
        */

    }, {
        key: "Normalized",
        get: function get() {
            return this._normalized;
        }
        /**
        * This elements are normalized or not.
        * It must be false in WebGL1.0.
        */
        ,
        set: function set(normalized) {
            this._normalized = normalized;
        }
    }, {
        key: "Stride",
        get: function get() {
            return this._stride;
        },
        set: function set(stride) {
            this._stride = stride;
        }
    }, {
        key: "Offset",
        get: function get() {
            return this._offset;
        },
        set: function set(offset) {
            this._offset = offset;
        }
        /**
        * Element count per 1 vertex.
        * This accessor is readonly.
        */

    }, {
        key: "UnitCount",
        get: function get() {
            return this._unitCount;
        }
    }, {
        key: "ElementCache",
        get: function get() {
            return this._elementCache;
        }
        /**
         * Length of this buffer.
         */

    }, {
        key: "Length",
        get: function get() {
            return this._length;
        }
    }]);

    return Buffer;
}(_ContextSafeResourceContainer2.default);

exports.default = Buffer;

},{"../ContextSafeResourceContainer":116,"./BufferWrapper":114}],114:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ResourceWrapper2 = require("../ResourceWrapper");

var _ResourceWrapper3 = _interopRequireDefault(_ResourceWrapper2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Buffer wrapper based on context.
 */

var BufferWrapper = function (_ResourceWrapper) {
    _inherits(BufferWrapper, _ResourceWrapper);

    function BufferWrapper(parentBuffer, canvas) {
        _classCallCheck(this, BufferWrapper);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BufferWrapper).call(this, canvas));

        _this._targetBuffer = null;
        _this._length = 0;
        _this._parentBuffer = parentBuffer;
        return _this;
    }

    _createClass(BufferWrapper, [{
        key: "dispose",
        value: function dispose() {
            if (this._targetBuffer) {
                this.GL.deleteBuffer(this._targetBuffer);
                this.__setInitialized(false);
                this._targetBuffer = null;
            }
        }
    }, {
        key: "update",
        value: function update(array, length) {
            if (!this.Initialized) {
                this.init();
            }
            this.bindBuffer();
            this.GL.bufferData(this._parentBuffer.Target, array, this._parentBuffer.Usage);
            this.unbindBuffer();
            this._length = length;
        }
    }, {
        key: "init",
        value: function init() {
            if (this._targetBuffer == null) {
                this._targetBuffer = this.GL.createBuffer();
                this.__setInitialized();
            }
        }
    }, {
        key: "bindBuffer",
        value: function bindBuffer() {
            if (this.Initialized) {
                this.GL.bindBuffer(this._parentBuffer.Target, this._targetBuffer);
            } else {
                this.init();
                this.update(this._parentBuffer.ElementCache, this._parentBuffer.Length);
                this.GL.bindBuffer(this._parentBuffer.Target, this._targetBuffer);
            }
        }
    }, {
        key: "unbindBuffer",
        value: function unbindBuffer() {
            if (this.Initialized) {
                this.GL.bindBuffer(this._parentBuffer.Target, null);
            }
        }
    }, {
        key: "Length",
        get: function get() {
            return this._length;
        }
    }, {
        key: "UnitCount",
        get: function get() {
            return this._parentBuffer.UnitCount;
        }
    }, {
        key: "ElementType",
        get: function get() {
            return this._parentBuffer.ElementType;
        }
    }, {
        key: "Normalized",
        get: function get() {
            return this._parentBuffer.Normalized;
        }
    }, {
        key: "Stride",
        get: function get() {
            return this._parentBuffer.Stride;
        }
    }, {
        key: "Offset",
        get: function get() {
            return this._parentBuffer.Offset;
        }
    }]);

    return BufferWrapper;
}(_ResourceWrapper3.default);

exports.default = BufferWrapper;

},{"../ResourceWrapper":126}],115:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CacheResolver = function () {
    function CacheResolver() {
        _classCallCheck(this, CacheResolver);

        this._isLoading = {};
        this._loadedResource = {};
        this._loadingPromise = {};
    }

    _createClass(CacheResolver, [{
        key: "pushLoaded",
        value: function pushLoaded(identity, content) {
            var path = this.getIdentityName(identity);
            this._loadedResource[path] = content;
            this._isLoading[path] = false;
        }
    }, {
        key: "fromCache",
        value: function fromCache(name) {
            var path = this.getIdentityName(name);
            if (this._isLoading[path] === false) {
                return this._loadedResource[this.getIdentityName(name)];
            } else {
                throw new Error("The resource " + name + " is not loaded yet.");
            }
        }
    }, {
        key: "fetch",
        value: function fetch(name, request) {
            var _this = this;

            var identity = this.getIdentityName(name);
            if (this._isLoading[identity] === true) {
                return this._loadingPromise[identity];
            } else {
                var _ret = function () {
                    var loader = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceLoader);
                    var deferred = loader.getResourceLoadingDeffered();
                    if (_this._isLoading[identity] === false) {
                        process.nextTick(function () {
                            deferred.resolve(_this._loadedResource[identity]);
                        });
                    } else {
                        request(identity).then(function (result) {
                            _this._loadedResource[identity] = result;
                            _this._isLoading[identity] = false;
                            deferred.resolve(result);
                        }, function (err) {
                            _this._isLoading[identity] = false;
                            deferred.reject(err);
                        });
                        _this._loadingPromise[identity] = deferred.promise;
                        _this._isLoading[identity] = true;
                    }
                    return {
                        v: deferred.promise
                    };
                }();

                if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
            }
        }
    }]);

    return CacheResolver;
}();

exports.default = CacheResolver;

}).call(this,require('_process'))

},{"../../ContextComponents":8,"../../JThreeContext":267,"_process":319}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectEEWithID2 = require("../../Base/JThreeObjectEEWithID");

var _JThreeObjectEEWithID3 = _interopRequireDefault(_JThreeObjectEEWithID2);

var _Exceptions = require("../../Exceptions");

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides context difference abstraction.
 */

var ContextSafeResourceContainer = function (_JThreeObjectEEWithID) {
    _inherits(ContextSafeResourceContainer, _JThreeObjectEEWithID);

    function ContextSafeResourceContainer() {
        _classCallCheck(this, ContextSafeResourceContainer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ContextSafeResourceContainer).call(this));

        _this._childWrapper = {};
        _this._wrapperLength = 0;
        var canvasManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.CanvasManager);
        // Initialize resources for the renderers already subscribed.
        canvasManager.on("canvas-list-changed", _this._rendererChanged.bind(_this));
        return _this;
    }

    _createClass(ContextSafeResourceContainer, [{
        key: "dispose",
        value: function dispose() {
            this.each(function (e) {
                e.dispose();
            });
        }
    }, {
        key: "getForGL",
        value: function getForGL(gl) {
            return this._getForContextID(gl.id);
        }
    }, {
        key: "each",
        value: function each(act) {
            for (var key in this._childWrapper) {
                act(this._childWrapper[key]);
            }
        }
    }, {
        key: "__createWrapperForCanvas",
        value: function __createWrapperForCanvas(canvas) {
            throw new _Exceptions.AbstractClassMethodCalledException();
        }
    }, {
        key: "__initializeForFirst",
        value: function __initializeForFirst() {
            var _this2 = this;

            var canvasManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.CanvasManager);
            canvasManager.canvases.forEach(function (v) {
                _this2._childWrapper[v.id] = _this2.__createWrapperForCanvas(v);
                _this2._wrapperLength++;
            });
        }
    }, {
        key: "_getForContextID",
        value: function _getForContextID(id) {
            if (!this._childWrapper[id]) {
                console.log("There is no matching object with the ID:" + id);
            }
            return this._childWrapper[id];
        }
    }, {
        key: "_rendererChanged",
        value: function _rendererChanged(arg) {
            if (arg.isAdditionalChange) {
                this._childWrapper[arg.canvas.id] = this.__createWrapperForCanvas(arg.canvas);
                this._wrapperLength++;
            } else {
                var delTarget = this._childWrapper[arg.canvas.id];
                delete this._childWrapper[arg.canvas.id];
                delTarget.dispose();
                this._wrapperLength--;
            }
        }
    }, {
        key: "wrappers",
        get: function get() {
            var array = new Array(this._wrapperLength);
            var index = 0;
            this.each(function (elem) {
                array[index] = elem;
                index++;
            });
            return array;
        }
    }]);

    return ContextSafeResourceContainer;
}(_JThreeObjectEEWithID3.default);

exports.default = ContextSafeResourceContainer;

},{"../../Base/JThreeObjectEEWithID":5,"../../ContextComponents":8,"../../Exceptions":159,"../../JThreeContext":267}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _FBOWrapper = require("./FBOWrapper");

var _FBOWrapper2 = _interopRequireDefault(_FBOWrapper);

var _ContextSafeResourceContainer = require("./../ContextSafeResourceContainer");

var _ContextSafeResourceContainer2 = _interopRequireDefault(_ContextSafeResourceContainer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FBO = function (_ContextSafeResourceC) {
    _inherits(FBO, _ContextSafeResourceC);

    function FBO() {
        _classCallCheck(this, FBO);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(FBO).call(this));

        _this.__initializeForFirst();
        return _this;
    }

    _createClass(FBO, [{
        key: "__createWrapperForCanvas",
        value: function __createWrapperForCanvas(canvas) {
            return new _FBOWrapper2.default(canvas);
        }
    }]);

    return FBO;
}(_ContextSafeResourceContainer2.default);

exports.default = FBO;

},{"./../ContextSafeResourceContainer":116,"./FBOWrapper":118}],118:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ResourceWrapper2 = require("../ResourceWrapper");

var _ResourceWrapper3 = _interopRequireDefault(_ResourceWrapper2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FBOWrapper = function (_ResourceWrapper) {
    _inherits(FBOWrapper, _ResourceWrapper);

    function FBOWrapper(canvas) {
        _classCallCheck(this, FBOWrapper);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(FBOWrapper).call(this, canvas));

        _this._textures = [];
        return _this;
    }

    _createClass(FBOWrapper, [{
        key: "init",
        value: function init() {
            if (!this.Initialized) {
                this._targetFBO = this.GL.createFramebuffer();
                this.GL.bindFramebuffer(this.GL.FRAMEBUFFER, this._targetFBO);
                this.__setInitialized();
            }
        }
    }, {
        key: "bind",
        value: function bind() {
            if (!this.Initialized) {
                this.init();
            }
            this.GL.bindFramebuffer(this.GL.FRAMEBUFFER, this._targetFBO);
        }
    }, {
        key: "unbind",
        value: function unbind() {
            this.GL.bindFramebuffer(this.GL.FRAMEBUFFER, null);
            /*        this.textures.forEach(tex=> {
                        tex.getForContext(this.OwnerCanvas).bind();
                        tex.generateMipmapIfNeed();
                    });*/
        }
    }, {
        key: "attachTexture",
        value: function attachTexture(attachmentType, tex) {
            if (!this.Initialized) {
                this.init();
            }
            this.bind();
            if (tex == null) {
                this.GL.framebufferTexture2D(this.GL.FRAMEBUFFER, attachmentType, this.GL.TEXTURE_2D, null, 0);
                return;
            }
            var wt = tex.getForGL(this.GL);
            wt.preTextureUpload();
            this.GL.framebufferTexture2D(this.GL.FRAMEBUFFER, attachmentType, this.GL.TEXTURE_2D, wt.TargetTexture, 0);
            tex.getForGL(this.GL).bind();
            tex.generateMipmapIfNeed();
            if (this._textures.indexOf(tex) !== -1) {
                this._textures.push(tex);
            }
            this.GL.bindTexture(tex.TargetTextureType, null);
        }
    }, {
        key: "attachRBO",
        value: function attachRBO(attachmentType, rbo) {
            if (!this.Initialized) {
                this.init();
            }
            this.bind();
            if (rbo == null) {
                this.GL.framebufferRenderbuffer(this.GL.FRAMEBUFFER, attachmentType, this.GL.RENDERBUFFER, null);
                return;
            }
            var wrapper = rbo.getForGL(this.GL);
            this.GL.framebufferRenderbuffer(this.GL.FRAMEBUFFER, attachmentType, this.GL.RENDERBUFFER, wrapper.Target);
        }
    }, {
        key: "dispose",
        value: function dispose() {
            if (this.Initialized) {
                this.GL.deleteFramebuffer(this._targetFBO);
                this._targetFBO = null;
                this.__setInitialized(false);
            }
        }
    }, {
        key: "TargetShader",
        get: function get() {
            if (!this.Initialized) {
                this.init();
            }
            return this._targetFBO;
        }
    }]);

    return FBOWrapper;
}(_ResourceWrapper3.default);

exports.default = FBOWrapper;

},{"../ResourceWrapper":126}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ResourceResolver = require("./ResourceResolver");

var _ResourceResolver2 = _interopRequireDefault(_ResourceResolver);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ImageLoader = function () {
    function ImageLoader() {
        _classCallCheck(this, ImageLoader);
    }

    _createClass(ImageLoader, null, [{
        key: "loadImage",
        value: function loadImage(src) {
            return ImageLoader._loader.fetch(src, function (path) {
                var deferred = _q2.default.defer();
                var imgTag = new Image();
                imgTag.onload = function () {
                    deferred.resolve(imgTag);
                };
                imgTag.onerror = function (e) {
                    deferred.reject(e);
                };
                imgTag.src = src;
                return deferred.promise;
            });
        }
    }]);

    return ImageLoader;
}();

ImageLoader._loader = new _ResourceResolver2.default();
exports.default = ImageLoader;

},{"./ResourceResolver":125,"q":338}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextSafeResourceContainer = require("../ContextSafeResourceContainer");

var _ContextSafeResourceContainer2 = _interopRequireDefault(_ContextSafeResourceContainer);

var _ProgramWrapper = require("./ProgramWrapper");

var _ProgramWrapper2 = _interopRequireDefault(_ProgramWrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Program = function (_ContextSafeContainer) {
    _inherits(Program, _ContextSafeContainer);

    function Program() {
        _classCallCheck(this, Program);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Program).call(this));

        _this._attachedShaders = [];
        _this.__initializeForFirst();
        return _this;
    }

    _createClass(Program, [{
        key: "attachShader",
        value: function attachShader(shader) {
            var _this2 = this;

            this._attachedShaders.push(shader);
            shader.on("source-updated", function () {
                _this2._relinkShader();
            });
        }
    }, {
        key: "__createWrapperForCanvas",
        value: function __createWrapperForCanvas(canvas) {
            return new _ProgramWrapper2.default(this, canvas);
        }
    }, {
        key: "uniformExists",
        value: function uniformExists(valName) {
            if (this.wrappers.length > 0) {
                return this.wrappers[0].uniformExists(valName);
            }
            throw new Error("Any program was not initialized!");
        }
    }, {
        key: "_relinkShader",
        value: function _relinkShader() {
            this.each(function (v) {
                v.relink();
            });
        }
    }, {
        key: "AttachedShaders",
        get: function get() {
            return this._attachedShaders;
        }
    }], [{
        key: "createProgram",
        value: function createProgram(attachShaders) {
            var program = new Program();
            program._attachedShaders = attachShaders;
            return program;
        }
    }]);

    return Program;
}(_ContextSafeResourceContainer2.default);

exports.default = Program;

},{"../ContextSafeResourceContainer":116,"./ProgramWrapper":121}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ResourceWrapper2 = require("../ResourceWrapper");

var _ResourceWrapper3 = _interopRequireDefault(_ResourceWrapper2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ProgramWrapper = function (_ResourceWrapper) {
    _inherits(ProgramWrapper, _ResourceWrapper);

    function ProgramWrapper(parent, canvas) {
        _classCallCheck(this, ProgramWrapper);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ProgramWrapper).call(this, canvas));

        _this._islinked = false;
        _this._targetProgram = null;
        _this._parentProgram = null;
        _this._attributeLocations = {};
        _this._uniformLocations = {};
        _this._parentProgram = parent;
        return _this;
    }

    _createClass(ProgramWrapper, [{
        key: "init",
        value: function init() {
            var _this2 = this;

            if (!this.Initialized) {
                this._targetProgram = this.GL.createProgram();
                this._parentProgram.AttachedShaders.forEach(function (v, i, a) {
                    _this2.GL.attachShader(_this2._targetProgram, v.getForGL(_this2.GL).TargetShader);
                });
                this.__setInitialized();
            }
        }
    }, {
        key: "dispose",
        value: function dispose() {
            if (this.Initialized) {
                this.GL.deleteProgram(this._targetProgram);
                this.__setInitialized(false);
                this._targetProgram = null;
                this._islinked = false;
            }
        }
    }, {
        key: "linkProgram",
        value: function linkProgram() {
            if (!this._islinked) {
                this.GL.linkProgram(this._targetProgram);
                if (!this.GL.getProgramParameter(this._targetProgram, this.GL.LINK_STATUS)) {
                    console.error("LINK ERROR:" + this.GL.getProgramInfoLog(this._targetProgram));
                }
                this._islinked = true;
            }
        }
    }, {
        key: "useProgram",
        value: function useProgram() {
            if (!this.Initialized) {
                this.init();
            }
            if (!this._islinked) {
                this.linkProgram();
            }
            this.GL.useProgram(this._targetProgram);
        }
    }, {
        key: "uniformExists",
        value: function uniformExists(valName) {
            this.useProgram();
            return this._fetchUniformLocation(valName) !== -1;
        }
        /**
         * Relink shader for shader source changing
         */

    }, {
        key: "relink",
        value: function relink() {
            var _this3 = this;

            this.GL.deleteProgram(this.TargetProgram);
            this._targetProgram = this.GL.createProgram();
            this._parentProgram.AttachedShaders.forEach(function (v, i, a) {
                _this3.GL.attachShader(_this3._targetProgram, v.getForGL(_this3.GL).TargetShader);
            });
        }
        /**
         * Assign attribute variable. This method requires that this related program was already used.
         * @param {string} variableName variable name to be assigned buffer
         * @param {Buffer} buffer       actual variable buffer to be assigned
         */

    }, {
        key: "assignAttributeVariable",
        value: function assignAttributeVariable(variableName, buffer) {
            var attribIndex = this._fetchAttributeLocation(variableName);
            if (attribIndex < 0) {
                return;
            } // When the variable was not found
            var bufWrapper = buffer.getForGL(this.GL);
            bufWrapper.bindBuffer();
            this.GL.vertexAttribPointer(attribIndex, buffer.UnitCount, buffer.ElementType, buffer.Normalized, buffer.Stride, buffer.Offset);
        }
    }, {
        key: "uniformMatrixArrayFromBuffer",
        value: function uniformMatrixArrayFromBuffer(variableName, buffer) {
            var location = this._fetchUniformLocation(variableName);
            if (!location) {
                return;
            }
            this.GL.uniform4fv(location, buffer);
        }
    }, {
        key: "uniformMatrixArray",
        value: function uniformMatrixArray(variableName, matArray) {
            var location = this._fetchUniformLocation(variableName);
            if (!location) {
                return;
            }
            this.GL.uniform4fv(location, matArray.rawElements);
        }
    }, {
        key: "uniformMatrix",
        value: function uniformMatrix(variableName, mat) {
            var location = this._fetchUniformLocation(variableName);
            if (!location) {
                return;
            }
            this.GL.uniformMatrix4fv(location, false, mat.rawElements);
        }
    }, {
        key: "uniformVector",
        value: function uniformVector(variableName, vec) {
            var location = this._fetchUniformLocation(variableName);
            if (!location) {
                return;
            }
            var rawVector = vec.rawElements;
            switch (vec.ElementCount) {
                case 2:
                    this.GL.uniform2f(location, rawVector[0], rawVector[1]);
                    return;
                case 3:
                    this.GL.uniform3f(location, rawVector[0], rawVector[1], rawVector[2]);
                    return;
                case 4:
                    this.GL.uniform4f(location, rawVector[0], rawVector[1], rawVector[2], rawVector[3]);
                    return;
                default:
                    console.error("Unexpected element count of vector!");
            }
        }
    }, {
        key: "uniformVectorArray",
        value: function uniformVectorArray(variableName, vectors) {
            var location = this._fetchUniformLocation(variableName);
            if (!location) {
                return;
            }
            switch (vectors.dimension) {
                case 2:
                    this.GL.uniform2fv(location, new Float32Array(vectors.rawElements));
                    return;
                case 3:
                    this.GL.uniform3fv(location, new Float32Array(vectors.rawElements));
                    return;
                case 4:
                    this.GL.uniform4fv(location, new Float32Array(vectors.rawElements));
                    return;
                default:
                    console.error("Unexpected element count of vector!");
            }
        }
    }, {
        key: "uniformFloat",
        value: function uniformFloat(variableName, val) {
            var location = this._fetchUniformLocation(variableName);
            if (!location) {
                return;
            }
            this.GL.uniform1f(location, val);
        }
    }, {
        key: "uniformFloatArray",
        value: function uniformFloatArray(variableName, val) {
            var location = this._fetchUniformLocation(variableName);
            if (!location) {
                return;
            }
            this.GL.uniform1fv(location, new Float32Array(val));
        }
    }, {
        key: "uniformInt",
        value: function uniformInt(variableName, val) {
            var location = this._fetchUniformLocation(variableName);
            if (!location) {
                return;
            }
            this.GL.uniform1i(location, val);
        }
    }, {
        key: "uniformIntArray",
        value: function uniformIntArray(variableName, val) {
            var location = this._fetchUniformLocation(variableName);
            if (!location) {
                return;
            }
            this.GL.uniform1iv(location, new Int32Array(val));
        }
    }, {
        key: "uniformSampler",
        value: function uniformSampler(variableName, tex, texRegister) {
            var location = this._fetchUniformLocation(variableName);
            var texWrapper = tex.getForGL(this.GL);
            if (!location) {
                return -1;
            }
            if (texWrapper.Initialized) {
                if (texWrapper.registerTexture(texRegister)) {
                    this.GL.uniform1i(location, texRegister);
                }
            }
        }
    }, {
        key: "_fetchUniformLocation",
        value: function _fetchUniformLocation(valName) {
            if (!this._uniformLocations[valName]) {
                this._uniformLocations[valName] = this.GL.getUniformLocation(this.TargetProgram, valName);
            }
            return this._uniformLocations[valName];
        }
    }, {
        key: "_fetchAttributeLocation",
        value: function _fetchAttributeLocation(valName) {
            if (!this._attributeLocations[valName]) {
                this._attributeLocations[valName] = this.GL.getAttribLocation(this.TargetProgram, valName);
                if (this._attributeLocations[valName] >= 0) {
                    this.GL.enableVertexAttribArray(this._attributeLocations[valName]);
                }
            }
            return this._attributeLocations[valName];
        }
    }, {
        key: "TargetProgram",
        get: function get() {
            return this._targetProgram;
        }
    }]);

    return ProgramWrapper;
}(_ResourceWrapper3.default);

exports.default = ProgramWrapper;

},{"../ResourceWrapper":126}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextSafeResourceContainer = require("./../ContextSafeResourceContainer");

var _ContextSafeResourceContainer2 = _interopRequireDefault(_ContextSafeResourceContainer);

var _RBOWrapper = require("./RBOWrapper");

var _RBOWrapper2 = _interopRequireDefault(_RBOWrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RBO = function (_ContextSafeResourceC) {
    _inherits(RBO, _ContextSafeResourceC);

    function RBO(width, height) {
        var format = arguments.length <= 2 || arguments[2] === undefined ? WebGLRenderingContext.DEPTH_COMPONENT16 : arguments[2];

        _classCallCheck(this, RBO);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RBO).call(this));

        _this._width = width;
        _this._height = height;
        _this._format = format;
        _this.__initializeForFirst();
        return _this;
    }

    _createClass(RBO, [{
        key: "__createWrapperForCanvas",
        value: function __createWrapperForCanvas(canvas) {
            return new _RBOWrapper2.default(canvas, this);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            if (this._width !== width || this._height !== height) {
                this._width = width;
                this._height = height;
                this.each(function (v) {
                    return v.resize(width, height);
                });
            }
        }
    }, {
        key: "Width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "Height",
        get: function get() {
            return this._height;
        }
    }, {
        key: "Format",
        get: function get() {
            return this._format;
        }
    }]);

    return RBO;
}(_ContextSafeResourceContainer2.default);

exports.default = RBO;

},{"./../ContextSafeResourceContainer":116,"./RBOWrapper":123}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ResourceWrapper2 = require("../ResourceWrapper");

var _ResourceWrapper3 = _interopRequireDefault(_ResourceWrapper2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides wrapper class for Render Buffer Object depending on particular WebGLRenderingContext.
 * Most of user may have no reason to modify by themselves.
 */

var RBOWrapper = function (_ResourceWrapper) {
    _inherits(RBOWrapper, _ResourceWrapper);

    function RBOWrapper(canvas, parentRBO) {
        _classCallCheck(this, RBOWrapper);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RBOWrapper).call(this, canvas));

        _this._parent = parentRBO;
        return _this;
    }

    _createClass(RBOWrapper, [{
        key: "init",
        value: function init() {
            if (this.Initialized) {
                return;
            }
            this._targetRBO = this.GL.createRenderbuffer();
            this.bind();
            this.GL.renderbufferStorage(this.GL.RENDERBUFFER, this._parent.Format, this._parent.Width, this._parent.Height);
            this.__setInitialized();
        }
    }, {
        key: "bind",
        value: function bind() {
            this.GL.bindRenderbuffer(this.GL.RENDERBUFFER, this._targetRBO);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            if (this.Initialized) {
                this.bind();
                this.GL.renderbufferStorage(this.GL.RENDERBUFFER, this._parent.Format, this._parent.Width, this._parent.Height);
            }
        }
    }, {
        key: "dispose",
        value: function dispose() {
            if (this._targetRBO) {
                this.GL.deleteRenderbuffer(this._targetRBO);
                this._targetRBO = null;
                this.__setInitialized(false);
            }
        }
    }, {
        key: "Target",
        get: function get() {
            return this._targetRBO;
        }
    }]);

    return RBOWrapper;
}(_ResourceWrapper3.default);

exports.default = RBOWrapper;

},{"../ResourceWrapper":126}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject2 = require("../../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ResourceArray = function (_JThreeObject) {
    _inherits(ResourceArray, _JThreeObject);

    function ResourceArray() {
        var _Object$getPrototypeO;

        _classCallCheck(this, ResourceArray);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(ResourceArray)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this._resourceArray = {};
        _this._handlerArray = {};
        return _this;
    }

    _createClass(ResourceArray, [{
        key: "create",
        value: function create(id, creationFunc) {
            var resource = undefined;
            if (this._resourceArray[id]) {
                resource = this._resourceArray[id];
                return resource;
            } else {
                resource = creationFunc();
                this._resourceArray[id] = resource;
                var handlers = this._handlerArray[id];
                if (handlers) {
                    handlers.forEach(function (v) {
                        return v(resource);
                    });
                }
                return resource;
            }
        }
    }, {
        key: "get",
        value: function get(id) {
            return this._resourceArray[id];
        }
    }, {
        key: "has",
        value: function has(id) {
            return !!this._resourceArray[id];
        }
    }, {
        key: "getHandler",
        value: function getHandler(id, handler) {
            if (this.has(id)) {
                handler(this.get(id));
            } else {
                if (this._handlerArray[id]) {
                    this._handlerArray[id].push(handler);
                } else {
                    this._handlerArray[id] = [handler];
                }
            }
        }
    }]);

    return ResourceArray;
}(_JThreeObject3.default);

exports.default = ResourceArray;

},{"../../Base/JThreeObject":3}],125:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CacheResolver = require("./CacheResolver");

var _CacheResolver2 = _interopRequireDefault(_CacheResolver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ResourceResolver = function (_CacheResovler) {
    _inherits(ResourceResolver, _CacheResovler);

    function ResourceResolver() {
        _classCallCheck(this, ResourceResolver);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ResourceResolver).apply(this, arguments));
    }

    _createClass(ResourceResolver, [{
        key: "getIdentityName",
        value: function getIdentityName(name) {
            return ResourceResolver.getAbsolutePath(name);
        }
    }], [{
        key: "getAbsolutePath",
        value: function getAbsolutePath(name) {
            var aElem = document.createElement("a");
            aElem.href = name;
            return aElem.href;
        }
    }]);

    return ResourceResolver;
}(_CacheResolver2.default);

exports.default = ResourceResolver;

},{"./CacheResolver":115}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectEE2 = require("../../Base/JThreeObjectEE");

var _JThreeObjectEE3 = _interopRequireDefault(_JThreeObjectEE2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ResourceWrapper = function (_JThreeObjectEE) {
    _inherits(ResourceWrapper, _JThreeObjectEE);

    function ResourceWrapper(ownerCanvas) {
        _classCallCheck(this, ResourceWrapper);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ResourceWrapper).call(this));

        _this._ownerCanvas = ownerCanvas;
        return _this;
    }

    _createClass(ResourceWrapper, [{
        key: "dispose",
        value: function dispose() {
            return;
        }
        /**
        * The canvas hold this resource.
        */

    }, {
        key: "init",
        value: function init() {
            return;
        }
    }, {
        key: "__setInitialized",
        value: function __setInitialized(initialized) {
            if (typeof initialized === "undefined") {
                initialized = true;
            }
            if (initialized === this._initialized) {
                return;
            }
            this._initialized = initialized;
            this.emit("initialized", initialized);
        }
    }, {
        key: "OwnerCanvas",
        get: function get() {
            return this._ownerCanvas;
        }
        /**
        * The ID string for identify which canvas manager holds this resource.
        */

    }, {
        key: "OwnerID",
        get: function get() {
            return this._ownerCanvas.id;
        }
    }, {
        key: "GL",
        get: function get() {
            return this._ownerCanvas.gl;
        }
        /**
        * Getter for whether this resource was initialized for this context or not.
        */

    }, {
        key: "Initialized",
        get: function get() {
            return this._initialized;
        }
    }]);

    return ResourceWrapper;
}(_JThreeObjectEE3.default);

exports.default = ResourceWrapper;

},{"../../Base/JThreeObjectEE":4}],127:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextSafeResourceContainer = require("../ContextSafeResourceContainer");

var _ContextSafeResourceContainer2 = _interopRequireDefault(_ContextSafeResourceContainer);

var _ShaderWrapper = require("./ShaderWrapper");

var _ShaderWrapper2 = _interopRequireDefault(_ShaderWrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Shader = function (_ContextSafeContainer) {
    _inherits(Shader, _ContextSafeContainer);

    /**
     * コンストラクタ
     * (Should not be called by new,You should use CreateShader static method instead.)
     */

    function Shader() {
        _classCallCheck(this, Shader);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Shader).call(this));

        _this.__initializeForFirst();
        return _this;
    }
    /**
     * シェーダークラスを作成する。
     */


    _createClass(Shader, [{
        key: "loadAll",

        /**
         * Load all shaderWrappers
         */
        value: function loadAll() {
            this.each(function (v) {
                v.init();
            });
        }
    }, {
        key: "__createWrapperForCanvas",
        value: function __createWrapperForCanvas(canvas) {
            return new _ShaderWrapper2.default(this, canvas);
        }
        /**
         * Update shader source code.
         * @param shaderSource new shader source code.
         */

    }, {
        key: "update",
        value: function update(shaderSource) {
            this._shaderSource = shaderSource;
            this.each(function (v) {
                v.update();
            });
            this.emit("source-updated", shaderSource);
        }
    }, {
        key: "ShaderType",

        /**
         * Shader Type
         * (VertexShader or FragmentShader)
         */
        get: function get() {
            return this._shaderType;
        }
        /**
         * Shader Source in text
         */

    }, {
        key: "ShaderSource",
        get: function get() {
            return this._shaderSource;
        }
    }], [{
        key: "createShader",
        value: function createShader(source, shaderType) {
            var shader = new Shader();
            shader._shaderSource = source;
            shader._shaderType = shaderType;
            return shader;
        }
    }]);

    return Shader;
}(_ContextSafeResourceContainer2.default);

exports.default = Shader;

},{"../ContextSafeResourceContainer":116,"./ShaderWrapper":128}],128:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeLogger = require("../../../Base/JThreeLogger");

var _JThreeLogger2 = _interopRequireDefault(_JThreeLogger);

var _ResourceWrapper2 = require("../ResourceWrapper");

var _ResourceWrapper3 = _interopRequireDefault(_ResourceWrapper2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ShaderWrapper = function (_ResourceWrapper) {
    _inherits(ShaderWrapper, _ResourceWrapper);

    function ShaderWrapper(parent, canvas) {
        _classCallCheck(this, ShaderWrapper);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ShaderWrapper).call(this, canvas));

        _this._targetShader = null;
        _this._parentShader = parent;
        return _this;
    }

    _createClass(ShaderWrapper, [{
        key: "init",
        value: function init() {
            if (!this.Initialized) {
                this._targetShader = this.GL.createShader(this._parentShader.ShaderType);
                this.GL.shaderSource(this._targetShader, this._parentShader.ShaderSource);
                this.GL.compileShader(this._targetShader);
                this._checkCompileStatus();
                this.__setInitialized(true);
            }
        }
    }, {
        key: "dispose",
        value: function dispose() {
            if (this.Initialized) {
                this.GL.deleteShader(this._targetShader);
                this._targetShader = null;
                this.__setInitialized(false);
            }
        }
        /**
         * Update shader source from Shader class.
         */

    }, {
        key: "update",
        value: function update() {
            this.GL.deleteShader(this._targetShader);
            this._targetShader = this.GL.createShader(this._parentShader.ShaderType);
            this.GL.shaderSource(this.TargetShader, this._parentShader.ShaderSource);
            this.GL.compileShader(this.TargetShader);
        }
    }, {
        key: "_checkCompileStatus",
        value: function _checkCompileStatus() {
            if (!this.GL.getShaderParameter(this._targetShader, this.GL.COMPILE_STATUS)) {
                console.error("Compile error!:" + this.GL.getShaderInfoLog(this._targetShader));
                _JThreeLogger2.default.sectionLongLog("COMPILE_ERROR", this._parentShader.ShaderSource);
            }
        }
    }, {
        key: "TargetShader",
        get: function get() {
            if (!this.Initialized) {
                this.init();
            }
            return this._targetShader;
        }
    }]);

    return ShaderWrapper;
}(_ResourceWrapper3.default);

exports.default = ShaderWrapper;

},{"../../../Base/JThreeLogger":2,"../ResourceWrapper":126}],129:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BufferTextureWrapper = require("./BufferTextureWrapper");

var _BufferTextureWrapper2 = _interopRequireDefault(_BufferTextureWrapper);

var _TextureBase2 = require("./TextureBase");

var _TextureBase3 = _interopRequireDefault(_TextureBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Buffer texture is a texture created from array programatically.
 */

var BufferTexture = function (_TextureBase) {
    _inherits(BufferTexture, _TextureBase);

    function BufferTexture(width, height, textureFormat, elementFormat, textureName) {
        _classCallCheck(this, BufferTexture);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BufferTexture).call(this, textureName));

        _this._width = width;
        _this._height = height;
        _this.__textureFormat = textureFormat;
        _this.__elementFormat = elementFormat;
        if (_this.__elementFormat === WebGLRenderingContext.FLOAT) {
            _this.MinFilter = WebGLRenderingContext.NEAREST;
            _this.MagFilter = WebGLRenderingContext.NEAREST;
        }
        return _this;
    }

    _createClass(BufferTexture, [{
        key: "__createWrapperForCanvas",
        value: function __createWrapperForCanvas(canvas) {
            return new _BufferTextureWrapper2.default(canvas, this);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            if (this._width !== width || this._height !== height) {
                this._width = width;
                this._height = height;
                this.each(function (v) {
                    return v.resize(width, height);
                });
            }
        }
    }, {
        key: "updateTexture",
        value: function updateTexture(buffer) {
            this.each(function (t) {
                t.updateTexture(buffer);
            });
        }
    }, {
        key: "Width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "Height",
        get: function get() {
            return this._height;
        }
    }]);

    return BufferTexture;
}(_TextureBase3.default);

exports.default = BufferTexture;

},{"./BufferTextureWrapper":130,"./TextureBase":134}],130:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _TextureWrapperBase2 = require("./TextureWrapperBase");

var _TextureWrapperBase3 = _interopRequireDefault(_TextureWrapperBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BufferTextureWrapper = function (_TextureWrapperBase) {
    _inherits(BufferTextureWrapper, _TextureWrapperBase);

    function BufferTextureWrapper(ownerCanvas, parent) {
        _classCallCheck(this, BufferTextureWrapper);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(BufferTextureWrapper).call(this, ownerCanvas, parent));
    }

    _createClass(BufferTextureWrapper, [{
        key: "init",
        value: function init() {
            if (this.Initialized) {
                return;
            }
            var parent = this.Parent;
            this.__setTargetTexture(this.GL.createTexture());
            this.bind();
            this.GL.texImage2D(WebGLRenderingContext.TEXTURE_2D, 0, parent.TextureFormat, parent.Width, parent.Height, 0, parent.TextureFormat, parent.ElementFormat, null);
            this.__setInitialized();
        }
    }, {
        key: "unbind",
        value: function unbind() {
            // TODO consider is it really need to implement unbind
            this.GL.bindTexture(WebGLRenderingContext.TEXTURE_2D, null);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            this.bind();
            if (this.Initialized) {
                var parent = this.Parent;
                this.preTextureUpload();
                this.GL.texImage2D(WebGLRenderingContext.TEXTURE_2D, 0, parent.TextureFormat, parent.Width, parent.Height, 0, parent.TextureFormat, parent.ElementFormat, null);
            }
        }
    }, {
        key: "updateTexture",
        value: function updateTexture(buffer) {
            this.bind();
            if (this.Initialized) {
                var parent = this.Parent;
                this.preTextureUpload();
                this.GL.texImage2D(WebGLRenderingContext.TEXTURE_2D, 0, parent.TextureFormat, parent.Width, parent.Height, 0, parent.TextureFormat, parent.ElementFormat, buffer);
            }
            this.unbind();
        }
    }, {
        key: "generateHtmlImage",
        value: function generateHtmlImage(encoder) {
            var parent = this.Parent;
            return this.__encodeHtmlImage(parent.Width, parent.Height, encoder);
        }
    }]);

    return BufferTextureWrapper;
}(_TextureWrapperBase3.default);

exports.default = BufferTextureWrapper;

},{"./TextureWrapperBase":136}],131:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _TextureBase2 = require("./TextureBase");

var _TextureBase3 = _interopRequireDefault(_TextureBase2);

var _CubeTextureWrapper = require("./CubeTextureWrapper");

var _CubeTextureWrapper2 = _interopRequireDefault(_CubeTextureWrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CubeTexture = function (_TextureBase) {
    _inherits(CubeTexture, _TextureBase);

    function CubeTexture(source, textureName, flipY) {
        _classCallCheck(this, CubeTexture);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CubeTexture).call(this, textureName, flipY, true));

        _this._imageSource = null;
        _this.ImageSource = source;
        return _this;
    }

    _createClass(CubeTexture, [{
        key: "__createWrapperForCanvas",
        value: function __createWrapperForCanvas(canvas) {
            var textureWrapper = new _CubeTextureWrapper2.default(canvas, this);
            return textureWrapper;
        }
    }, {
        key: "ImageSource",
        get: function get() {
            return this._imageSource;
        },
        set: function set(img) {
            this._imageSource = img;
            this.each(function (v) {
                return v.init(true);
            });
            this.generateMipmapIfNeed();
        }
    }]);

    return CubeTexture;
}(_TextureBase3.default);

exports.default = CubeTexture;

},{"./CubeTextureWrapper":132,"./TextureBase":134}],132:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _TextureWrapperBase2 = require("./TextureWrapperBase");

var _TextureWrapperBase3 = _interopRequireDefault(_TextureWrapperBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CubeTextureWrapper = function (_TextureWrapperBase) {
    _inherits(CubeTextureWrapper, _TextureWrapperBase);

    function CubeTextureWrapper(canvas, parent) {
        _classCallCheck(this, CubeTextureWrapper);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(CubeTextureWrapper).call(this, canvas, parent));
    }

    _createClass(CubeTextureWrapper, [{
        key: "init",
        value: function init(isChanged) {
            var parent = this.Parent;
            if (this.Initialized && !isChanged) {
                return;
            }
            if (this.TargetTexture == null) {
                this.__setTargetTexture(this.GL.createTexture());
            }
            this.GL.bindTexture(WebGLRenderingContext.TEXTURE_CUBE_MAP, this.TargetTexture);
            if (parent.ImageSource == null) {
                for (var i = 0; i < 6; i++) {
                    this.GL.texImage2D(WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, WebGLRenderingContext.RGBA, 1, 1, 0, WebGLRenderingContext.RGBA, WebGLRenderingContext.UNSIGNED_BYTE, _TextureWrapperBase3.default.__altTextureBuffer);
                }
            } else {
                this.preTextureUpload();
                for (var _i = 0; _i < 6; _i++) {
                    if (parent.ImageSource[_i]) {
                        this.GL.texImage2D(WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + _i, 0, WebGLRenderingContext.RGBA, WebGLRenderingContext.RGBA, WebGLRenderingContext.UNSIGNED_BYTE, parent.ImageSource[_i]);
                    }
                }
            }
            this.GL.bindTexture(WebGLRenderingContext.TEXTURE_CUBE_MAP, null);
            this.__setInitialized();
        }
    }]);

    return CubeTextureWrapper;
}(_TextureWrapperBase3.default);

exports.default = CubeTextureWrapper;

},{"./TextureWrapperBase":136}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _TextureWrapper = require("./TextureWrapper");

var _TextureWrapper2 = _interopRequireDefault(_TextureWrapper);

var _TextureBase2 = require("./TextureBase");

var _TextureBase3 = _interopRequireDefault(_TextureBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Texture = function (_TextureBase) {
    _inherits(Texture, _TextureBase);

    function Texture(source, textureName) {
        _classCallCheck(this, Texture);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Texture).call(this, textureName));

        _this._imageSource = null;
        _this._imageSource = source;
        return _this;
    }

    _createClass(Texture, [{
        key: "__createWrapperForCanvas",
        value: function __createWrapperForCanvas(canvas) {
            var textureWrapper = new _TextureWrapper2.default(canvas, this);
            return textureWrapper;
        }
    }, {
        key: "ImageSource",
        get: function get() {
            return this._imageSource;
        },
        set: function set(img) {
            this._imageSource = img;
            this.each(function (v) {
                return v.updateTexture();
            });
            this.generateMipmapIfNeed();
        }
    }]);

    return Texture;
}(_TextureBase3.default);

exports.default = Texture;

},{"./TextureBase":134,"./TextureWrapper":135}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextSafeResourceContainer = require("../ContextSafeResourceContainer");

var _ContextSafeResourceContainer2 = _interopRequireDefault(_ContextSafeResourceContainer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 */

var TextureBase = function (_ContextSafeResourceC) {
    _inherits(TextureBase, _ContextSafeResourceC);

    function TextureBase(textureName, flipY, isCubeTexture) {
        _classCallCheck(this, TextureBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TextureBase).call(this));

        _this.__textureFormat = WebGLRenderingContext.RGBA;
        _this.__elementFormat = WebGLRenderingContext.UNSIGNED_BYTE;
        _this._targetTextureType = WebGLRenderingContext.TEXTURE_2D;
        _this._minFilter = WebGLRenderingContext.NEAREST;
        _this._magFilter = WebGLRenderingContext.NEAREST;
        _this._tWrap = WebGLRenderingContext.CLAMP_TO_EDGE;
        _this._sWrap = WebGLRenderingContext.CLAMP_TO_EDGE;
        _this._flipY = false;
        if (typeof flipY === "undefined") {
            flipY = false;
        }
        if (typeof isCubeTexture === "undefined") {
            isCubeTexture = false;
        }
        _this._flipY = flipY;
        _this._targetTextureType = isCubeTexture ? WebGLRenderingContext.TEXTURE_CUBE_MAP : WebGLRenderingContext.TEXTURE_2D;
        _this.__initializeForFirst();
        return _this;
    }

    _createClass(TextureBase, [{
        key: "generateMipmapIfNeed",
        value: function generateMipmapIfNeed() {
            var _this2 = this;

            switch (this.MinFilter) {
                case WebGLRenderingContext.LINEAR_MIPMAP_LINEAR:
                case WebGLRenderingContext.LINEAR_MIPMAP_NEAREST:
                case WebGLRenderingContext.NEAREST_MIPMAP_LINEAR:
                case WebGLRenderingContext.NEAREST_MIPMAP_NEAREST:
                    this.each(function (v) {
                        v.bind();
                        v.GL.generateMipmap(_this2.TargetTextureType);
                    });
                    break;
                default:
            }
        }
    }, {
        key: "TargetTextureType",
        get: function get() {
            return this._targetTextureType;
        }
    }, {
        key: "TextureFormat",
        get: function get() {
            return this.__textureFormat;
        }
    }, {
        key: "ElementFormat",
        get: function get() {
            return this.__elementFormat;
        }
    }, {
        key: "FlipY",
        get: function get() {
            return this._flipY;
        },
        set: function set(val) {
            this._flipY = val;
        }
    }, {
        key: "MinFilter",
        get: function get() {
            return this._minFilter;
        },
        set: function set(value) {
            if (value === this._minFilter) {
                return;
            }
            this._minFilter = value;
            this.emit("filter-changed", WebGLRenderingContext.TEXTURE_MIN_FILTER);
        }
    }, {
        key: "MagFilter",
        get: function get() {
            return this._magFilter;
        },
        set: function set(value) {
            if (value === this._magFilter) {
                return;
            }
            this._magFilter = value;
            this.emit("filter-changed", WebGLRenderingContext.TEXTURE_MAG_FILTER);
        }
    }, {
        key: "SWrap",
        get: function get() {
            return this._sWrap;
        },
        set: function set(value) {
            if (this._sWrap === value) {
                return;
            }
            this._sWrap = value;
            this.emit("filyer-changed", WebGLRenderingContext.TEXTURE_WRAP_S);
        }
    }, {
        key: "TWrap",
        get: function get() {
            return this._tWrap;
        },
        set: function set(value) {
            if (this._tWrap === value) {
                return;
            }
            this._tWrap = value;
            this.emit("filyer-changed", WebGLRenderingContext.TEXTURE_WRAP_T);
        }
    }, {
        key: "TextureName",
        get: function get() {
            return this._textureName;
        }
    }]);

    return TextureBase;
}(_ContextSafeResourceContainer2.default);

exports.default = TextureBase;

},{"../ContextSafeResourceContainer":116}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _TextureWrapperBase2 = require("./TextureWrapperBase");

var _TextureWrapperBase3 = _interopRequireDefault(_TextureWrapperBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TextureWrapper = function (_TextureWrapperBase) {
    _inherits(TextureWrapper, _TextureWrapperBase);

    function TextureWrapper(canvas, parent) {
        _classCallCheck(this, TextureWrapper);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(TextureWrapper).call(this, canvas, parent));
    }

    _createClass(TextureWrapper, [{
        key: "init",
        value: function init(isChanged) {
            if (this.Initialized && !isChanged) {
                return;
            }
            if (this.TargetTexture == null) {
                this.__setTargetTexture(this.GL.createTexture());
            }
            this.updateTexture();
            this.GL.bindTexture(WebGLRenderingContext.TEXTURE_2D, null);
            this.__setInitialized();
        }
    }, {
        key: "updateTexture",
        value: function updateTexture() {
            var parentTexture = this.Parent;
            this.GL.bindTexture(WebGLRenderingContext.TEXTURE_2D, this.TargetTexture);
            if (parentTexture.ImageSource == null) {
                this.GL.texImage2D(WebGLRenderingContext.TEXTURE_2D, 0, WebGLRenderingContext.RGBA, 1, 1, 0, WebGLRenderingContext.RGBA, WebGLRenderingContext.UNSIGNED_BYTE, _TextureWrapperBase3.default.__altTextureBuffer);
            } else {
                this.preTextureUpload();
                this.GL.texImage2D(WebGLRenderingContext.TEXTURE_2D, 0, WebGLRenderingContext.RGBA, WebGLRenderingContext.RGBA, WebGLRenderingContext.UNSIGNED_BYTE, parentTexture.ImageSource);
            }
        }
    }]);

    return TextureWrapper;
}(_TextureWrapperBase3.default);

exports.default = TextureWrapper;

},{"./TextureWrapperBase":136}],136:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ResourceWrapper2 = require("../ResourceWrapper");

var _ResourceWrapper3 = _interopRequireDefault(_ResourceWrapper2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TextureWrapperBase = function (_ResourceWrapper) {
    _inherits(TextureWrapperBase, _ResourceWrapper);

    function TextureWrapperBase(owner, parent) {
        _classCallCheck(this, TextureWrapperBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TextureWrapperBase).call(this, owner));

        _this._targetTexture = null;
        _this._parent = parent;
        _this._parent.on("filter-changed", _this._applyTextureParameter.bind(_this));
        return _this;
    }

    _createClass(TextureWrapperBase, [{
        key: "bind",
        value: function bind() {
            if (this._targetTexture != null) {
                this.GL.bindTexture(this.Parent.TargetTextureType, this._targetTexture);
            } else {
                this.GL.bindTexture(this.Parent.TargetTextureType, null);
            }
        }
    }, {
        key: "registerTexture",
        value: function registerTexture(registerIndex) {
            if (this.TargetTexture == null) {
                this.GL.activeTexture(WebGLRenderingContext.TEXTURE0 + registerIndex);
                this.GL.bindTexture(this._parent.TargetTextureType, null);
                return false;
            }
            this.GL.activeTexture(WebGLRenderingContext.TEXTURE0 + registerIndex);
            this._applyTextureParameter();
            return true;
        }
    }, {
        key: "init",
        value: function init() {
            return;
        }
    }, {
        key: "preTextureUpload",
        value: function preTextureUpload() {
            if (this._parent.FlipY) {
                this.GL.pixelStorei(WebGLRenderingContext.UNPACK_FLIP_Y_WEBGL, 1);
            } else {
                this.GL.pixelStorei(WebGLRenderingContext.UNPACK_FLIP_Y_WEBGL, 0);
            }
        }
    }, {
        key: "generateHtmlImage",
        value: function generateHtmlImage(encoder) {
            return null;
        }
    }, {
        key: "dispose",
        value: function dispose() {
            if (this._targetTexture) {
                this.GL.deleteTexture(this._targetTexture);
                this.__setInitialized(false);
                this._targetTexture = null;
            }
        }
    }, {
        key: "getPixel",
        value: function getPixel(x, y) {
            var result = new Uint8Array(4);
            var frameBuffer = this.GL.createFramebuffer();
            this.GL.bindFramebuffer(this.GL.FRAMEBUFFER, frameBuffer);
            this.GL.framebufferTexture2D(this.GL.FRAMEBUFFER, this.GL.COLOR_ATTACHMENT0, this.GL.TEXTURE_2D, this._targetTexture, 0);
            this.GL.readPixels(x, y, 1, 1, this.GL.RGBA, this.Parent.ElementFormat, result);
            this.GL.deleteFramebuffer(frameBuffer);
            return result;
        }
    }, {
        key: "__setTargetTexture",
        value: function __setTargetTexture(texture) {
            this._targetTexture = texture;
        }
    }, {
        key: "__encodeHtmlImage",
        value: function __encodeHtmlImage(width, height, encode) {
            var lastFBO = this.GL.getParameter(this.GL.FRAMEBUFFER_BINDING);
            // Create framebuffer to transfer texture data
            var framebuffer = this.GL.createFramebuffer();
            this.GL.bindFramebuffer(this.GL.FRAMEBUFFER, framebuffer);
            this.GL.framebufferTexture2D(this.GL.FRAMEBUFFER, this.GL.COLOR_ATTACHMENT0, this.GL.TEXTURE_2D, this._targetTexture, 0);
            var data = undefined;
            var dataArrayConstructor = undefined;
            var transformFunc = undefined;
            switch (this.Parent.ElementFormat) {
                case WebGLRenderingContext.FLOAT:
                    dataArrayConstructor = Float32Array;
                    break;
                case WebGLRenderingContext.UNSIGNED_BYTE:
                    dataArrayConstructor = Uint8Array;
                    break;
                case WebGLRenderingContext.UNSIGNED_SHORT:
                case WebGLRenderingContext.UNSIGNED_SHORT_5_6_5:
                case WebGLRenderingContext.UNSIGNED_SHORT_4_4_4_4:
                case WebGLRenderingContext.UNSIGNED_SHORT_5_5_5_1:
                    dataArrayConstructor = Uint16Array;
                    break;
                default:
                    console.error("Element format is not supported!");
                    return;
            }
            switch (this.Parent.TextureFormat) {
                case WebGLRenderingContext.RGB:
                    data = new dataArrayConstructor(width * height * 4);
                    transformFunc = function transformFunc(w, h, arr) {
                        var ret = new Uint8Array(w * h * 4);
                        for (var x = 0; x < w; x++) {
                            for (var y = 0; y < h; y++) {
                                ret[4 * (y * w + x) + 0] = arr[4 * ((h - y) * w + x) + 0];
                                ret[4 * (y * w + x) + 1] = arr[4 * ((h - y) * w + x) + 1];
                                ret[4 * (y * w + x) + 2] = arr[4 * ((h - y) * w + x) + 2];
                                ret[4 * (y * w + x) + 3] = 255;
                            }
                        }
                        return ret;
                    };
                    break;
                case WebGLRenderingContext.RGBA:
                    data = new dataArrayConstructor(width * height * 4);
                    transformFunc = function transformFunc(w, h, arr) {
                        var ret = new Uint8Array(w * h * 4);
                        for (var x = 0; x < w; x++) {
                            for (var y = 0; y < h; y++) {
                                ret[4 * (y * w + x) + 0] = arr[4 * ((h - y) * w + x) + 0];
                                ret[4 * (y * w + x) + 1] = arr[4 * ((h - y) * w + x) + 1];
                                ret[4 * (y * w + x) + 2] = arr[4 * ((h - y) * w + x) + 2];
                                ret[4 * (y * w + x) + 3] = arr[4 * ((h - y) * w + x) + 3];
                            }
                        }
                        return ret;
                    };
                    break;
                case WebGLRenderingContext.ALPHA:
                    data = new dataArrayConstructor(width * height * 4);
                    transformFunc = function transformFunc(w, h, arr) {
                        var ret = new Uint8Array(w * h * 4);
                        for (var x = 0; x < w; x++) {
                            for (var y = 0; y < h; y++) {
                                ret[4 * (y * w + x) + 0] = arr[4 * (y * w + x)];
                                ret[4 * (y * w + x) + 1] = 0;
                                ret[4 * (y * w + x) + 2] = 0;
                                ret[4 * (y * w + x) + 3] = 255;
                            }
                        }
                        return ret;
                    };
                    break;
                default:
                    console.error("Specified texture format is unsupported!");
                    return;
            }
            transformFunc = encode || transformFunc;
            // read pixels from framebuffer
            this.GL.readPixels(0, 0, width, height, WebGLRenderingContext.RGBA, this.Parent.ElementFormat, data);
            this.GL.deleteFramebuffer(framebuffer);
            this.GL.bindFramebuffer(this.GL.FRAMEBUFFER, lastFBO);
            // generate canvas for result
            var canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            var context = canvas.getContext("2d");
            // Copy the pixels to a 2D canvas
            var imageData = context.createImageData(width, height);
            imageData.data.set(transformFunc(width, height, data));
            context.putImageData(imageData, 0, 0);
            var img = new Image();
            img.src = canvas.toDataURL();
            return img;
        }
        /**
         * apply texture parameters
         */

    }, {
        key: "_applyTextureParameter",
        value: function _applyTextureParameter() {
            if (this._targetTexture == null) {
                return;
            }
            this.bind();
            this.GL.texParameteri(this.Parent.TargetTextureType, WebGLRenderingContext.TEXTURE_MIN_FILTER, this._parent.MinFilter);
            this.GL.texParameteri(this.Parent.TargetTextureType, WebGLRenderingContext.TEXTURE_MAG_FILTER, this._parent.MagFilter);
            this.GL.texParameteri(this.Parent.TargetTextureType, WebGLRenderingContext.TEXTURE_WRAP_S, this._parent.SWrap);
            this.GL.texParameteri(this.Parent.TargetTextureType, WebGLRenderingContext.TEXTURE_WRAP_T, this._parent.TWrap);
        }
    }, {
        key: "Parent",
        get: function get() {
            return this._parent;
        }
    }, {
        key: "TargetTexture",
        get: function get() {
            return this._targetTexture;
        }
    }]);

    return TextureWrapperBase;
}(_ResourceWrapper3.default);

TextureWrapperBase.__altTextureBuffer = new Uint8Array([255, 0, 255, 255]);
exports.default = TextureWrapperBase;

},{"../ResourceWrapper":126}],137:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectEEWithID = require("../Base/JThreeObjectEEWithID");

var _JThreeObjectEEWithID2 = _interopRequireDefault(_JThreeObjectEEWithID);

var _Color = require("../Math/Color3");

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides scene feature.
 */

var Scene = function (_jThreeObjectEEWithID) {
    _inherits(Scene, _jThreeObjectEEWithID);

    function Scene(id) {
        _classCallCheck(this, Scene);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Scene).call(this, id));

        _this.children = [];
        /**
         * Scene ambient coefficients
         */
        _this.sceneAmbient = new _Color2.default(1.0, 1.0, 1.0);
        _this._renderers = [];
        _this.enabled = true;
        return _this;
    }
    /**
     * Scene will be updated by this method.
     * This method is intended to be called by jThree system.
     * You don't need to call this method manually in most of use case.
     */


    _createClass(Scene, [{
        key: "update",
        value: function update() {
            if (!this.enabled) {
                return;
            }
            this.children.forEach(function (v) {
                return v.update();
            });
        }
        /**
         * Scene will be rendererd by this method.
         * This method is intended to be called by jThree system.
         * You don't need to call this method manually in most of use case.
         */

    }, {
        key: "render",
        value: function render() {
            var _this2 = this;

            this._renderers.forEach(function (r) {
                r.beforeRender();
                r.render(_this2);
                r.afterRender();
            });
        }
    }, {
        key: "addRenderer",
        value: function addRenderer(renderer) {
            this._renderers.push(renderer);
            this.emit("changed-renderer", {
                owner: this,
                renderer: renderer,
                isAdditionalChange: true
            });
        }
    }, {
        key: "removeRenderer",
        value: function removeRenderer(renderer) {
            var index = this._renderers.indexOf(renderer);
            if (index < 0) {
                return;
            }
            this._renderers.splice(index, 1);
            this.emit("changed-renderer", {
                owner: this,
                renderer: renderer,
                isAdditionalChange: false
            });
        }
    }, {
        key: "addObject",

        /**
         * Add SceneObject to scene hierarchy top.
         * @param {SceneObject} targetObject target scene object which will be inserted.
         * @param {number}      index        insert index of location in children.
         */
        value: function addObject(targetObject, index) {
            if (index == null) {
                index = this.children.length;
            }
            this.children.splice(index, 0, targetObject);
            targetObject.ParentScene = this;
            this.notifySceneObjectChanged({
                owner: null,
                scene: this,
                isAdditionalChange: true,
                changedSceneObject: targetObject,
                changedSceneObjectID: targetObject.id
            });
        }
        /**
         * Remove SceneObject from scene hierarchy top.
         * @param {SceneObject} removeTarget target object which will be removed.
         */

    }, {
        key: "removeObject",
        value: function removeObject(removeTarget) {
            var index = this.children.indexOf(removeTarget);
            if (index >= 0) {
                this.children.splice(index, 1);
                removeTarget.ParentScene = null;
                this.notifySceneObjectChanged({
                    owner: null,
                    scene: this,
                    isAdditionalChange: false,
                    changedSceneObject: removeTarget,
                    changedSceneObjectID: removeTarget.id
                });
            }
        }
    }, {
        key: "notifySceneObjectChanged",
        value: function notifySceneObjectChanged(eventArg) {
            this.emit("structure-changed", eventArg);
        }
    }, {
        key: "Renderers",
        get: function get() {
            return this._renderers;
        }
    }]);

    return Scene;
}(_JThreeObjectEEWithID2.default);

exports.default = Scene;

},{"../Base/JThreeObjectEEWithID":5,"../Math/Color3":269}],138:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectEE = require("../Base/JThreeObjectEE");

var _JThreeObjectEE2 = _interopRequireDefault(_JThreeObjectEE);

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* The class for managing entire _scenes.
*/

var SceneManager = function (_jThreeObjectEE) {
    _inherits(SceneManager, _jThreeObjectEE);

    function SceneManager() {
        _classCallCheck(this, SceneManager);

        /**
         * All scene map. Hold by Scene.ID.
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SceneManager).call(this));

        _this._scenes = {};
        var loopManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.LoopManager);
        loopManager.addAction(5000, function () {
            return _this.renderAll();
        });
        return _this;
    }

    _createClass(SceneManager, [{
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.SceneManager;
        }
        /**
        * Add new scene to be managed.
        */

    }, {
        key: "addScene",
        value: function addScene(scene) {
            if (!this._scenes[scene.id]) {
                this._scenes[scene.id] = scene;
                this.emit("change", {
                    owner: this,
                    isAdditionalChange: true,
                    changedScene: scene
                });
            }
        }
        /**
         * All scene list this class is managing.
         */

    }, {
        key: "removeScene",

        /**
        * Remove exisiting scene from managed.
        */
        value: function removeScene(scene) {
            if (this._scenes[scene.id]) {
                delete this._scenes[scene.id];
                this.emit("change", {
                    owner: this,
                    isAdditionalChange: false,
                    changedScene: scene
                });
            }
        }
        /**
         * Process render for all _scenes
         * This method is intended to be called by jThree system.
         * You don't need to call this method maually in most case.
         */

    }, {
        key: "renderAll",
        value: function renderAll() {
            for (var sceneId in this._scenes) {
                var scene = this._scenes[sceneId];
                scene.update();
                scene.render();
            }
        }
    }, {
        key: "Scenes",
        get: function get() {
            var array = [];
            for (var scene in this._scenes) {
                array.push(this._scenes[scene]);
            }
            return array;
        }
    }]);

    return SceneManager;
}(_JThreeObjectEE2.default);

exports.default = SceneManager;

},{"../Base/JThreeObjectEE":4,"../ContextComponents":8,"../JThreeContext":267}],139:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _PrimaryBufferMaterial = require("../Materials/Buffering/PrimaryBufferMaterial");

var _PrimaryBufferMaterial2 = _interopRequireDefault(_PrimaryBufferMaterial);

var _Mesh2 = require("./Mesh");

var _Mesh3 = _interopRequireDefault(_Mesh2);

var _HitAreaMaterial = require("../Materials/Buffering/HitAreaMaterial");

var _HitAreaMaterial2 = _interopRequireDefault(_HitAreaMaterial);

var _BasicMaterial = require("../Materials/BasicMaterial");

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BasicMeshObject = function (_Mesh) {
    _inherits(BasicMeshObject, _Mesh);

    function BasicMeshObject(geometry, mat) {
        _classCallCheck(this, BasicMeshObject);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BasicMeshObject).call(this, geometry, mat));

        _this.addMaterial(new _PrimaryBufferMaterial2.default());
        _this.addMaterial(new _BasicMaterial2.default(require("../Materials/BuiltIn/GBuffer/Depth.xmml"), "builtin.depth"));
        _this.addMaterial(new _HitAreaMaterial2.default());
        return _this;
    }

    return BasicMeshObject;
}(_Mesh3.default);

exports.default = BasicMeshObject;

},{"../Materials/BasicMaterial":36,"../Materials/Buffering/HitAreaMaterial":37,"../Materials/Buffering/PrimaryBufferMaterial":38,"../Materials/BuiltIn/GBuffer/Depth.xmml":40,"./Mesh":150}],140:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SceneObject2 = require("../SceneObject");

var _SceneObject3 = _interopRequireDefault(_SceneObject2);

var _Matrix = require("../../../Math/Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

var _glMatrix = require("gl-matrix");

var _PointList = require("../../../Math/PointList");

var _PointList2 = _interopRequireDefault(_PointList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Basement class of Camera. These class related to camera are one of SceneObject in jThree.
 */

var Camera = function (_SceneObject) {
    _inherits(Camera, _SceneObject);

    function Camera() {
        var _Object$getPrototypeO;

        _classCallCheck(this, Camera);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Camera)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.viewProjectionMatrix = new _Matrix2.default();
        _this.viewProjectionInvMatrix = new _Matrix2.default();
        /**
         * View frustum vertex points in World space
         */
        _this.frustumPoints = new _PointList2.default();
        _this.viewMatrix = new _Matrix2.default();
        _this.projectionMatrix = new _Matrix2.default();
        _this.invProjectionMatrix = new _Matrix2.default();
        return _this;
    }

    _createClass(Camera, [{
        key: "__updateViewProjectionMatrix",
        value: function __updateViewProjectionMatrix() {
            _glMatrix.mat4.mul(this.viewProjectionMatrix.rawElements, this.projectionMatrix.rawElements, this.viewMatrix.rawElements);
            _glMatrix.mat4.invert(this.viewProjectionInvMatrix.rawElements, this.viewProjectionMatrix.rawElements);
            _PointList2.default.initializeWithCube(this.frustumPoints);
            this.frustumPoints.transform(this.viewProjectionInvMatrix);
        }
    }, {
        key: "update",
        value: function update() {
            _get(Object.getPrototypeOf(Camera.prototype), "update", this).call(this);
        }
    }, {
        key: "Far",
        get: function get() {
            return 0;
        }
    }, {
        key: "Near",
        get: function get() {
            return 0;
        }
    }]);

    return Camera;
}(_SceneObject3.default);

exports.default = Camera;

},{"../../../Math/Matrix":271,"../../../Math/PointList":274,"../SceneObject":151,"gl-matrix":320}],141:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ViewCameraBase = require("./ViewCameraBase");

var _ViewCameraBase2 = _interopRequireDefault(_ViewCameraBase);

var _glMatrix = require("gl-matrix");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OrthoCamera = function (_ViewCamera) {
    _inherits(OrthoCamera, _ViewCamera);

    function OrthoCamera() {
        _classCallCheck(this, OrthoCamera);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(OrthoCamera).call(this));

        _this._updateProjectionMatrix();
        return _this;
    }

    _createClass(OrthoCamera, [{
        key: "_updateProjectionMatrix",
        value: function _updateProjectionMatrix() {
            _glMatrix.mat4.ortho(this.projectionMatrix.rawElements, this.Left, this.Right, this.Bottom, this.Top, this.Near, this.Far);
            _glMatrix.mat4.invert(this.invProjectionMatrix.rawElements, this.projectionMatrix.rawElements);
            this.__updateViewProjectionMatrix();
        }
    }, {
        key: "Left",
        get: function get() {
            return this._left;
        },
        set: function set(left) {
            this._left = left;
            this._updateProjectionMatrix();
        }
    }, {
        key: "Right",
        get: function get() {
            return this._right;
        },
        set: function set(right) {
            this._right = right;
            this._updateProjectionMatrix();
        }
    }, {
        key: "Top",
        get: function get() {
            return this._top;
        },
        set: function set(_top) {
            this._top = _top;
            this._updateProjectionMatrix();
        }
    }, {
        key: "Bottom",
        get: function get() {
            return this._bottom;
        },
        set: function set(bottom) {
            this._bottom = bottom;
            this._updateProjectionMatrix();
        }
    }, {
        key: "Near",
        get: function get() {
            return this._near;
        },
        set: function set(near) {
            this._near = near;
            this._updateProjectionMatrix();
        }
    }, {
        key: "Far",
        get: function get() {
            return this._far;
        },
        set: function set(far) {
            this._far = far;
            this._updateProjectionMatrix();
        }
    }]);

    return OrthoCamera;
}(_ViewCameraBase2.default);

exports.default = OrthoCamera;

},{"./ViewCameraBase":143,"gl-matrix":320}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ViewCameraBase = require("./ViewCameraBase");

var _ViewCameraBase2 = _interopRequireDefault(_ViewCameraBase);

var _glMatrix = require("gl-matrix");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PerspectiveCamera = function (_ViewCamera) {
    _inherits(PerspectiveCamera, _ViewCamera);

    function PerspectiveCamera() {
        var _Object$getPrototypeO;

        _classCallCheck(this, PerspectiveCamera);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(PerspectiveCamera)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this._fovy = Math.PI / 4;
        _this._aspect = 1;
        _this._near = 0.1;
        _this._far = 10;
        return _this;
    }

    _createClass(PerspectiveCamera, [{
        key: "_updateProjectionMatrix",
        value: function _updateProjectionMatrix() {
            _glMatrix.mat4.perspective(this.projectionMatrix.rawElements, this._fovy, this._aspect, this._near, this._far);
            _glMatrix.mat4.invert(this.invProjectionMatrix.rawElements, this.projectionMatrix.rawElements);
            this.__updateViewProjectionMatrix();
        }
    }, {
        key: "Fovy",
        get: function get() {
            return this._fovy;
        },
        set: function set(fovy) {
            this._fovy = fovy;
            this._updateProjectionMatrix();
        }
    }, {
        key: "Aspect",
        get: function get() {
            return this._aspect;
        },
        set: function set(aspect) {
            this._aspect = aspect;
            this._updateProjectionMatrix();
        }
    }, {
        key: "Near",
        get: function get() {
            return this._near;
        },
        set: function set(near) {
            this._near = near;
            this._updateProjectionMatrix();
        }
    }, {
        key: "Far",
        get: function get() {
            return this._far;
        },
        set: function set(far) {
            this._far = far;
            this._updateProjectionMatrix();
        }
    }]);

    return PerspectiveCamera;
}(_ViewCameraBase2.default);

exports.default = PerspectiveCamera;

},{"./ViewCameraBase":143,"gl-matrix":320}],143:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Camera2 = require("./Camera");

var _Camera3 = _interopRequireDefault(_Camera2);

var _Vector = require("../../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _glMatrix = require("gl-matrix");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The abstract class to be overridden by camera related class having view matrix.
 *
 * ビュー行列を保持するカメラによってオーバーライドされるための抽象クラス
 * @type {[type]}
 */

var ViewCameraBase = function (_Camera) {
  _inherits(ViewCameraBase, _Camera);

  /**
   * constructor
   */

  function ViewCameraBase() {
    _classCallCheck(this, ViewCameraBase);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ViewCameraBase).call(this));

    _this._generateViewMatrix();
    _this.__transformer.on("transform", function () {
      return _this._updateViewProjectionMatrix();
    });
    return _this;
  }
  /**
   * Notify view-projection matrix was updated.
   *
   * ビュー・射影行列が更新されたことを通知します。
   */


  _createClass(ViewCameraBase, [{
    key: "_updateViewProjectionMatrix",
    value: function _updateViewProjectionMatrix() {
      this._generateViewMatrix();
      this.__updateViewProjectionMatrix();
    }
    /**
     * Generate view matrix
     *
     * ビュー行列を生成します。
     */

  }, {
    key: "_generateViewMatrix",
    value: function _generateViewMatrix() {
      _glMatrix.mat4.lookAt(this.viewMatrix.rawElements, this.Transformer.GlobalPosition.rawElements, _Vector2.default.add(this.Transformer.forward, this.Transformer.GlobalPosition).rawElements, this.Transformer.up.rawElements);
    }
  }]);

  return ViewCameraBase;
}(_Camera3.default);

exports.default = ViewCameraBase;

},{"../../../Math/Vector3":278,"./Camera":140,"gl-matrix":320}],144:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _BasicMaterial = require("../../../Materials/BasicMaterial");

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _ContextComponents = require("../../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _LightBase2 = require("./../LightBase");

var _LightBase3 = _interopRequireDefault(_LightBase2);

var _Matrix = require("../../../../Math/Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides area light feature.
 */

var AreaLight = function (_LightBase) {
    _inherits(AreaLight, _LightBase);

    function AreaLight() {
        _classCallCheck(this, AreaLight);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AreaLight).call(this));

        _this.intensity = 1.0;
        _this.Geometry = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.PrimitiveRegistory).getPrimitive("cube");
        var material = new _BasicMaterial2.default(require("../../../Materials/BuiltIn/Light/Diffuse/AreaLight.xmml"), "builtin.light.area");
        material.on("apply", function (matArg) {
            material.shaderVariables = {
                lightColor: _this.Color.toVector().multiplyWith(_this.intensity),
                areaMatrix: _Matrix2.default.inverse(_Matrix2.default.multiply(matArg.renderStage.renderer.camera.viewMatrix, matArg.object.Transformer.localToGlobal))
            };
        });
        _this.addMaterial(material);
        return _this;
    }

    return AreaLight;
}(_LightBase3.default);

exports.default = AreaLight;

},{"../../../../ContextComponents":8,"../../../../JThreeContext":267,"../../../../Math/Matrix":271,"../../../Materials/BasicMaterial":36,"../../../Materials/BuiltIn/Light/Diffuse/AreaLight.xmml":45,"./../LightBase":149}],145:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _LightBase2 = require("../LightBase");

var _LightBase3 = _interopRequireDefault(_LightBase2);

var _BasicMaterial = require("../../../Materials/BasicMaterial");

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _Vector = require("../../../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _Matrix = require("../../../../Math/Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

var _ContextComponents = require("../../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides directional light feature.
 */

var DirectionalLight = function (_LightBase) {
    _inherits(DirectionalLight, _LightBase);

    function DirectionalLight() {
        _classCallCheck(this, DirectionalLight);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DirectionalLight).call(this));

        _this.bias = 0.2;
        _this.Geometry = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.PrimitiveRegistory).getPrimitive("quad");
        var diffuseMaterial = new _BasicMaterial2.default(require("../../../Materials/BuiltIn/Light/Diffuse/DirectionalLight.xmml"), "builtin.light.directional.diffuse");
        diffuseMaterial.on("apply", function (matArg) {
            diffuseMaterial.shaderVariables = {
                lightColor: _this.Color.toVector().multiplyWith(_this.intensity),
                lightDirection: _Vector2.default.normalize(_Matrix2.default.transformNormal(matArg.renderStage.renderer.camera.viewMatrix, _this.__transformer.forward))
            };
        });
        var specularMaterial = new _BasicMaterial2.default(require("../../../Materials/BuiltIn/Light/Specular/DirectionalLight.xmml"), "builtin.light.directional.specular");
        specularMaterial.on("apply", function (matArg) {
            specularMaterial.shaderVariables = {
                lightColor: _this.Color.toVector().multiplyWith(_this.intensity),
                lightDirection: _Vector2.default.normalize(_Matrix2.default.transformNormal(matArg.renderStage.renderer.camera.viewMatrix, _this.__transformer.forward))
            };
        });
        _this.addMaterial(diffuseMaterial);
        _this.addMaterial(specularMaterial);
        return _this;
    }

    return DirectionalLight;
}(_LightBase3.default);

exports.default = DirectionalLight;

},{"../../../../ContextComponents":8,"../../../../JThreeContext":267,"../../../../Math/Matrix":271,"../../../../Math/Vector3":278,"../../../Materials/BasicMaterial":36,"../../../Materials/BuiltIn/Light/Diffuse/DirectionalLight.xmml":46,"../../../Materials/BuiltIn/Light/Specular/DirectionalLight.xmml":50,"../LightBase":149}],146:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Vector = require("../../../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _BasicMaterial = require("../../../Materials/BasicMaterial");

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _ContextComponents = require("../../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _LightBase2 = require("./../LightBase");

var _LightBase3 = _interopRequireDefault(_LightBase2);

var _Matrix = require("../../../../Math/Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Point Light
 */

var PointLight = function (_LightBase) {
    _inherits(PointLight, _LightBase);

    function PointLight() {
        _classCallCheck(this, PointLight);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PointLight).call(this));

        _this.distance = 0.0;
        _this.intensity = 1.0;
        _this.decay = 1;
        _this.Geometry = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.PrimitiveRegistory).getPrimitive("sphere");
        var diffuseMaterial = new _BasicMaterial2.default(require("../../../Materials/BuiltIn/Light/Diffuse/PointLight.xmml"), "builtin.light.point.diffuse");
        diffuseMaterial.on("apply", function (matArg) {
            _this.Transformer.Scale = new _Vector2.default(_this.distance, _this.distance, _this.distance);
            diffuseMaterial.shaderVariables = {
                lightColor: _this.Color.toVector().multiplyWith(_this.intensity),
                decay: _this.decay,
                dist: _this.distance,
                lightPosition: _Matrix2.default.transformPoint(matArg.renderStage.renderer.camera.viewMatrix, _this.Position)
            };
        });
        var specularMaterial = new _BasicMaterial2.default(require("../../../Materials/BuiltIn/Light/Specular/PointLight.xmml"), "builtin.light.point.specular");
        specularMaterial.on("apply", function (matArg) {
            _this.Transformer.Scale = new _Vector2.default(_this.distance, _this.distance, _this.distance);
            specularMaterial.shaderVariables = {
                lightColor: _this.Color.toVector().multiplyWith(_this.intensity),
                decay: _this.decay,
                dist: _this.distance,
                lightPosition: _Matrix2.default.transformPoint(matArg.renderStage.renderer.camera.viewMatrix, _this.Position)
            };
        });
        _this.addMaterial(diffuseMaterial);
        _this.addMaterial(specularMaterial);
        return _this;
    }

    return PointLight;
}(_LightBase3.default);

exports.default = PointLight;

},{"../../../../ContextComponents":8,"../../../../JThreeContext":267,"../../../../Math/Matrix":271,"../../../../Math/Vector3":278,"../../../Materials/BasicMaterial":36,"../../../Materials/BuiltIn/Light/Diffuse/PointLight.xmml":47,"../../../Materials/BuiltIn/Light/Specular/PointLight.xmml":51,"./../LightBase":149}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _BasicMaterial = require("../../../Materials/BasicMaterial");

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _JThreeContext = require("../../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _LightBase2 = require("./../LightBase");

var _LightBase3 = _interopRequireDefault(_LightBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides area light feature.
 * Parameters:
 * X:TYPE ID ,XYZ:COLOR
 */

var SceneLight = function (_LightBase) {
    _inherits(SceneLight, _LightBase);

    function SceneLight() {
        _classCallCheck(this, SceneLight);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SceneLight).call(this));

        _this.intensity = 1.0;
        _this.Geometry = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.PrimitiveRegistory).getPrimitive("quad");
        var material = new _BasicMaterial2.default(require("../../../Materials/BuiltIn/Light/Diffuse/SceneLight.xmml"), "builtin.light.scene");
        material.on("apply", function (matArg) {
            material.shaderVariables = {
                lightColor: _this.Color.toVector().multiplyWith(_this.intensity)
            };
        });
        _this.addMaterial(material);
        return _this;
    }

    return SceneLight;
}(_LightBase3.default);

exports.default = SceneLight;

},{"../../../../ContextComponents":8,"../../../../JThreeContext":267,"../../../Materials/BasicMaterial":36,"../../../Materials/BuiltIn/Light/Diffuse/SceneLight.xmml":48,"./../LightBase":149}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _BasicMaterial = require("../../../Materials/BasicMaterial");

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _ContextComponents = require("../../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _LightBase2 = require("./../LightBase");

var _LightBase3 = _interopRequireDefault(_LightBase2);

var _Matrix = require("../../../../Math/Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

var _Vector = require("../../../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Point Light
 */

var SpotLight = function (_LightBase) {
    _inherits(SpotLight, _LightBase);

    function SpotLight() {
        _classCallCheck(this, SpotLight);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SpotLight).call(this));

        _this.intensity = 1;
        _this.innerAngle = 0.2;
        _this.outerAngle = 0.5;
        _this.innerDistance = 4;
        _this.outerDistance = 15;
        _this.angleDecay = 1.0;
        _this.distanceDecay = 1.0;
        _this.Geometry = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.PrimitiveRegistory).getPrimitive("cone");
        var diffuseMaterial = new _BasicMaterial2.default(require("../../../Materials/BuiltIn/Light/Diffuse/SpotLight.xmml"), "builtin.light.spot.diffuse");
        diffuseMaterial.on("apply", function (matArg) {
            var tan = Math.tan(_this.outerAngle);
            _this.Transformer.Scale = new _Vector2.default(tan * _this.outerDistance, _this.outerDistance / 2, tan * _this.outerDistance);
            diffuseMaterial.shaderVariables = {
                lightColor: _this.Color.toVector().multiplyWith(_this.intensity),
                innerAngle: _this.innerAngle,
                outerAngle: _this.outerAngle,
                innerDistance: _this.innerDistance,
                outerDistance: _this.outerDistance,
                angleDecay: _this.angleDecay,
                distanceDecay: _this.distanceDecay,
                lightPosition: _Matrix2.default.transformPoint(matArg.renderStage.renderer.camera.viewMatrix, _this.Position),
                lightDirection: _Matrix2.default.transformNormal(_Matrix2.default.multiply(matArg.renderStage.renderer.camera.viewMatrix, _this.Transformer.localToGlobal), new _Vector2.default(0, -1, 0)).normalizeThis()
            };
        });
        var specularMaterial = new _BasicMaterial2.default(require("../../../Materials/BuiltIn/Light/Specular/SpotLight.xmml"), "builtin.light.spot.specular");
        specularMaterial.on("apply", function (matArg) {
            var tan = Math.tan(_this.outerAngle);
            _this.Transformer.Scale = new _Vector2.default(tan * _this.outerDistance, _this.outerDistance / 2, tan * _this.outerDistance);
            specularMaterial.shaderVariables = {
                lightColor: _this.Color.toVector().multiplyWith(_this.intensity),
                angle: _this.outerAngle,
                dist: _this.outerDistance,
                decay: _this.distanceDecay,
                lightDirection: _Matrix2.default.transformNormal(_Matrix2.default.multiply(matArg.renderStage.renderer.camera.viewMatrix, _this.Transformer.localToGlobal), new _Vector2.default(0, -1, 0)).normalizeThis(),
                lightPosition: _Matrix2.default.transformPoint(matArg.renderStage.renderer.camera.viewMatrix, _this.Position)
            };
        });
        _this.addMaterial(diffuseMaterial);
        _this.addMaterial(specularMaterial);
        return _this;
    }

    return SpotLight;
}(_LightBase3.default);

exports.default = SpotLight;

},{"../../../../ContextComponents":8,"../../../../JThreeContext":267,"../../../../Math/Matrix":271,"../../../../Math/Vector3":278,"../../../Materials/BasicMaterial":36,"../../../Materials/BuiltIn/Light/Diffuse/SpotLight.xmml":49,"../../../Materials/BuiltIn/Light/Specular/SpotLight.xmml":52,"./../LightBase":149}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Matrix = require("../../../Math/Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

var _Color = require("../../../Math/Color3");

var _Color2 = _interopRequireDefault(_Color);

var _Vector = require("../../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _SceneObject2 = require("../SceneObject");

var _SceneObject3 = _interopRequireDefault(_SceneObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LightBase = function (_SceneObject) {
    _inherits(LightBase, _SceneObject);

    function LightBase() {
        var _Object$getPrototypeO;

        _classCallCheck(this, LightBase);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(LightBase)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this._color = new _Color2.default(0, 0, 0);
        return _this;
    }

    _createClass(LightBase, [{
        key: "Color",
        get: function get() {
            return this._color;
        },
        set: function set(col) {
            this._color = col;
        }
    }, {
        key: "Position",
        get: function get() {
            return _Matrix2.default.transformPoint(this.Transformer.localToGlobal, new _Vector2.default(0, 0, 0));
        }
    }]);

    return LightBase;
}(_SceneObject3.default);

exports.default = LightBase;

},{"../../../Math/Color3":269,"../../../Math/Matrix":271,"../../../Math/Vector3":278,"../SceneObject":151}],150:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _SceneObject2 = require("../SceneObjects/SceneObject");

var _SceneObject3 = _interopRequireDefault(_SceneObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Mesh = function (_SceneObject) {
    _inherits(Mesh, _SceneObject);

    function Mesh(geometry, mat) {
        _classCallCheck(this, Mesh);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Mesh).call(this));

        if (mat) {
            _this.addMaterial(mat);
        }
        if (geometry) {
            _this.__geometry = geometry;
        }
        return _this;
    }

    return Mesh;
}(_SceneObject3.default);

exports.default = Mesh;

},{"../SceneObjects/SceneObject":151}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectEEWithID2 = require("../../Base/JThreeObjectEEWithID");

var _JThreeObjectEEWithID3 = _interopRequireDefault(_JThreeObjectEEWithID2);

var _Transformer = require("../Transform/Transformer");

var _Transformer2 = _interopRequireDefault(_Transformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This is most base class for SceneObject.
 * SceneObject is same as GameObject in Unity.
 */

var SceneObject = function (_JThreeObjectEEWithID) {
    _inherits(SceneObject, _JThreeObjectEEWithID);

    function SceneObject(transformer) {
        _classCallCheck(this, SceneObject);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SceneObject).call(this));

        _this.shaderVariables = {};
        _this.isVisible = true;
        _this._materialChanagedHandler = [];
        _this._materials = {};
        /**
         * Contains the children.
         */
        _this._children = [];
        _this.__transformer = transformer || new _Transformer2.default(_this);
        _this.name = _this.id;
        return _this;
    }
    /**
    * Getter for children
    */


    _createClass(SceneObject, [{
        key: "addChild",

        /**
         * Add SceneObject to child of SceneObject.
         * @param {SceneObject} obj   [description]
         * @param {number}      index [description]
         */
        value: function addChild(obj, index) {
            if (index == null) {
                index = this._children.length;
            }
            this._children.splice(index, 0, obj);
            obj._parent = this;
            obj.Transformer.updateTransform();
            var eventArg = {
                owner: this,
                scene: this.ParentScene,
                isAdditionalChange: true,
                changedSceneObject: obj,
                changedSceneObjectID: obj.id
            };
            this.emit("structure-changed", eventArg);
            this.onChildrenChanged();
            obj.onParentChanged();
            if (this.ParentScene) {
                this.ParentScene.notifySceneObjectChanged(eventArg);
            }
        }
        /**
         * Remove SceneObject from children of SceneObject.
         * @param {SceneObject} obj [description]
         */

    }, {
        key: "removeChild",
        value: function removeChild(obj) {
            var childIndex = this._children.indexOf(obj);
            if (childIndex !== -1) {
                this._children.splice(childIndex, 1);
                var eventArg = {
                    owner: this,
                    scene: this.ParentScene,
                    isAdditionalChange: false,
                    changedSceneObject: obj,
                    changedSceneObjectID: obj.id
                };
                this.emit("structure-changed", eventArg);
                obj.onParentChanged();
                if (this.ParentScene) {
                    this.ParentScene.notifySceneObjectChanged(eventArg);
                }
            }
        }
        /**
         * remove this SceneObject from parent.
         */

    }, {
        key: "remove",
        value: function remove() {
            this._parent.removeChild(this);
        }
    }, {
        key: "onMaterialChanged",
        value: function onMaterialChanged(func) {
            this._materialChanagedHandler.push(func);
        }
        /**
         * すべてのマテリアルに対して処理を実行します。
         */

    }, {
        key: "eachMaterial",
        value: function eachMaterial(func) {
            for (var material in this._materials) {
                for (var matID in this._materials[material]) {
                    func(this._materials[material][matID]);
                }
            }
        }
    }, {
        key: "addMaterial",
        value: function addMaterial(mat) {
            var _this2 = this;

            if (mat.Initialized) {
                if (!this._materials[mat.MaterialGroup]) {
                    this._materials[mat.MaterialGroup] = {};
                }
                this._materials[mat.MaterialGroup][mat.id] = mat;
            } else {
                mat.once("ready", function () {
                    if (!_this2._materials[mat.MaterialGroup]) {
                        _this2._materials[mat.MaterialGroup] = {};
                    }
                    _this2._materials[mat.MaterialGroup][mat.id] = mat;
                });
            }
        }
    }, {
        key: "getMaterial",
        value: function getMaterial(matGroup) {
            if (this._materials[matGroup]) {
                var a = this._materials[matGroup];
                for (var e in a) {
                    return a[e];
                }
            }
            return null;
        }
    }, {
        key: "getMaterials",
        value: function getMaterials(matGroup) {
            if (this._materials[matGroup]) {
                var ret = [];
                for (var matID in this._materials[matGroup]) {
                    ret.push(this._materials[matGroup][matID]);
                }
                return ret;
            }
            return [];
        }
    }, {
        key: "callRecursive",
        value: function callRecursive(action) {
            if (this._children) {
                this._children.forEach(function (t) {
                    return t.callRecursive(action);
                });
            }
            action(this);
        }
    }, {
        key: "onChildrenChanged",
        value: function onChildrenChanged() {
            return;
        }
    }, {
        key: "onParentChanged",
        value: function onParentChanged() {
            return;
        }
    }, {
        key: "onParentSceneChanged",
        value: function onParentSceneChanged(sceneInfo) {
            return;
        }
    }, {
        key: "update",
        value: function update() {
            return;
        }
    }, {
        key: "Children",
        get: function get() {
            return this._children;
        }
    }, {
        key: "Parent",
        get: function get() {
            return this._parent;
        }
        /**
        * The Getter for the parent scene containing this SceneObject.
        */

    }, {
        key: "ParentScene",
        get: function get() {
            if (!this._parentScene) {
                if (!this._parent) {
                    return null;
                } else {
                    this.ParentScene = this._parent.ParentScene; // Retrieve and cache parent scene
                    return this._parentScene;
                }
            } else {
                // The parent scene was already cached.
                return this._parentScene;
            }
        }
        /**
        * The Getter for the parent scene containing this SceneObject.
        */
        ,
        set: function set(scene) {
            if (scene === this._parentScene) {
                return;
            }
            var lastScene = this._parentScene;
            this._parentScene = scene;
            // if(!this.parent||this.parent.ParentScene.ID!=scene.ID)
            //     console.error("There is something wrong in Scene structure.");
            // insert recursively to the children this SceneObject contains.
            this._children.forEach(function (v) {
                v.ParentScene = scene;
            });
            this.onParentSceneChanged({
                lastParentScene: lastScene,
                currentParentScene: this._parentScene
            });
        }
    }, {
        key: "Geometry",
        get: function get() {
            return this.__geometry;
        },
        set: function set(geo) {
            this.__geometry = geo;
        }
    }, {
        key: "Transformer",
        get: function get() {
            return this.__transformer;
        }
    }]);

    return SceneObject;
}(_JThreeObjectEEWithID3.default);

exports.default = SceneObject;

},{"../../Base/JThreeObjectEEWithID":5,"../Transform/Transformer":153}],152:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeObject2 = require("../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

var _JThreeContext = require("../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Timer = function (_JThreeObject) {
    _inherits(Timer, _JThreeObject);

    function Timer() {
        _classCallCheck(this, Timer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Timer).call(this));

        _this.currentFrame = 0;
        _this.time = 0;
        _this.timeFromLast = 0;
        _this._initializedTime = 0;
        _this._initializedTime = Date.now();
        var loopManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.LoopManager);
        loopManager.addAction(1000, function () {
            return _this.updateTimer();
        });
        return _this;
    }

    _createClass(Timer, [{
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.Timer;
        }
    }, {
        key: "updateTimer",
        value: function updateTimer() {
            this.currentFrame++;
            var currentTime = Date.now() - this._initializedTime;
            this.timeFromLast = currentTime - this.time;
            this.time = currentTime;
        }
    }]);

    return Timer;
}(_JThreeObject3.default);

exports.default = Timer;

},{"../Base/JThreeObject":3,"../ContextComponents":8,"../JThreeContext":267}],153:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _TransformerBase2 = require("./TransformerBase");

var _TransformerBase3 = _interopRequireDefault(_TransformerBase2);

var _Quaternion = require("../../Math/Quaternion");

var _Quaternion2 = _interopRequireDefault(_Quaternion);

var _Vector = require("../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _Matrix = require("../../Math/Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

var _glMatrix = require("gl-matrix");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Position,rotation and scale of scene object.
 * Every scene object in a scene has Toransformer.It's used to store and manipulate the position,rotation and scale ob the object.
 * Every Transformer can have a parent, each parent Transformer affect children's Transformer hierachically.
 */

var Transformer = function (_TransformerBase) {
    _inherits(Transformer, _TransformerBase);

    /**
     * Constructor of Transformer
     * @param sceneObj the scene object this transformer attached to.
     */

    function Transformer(sceneObj) {
        _classCallCheck(this, Transformer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Transformer).call(this, sceneObj));

        _this.hasChanged = false;
        /**
         * forward direction of transform in world space
         */
        _this.forward = _Vector2.default.ZUnit.negateThis();
        /**
        * up direction of transform in world space
        */
        _this.up = _Vector2.default.YUnit;
        /**
        * right direction of transform in world space
        */
        _this.right = _Vector2.default.XUnit;
        _this._modelViewProjectionCaluculationCache = _glMatrix.mat4.create();
        _this._g2lupdated = false;
        _this._position = _Vector2.default.Zero;
        _this._rotation = _Quaternion2.default.Identity;
        _this._scale = new _Vector2.default(1, 1, 1);
        _this._localOrigin = new _Vector2.default(0, 0, 0);
        _this.updateTransform();
        return _this;
    }
    /**
     * update all transform
     * You no need to call this method manually if you access all of properties in this transformer by accessor.
     */


    _createClass(Transformer, [{
        key: "updateTransform",
        value: function updateTransform() {
            this.hasChanged = true;
            this.__updateTransformMatricies();
            // notify update to childrens
            if (this.object.Children) {
                this.object.Children.forEach(function (v) {
                    v.Transformer.updateTransform();
                });
            }
            this._g2lupdated = false;
            // fire updated event
            this.emit("transform", this);
        }
    }, {
        key: "calculateMVPMatrix",

        /**
         * Calculate Projection-View-Model matrix with renderer camera.
         */
        value: function calculateMVPMatrix(renderer) {
            _glMatrix.mat4.mul(this._modelViewProjectionCaluculationCache, renderer.camera.viewMatrix.rawElements, this.localToGlobal.rawElements);
            _glMatrix.mat4.mul(this._modelViewProjectionCaluculationCache, renderer.camera.projectionMatrix.rawElements, this._modelViewProjectionCaluculationCache);
            return new _Matrix2.default(this._modelViewProjectionCaluculationCache);
        }
    }, {
        key: "__updateTransformMatricies",

        /**
        * Update transform matricies
        * @return {[type]} [description]
        */
        value: function __updateTransformMatricies() {
            // initialize localTransformCache & localToGlobalMatrix.rawElements
            _glMatrix.mat4.identity(this.localTransform.rawElements);
            _glMatrix.mat4.identity(this.localToGlobal.rawElements);
            // generate local transofrm matrix
            _glMatrix.mat4.fromRotationTranslationScaleOrigin(this.localTransform.rawElements, this._rotation.rawElements, this._position.rawElements, this._scale.rawElements, this._localOrigin.rawElements); // substitute Rotation*Translation*Scale matrix (around local origin) for localTransformMatrix.rawElements
            if (this.object != null && this.object.Parent != null) {
                // Use localToGlobal matrix of parents to multiply with localTransformCache
                _glMatrix.mat4.copy(this.localToGlobal.rawElements, this.object.Parent.Transformer.localToGlobal.rawElements);
            } else {
                // If this transformer have no parent transformer,localToGlobalMatrix.rawElements,GlobalTransform will be same as localTransformCache
                _glMatrix.mat4.identity(this.localToGlobal.rawElements);
            }
            // Multiply parent transform
            _glMatrix.mat4.multiply(this.localToGlobal.rawElements, this.localToGlobal.rawElements, this.localTransform.rawElements);
            this.__updateDirections();
        }
        /**
         * Update directions by this transform
         */

    }, {
        key: "__updateDirections",
        value: function __updateDirections() {
            // Calculate direction vectors
            this._updateDirection(this.right, [1, 0, 0, 0]); // need to reduce memory allocation
            this._updateDirection(this.up, [0, 1, 0, 0]);
            this._updateDirection(this.forward, [0, 0, -1, 0]);
        }
    }, {
        key: "_updateDirection",
        value: function _updateDirection(rawElements, sourceVector4) {
            _glMatrix.vec4.transformMat4(rawElements.rawElements, sourceVector4, this.localToGlobal.rawElements);
            _glMatrix.vec3.normalize(rawElements.rawElements, rawElements.rawElements);
        }
    }, {
        key: "hasParent",
        get: function get() {
            return !!this.object.Parent;
        }
    }, {
        key: "parent",
        get: function get() {
            return this.hasParent ? this.object.Parent.Transformer : null;
        }
    }, {
        key: "childrenCount",
        get: function get() {
            return this.object.Children.length;
        }
    }, {
        key: "GlobalPosition",
        get: function get() {
            return _Matrix2.default.transformPoint(this.localToGlobal, _Vector2.default.Zero);
        }
        /**
         * Get accessor for model rotation.
         */

    }, {
        key: "Rotation",
        get: function get() {
            return this._rotation;
        }
        /**
         * Set accessor for model rotation.
         */
        ,
        set: function set(quat) {
            this._rotation = quat;
            this.updateTransform();
        }
        /**
         * Get Accessor for model position.
         */

    }, {
        key: "Position",
        get: function get() {
            return this._position;
        }
        /**
         * Set Accessor for model position.
         */
        ,
        set: function set(vec) {
            this._position = vec;
            this.updateTransform();
        }
        /**
         * Get Accessor for model scale.
         */

    }, {
        key: "Scale",
        get: function get() {
            return this._scale;
        }
        /**
         * Set Accessor for model scale.
         */
        ,
        set: function set(vec) {
            this._scale = vec;
            this.updateTransform();
        }
    }, {
        key: "LocalOrigin",
        get: function get() {
            return this._localOrigin;
        },
        set: function set(origin) {
            this._localOrigin = origin;
            this.updateTransform();
        }
    }]);

    return Transformer;
}(_TransformerBase3.default);

exports.default = Transformer;

},{"../../Math/Matrix":271,"../../Math/Quaternion":275,"../../Math/Vector3":278,"./TransformerBase":154,"gl-matrix":320}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Matrix = require("../../Math/Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

var _JThreeObjectEE2 = require("../../Base/JThreeObjectEE");

var _JThreeObjectEE3 = _interopRequireDefault(_JThreeObjectEE2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BaseTransformer = function (_JThreeObjectEE) {
    _inherits(BaseTransformer, _JThreeObjectEE);

    function BaseTransformer(sceneObject) {
        _classCallCheck(this, BaseTransformer);

        /**
         * calculation cache
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BaseTransformer).call(this));

        _this.localTransform = _Matrix2.default.identity();
        _this.localToGlobal = _Matrix2.default.identity();
        _this.object = sceneObject;
        return _this;
    }

    _createClass(BaseTransformer, [{
        key: "transformDirection",
        value: function transformDirection(direction) {
            return _Matrix2.default.transformNormal(this.localToGlobal, direction);
        }
    }, {
        key: "transformPoint",
        value: function transformPoint(point) {
            return _Matrix2.default.transformPoint(this.localToGlobal, point);
        }
    }, {
        key: "transformVector",
        value: function transformVector(vector) {
            return _Matrix2.default.transform(this.localToGlobal, vector);
        }
    }]);

    return BaseTransformer;
}(_JThreeObjectEE3.default);

exports.default = BaseTransformer;

},{"../../Base/JThreeObjectEE":4,"../../Math/Matrix":271}],155:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _SceneStructureDebugger = require("./Modules/SceneStructureDebugger");

var _SceneStructureDebugger2 = _interopRequireDefault(_SceneStructureDebugger);

var _RendererDebugger = require("./Modules/RendererDebugger");

var _RendererDebugger2 = _interopRequireDefault(_RendererDebugger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Debugger = function () {
    function Debugger() {
        _classCallCheck(this, Debugger);

        this._debuggerModules = [new _SceneStructureDebugger2.default(), new _RendererDebugger2.default()];
        this.debuggerAPI = window.j3d;
        if (!this.debuggerAPI) {
            console.warn("Debugger API was not found! Did you surely import j3d.js?\nDebugger will not be attached.");
        }
    }

    _createClass(Debugger, [{
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.Debugger;
        }
    }, {
        key: "attach",
        value: function attach() {
            var _this = this;

            if (this.debuggerAPI) {
                this._debuggerModules.forEach(function (m) {
                    return m.attach(_this);
                });
                console.info("Debugger API was attached.");
            }
            ;
        }
    }, {
        key: "setInfo",
        value: function setInfo(key, val) {
            if (!this.debuggerAPI) {
                return;
            }
            if ((typeof val === "undefined" ? "undefined" : _typeof(val)) === "object") {
                var stringfied = "";
                for (var k in val) {
                    var v = val[k];
                    stringfied += k + ":" + v + "<br/>";
                }
                val = stringfied;
            }
            this.debuggerAPI.info.setInfo(key, val);
        }
    }]);

    return Debugger;
}();

exports.default = Debugger;

},{"../ContextComponents":8,"./Modules/RendererDebugger":157,"./Modules/SceneStructureDebugger":158}],156:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DebuggerModuleBase = function () {
    function DebuggerModuleBase() {
        _classCallCheck(this, DebuggerModuleBase);
    }

    _createClass(DebuggerModuleBase, [{
        key: "attach",
        value: function attach(debug) {
            return;
        }
    }]);

    return DebuggerModuleBase;
}();

exports.default = DebuggerModuleBase;

},{}],157:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BasicRenderer = require("../../Core/Renderers/BasicRenderer");

var _BasicRenderer2 = _interopRequireDefault(_BasicRenderer);

var _DebuggerModuleBase2 = require("./DebuggerModuleBase");

var _DebuggerModuleBase3 = _interopRequireDefault(_DebuggerModuleBase2);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RendererDebugger = function (_DebuggerModuleBase) {
    _inherits(RendererDebugger, _DebuggerModuleBase);

    function RendererDebugger() {
        _classCallCheck(this, RendererDebugger);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(RendererDebugger).apply(this, arguments));
    }

    _createClass(RendererDebugger, [{
        key: "attach",
        value: function attach(debug) {
            var _this2 = this;

            var sm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.SceneManager);
            sm.Scenes.forEach(function (s) {
                _this2._attachToScene(s, debug);
            });
            sm.on("change", function (h) {
                if (h.isAdditionalChange) {
                    _this2._attachToScene(h.changedScene, debug);
                } else {}
            });
        }
    }, {
        key: "getShadowMapImage",
        value: function getShadowMapImage(rendererID, generator) {
            var d = _q2.default.defer();
            this._shadowMapRequest = {
                deffered: d,
                rendererID: rendererID,
                generator: generator
            };
            return d.promise;
        }
    }, {
        key: "getShadowMapProgressImage",
        value: function getShadowMapProgressImage(rendererID, generator) {
            var d = _q2.default.defer();
            this._shadowMapProgressRequest = {
                deffered: d,
                rendererID: rendererID,
                generator: generator,
                begin: false
            };
            return d.promise;
        }
    }, {
        key: "getTextureHtmlImage",
        value: function getTextureHtmlImage(stageID, bufferTextureID, generator) {
            var d = _q2.default.defer();
            this._bufferTextureRequest = {
                deffered: d,
                stageID: stageID,
                bufferTextureID: bufferTextureID,
                generator: generator
            };
            return d.promise;
        }
    }, {
        key: "getTextureProgressHtmlImage",
        value: function getTextureProgressHtmlImage(stageID, bufferTextureID, generator) {
            var d = _q2.default.defer();
            this._bufferTextureProgressRequest = {
                deffered: d,
                stageID: stageID,
                bufferTextureID: bufferTextureID,
                generator: generator,
                begin: false
            };
            return d.promise;
        }
    }, {
        key: "_attachToScene",
        value: function _attachToScene(scene, debug) {
            var _this3 = this;

            scene.Renderers.forEach(function (r) {
                _this3._attachToRenderer(r, debug);
            });
            scene.on("changed-renderer", function (h) {
                if (h.isAdditionalChange) {
                    _this3._attachToRenderer(h.renderer, debug);
                } else {}
            });
        }
    }, {
        key: "_canvasToimg",
        value: function _canvasToimg(renderer) {
            ;
            var img = new Image(renderer.canvasElement.width, renderer.canvasElement.height);
            img.src = renderer.canvasElement.toDataURL();
            return img;
        }
    }, {
        key: "_attachToRenderer",
        value: function _attachToRenderer(renderer, debug) {
            var _this4 = this;

            debug.debuggerAPI.renderers.addRenderer(renderer, this);
            renderer.on("rendered-stage", function (v) {
                if (_this4._bufferTextureRequest && v.completedChain.stage.id === _this4._bufferTextureRequest.stageID) {
                    if (v.bufferTextures[_this4._bufferTextureRequest.bufferTextureID] == null && renderer instanceof _BasicRenderer2.default) {
                        _this4._bufferTextureRequest.deffered.resolve(_this4._canvasToimg(renderer));
                        _this4._bufferTextureRequest = null;
                        return;
                    }
                    _this4._bufferTextureRequest.deffered.resolve(v.bufferTextures[_this4._bufferTextureRequest.bufferTextureID].wrappers[0].generateHtmlImage(_this4._bufferTextureRequest.generator));
                    _this4._bufferTextureRequest = null;
                }
            });
            renderer.on("rendered-path", function (v) {
                if (_this4._shadowMapRequest && renderer.id === _this4._shadowMapRequest.rendererID) {
                    // this.shadowMapRequest.deffered.resolve(v.scene.LightRegister.shadowMapResourceManager.shadowMapTileTexture.wrappers[0].generateHtmlImage(this.shadowMapRequest.generator));
                    _this4._shadowMapRequest = null;
                }
                if (_this4._bufferTextureProgressRequest && _this4._bufferTextureProgressRequest.begin) {
                    _this4._bufferTextureProgressRequest.deffered.resolve(null);
                    _this4._bufferTextureProgressRequest = null;
                }
                if (_this4._shadowMapProgressRequest && _this4._shadowMapProgressRequest.begin) {
                    _this4._shadowMapProgressRequest.deffered.resolve(null);
                    _this4._shadowMapProgressRequest = null;
                }
            });
            renderer.on("rendered-object", function (v) {
                var img = undefined;
                if (_this4._bufferTextureProgressRequest && v.stage.id === _this4._bufferTextureProgressRequest.stageID) {
                    _this4._bufferTextureProgressRequest.begin = true;
                    renderer.gl.flush();
                    if (v.bufferTextures[_this4._bufferTextureProgressRequest.bufferTextureID] == null) {
                        // for default buffer
                        if (renderer instanceof _BasicRenderer2.default) {
                            img = _this4._canvasToimg(renderer);
                        }
                    } else {
                        img = v.bufferTextures[_this4._bufferTextureProgressRequest.bufferTextureID].wrappers[0].generateHtmlImage(_this4._bufferTextureProgressRequest.generator);
                    }
                    img.title = "object:" + v.renderedObject.name + " technique:" + v.technique;
                    _this4._bufferTextureProgressRequest.deffered.notify({
                        image: img,
                        object: v.renderedObject,
                        technique: v.technique
                    });
                }
                if (_this4._shadowMapProgressRequest && v.stage.getTypeName() === "ShadowMapGenerationStage" && v.stage.Renderer.id === _this4._shadowMapProgressRequest.rendererID) {
                    _this4._shadowMapProgressRequest.begin = true;
                    renderer.gl.flush();
                    img = undefined; // v.renderedObject.ParentScene.LightRegister.shadowMapResourceManager.shadowMapTileTexture.wrappers[0].generateHtmlImage(this.shadowMapProgressRequest.generator);
                    img.title = "object:" + v.renderedObject.name + " technique:" + v.technique;
                    _this4._shadowMapProgressRequest.deffered.notify({
                        image: img,
                        object: v.renderedObject,
                        technique: v.technique
                    });
                }
            });
        }
    }]);

    return RendererDebugger;
}(_DebuggerModuleBase3.default);

exports.default = RendererDebugger;

},{"../../ContextComponents":8,"../../Core/Renderers/BasicRenderer":81,"../../JThreeContext":267,"./DebuggerModuleBase":156,"q":338}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DebuggerModuleBase2 = require("./DebuggerModuleBase");

var _DebuggerModuleBase3 = _interopRequireDefault(_DebuggerModuleBase2);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SceneStructureDebugger = function (_DebuggerModuleBase) {
    _inherits(SceneStructureDebugger, _DebuggerModuleBase);

    function SceneStructureDebugger() {
        _classCallCheck(this, SceneStructureDebugger);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SceneStructureDebugger).apply(this, arguments));
    }

    _createClass(SceneStructureDebugger, [{
        key: "attach",
        value: function attach(debug) {
            _JThreeContext2.default.getContextComponent(_ContextComponents2.default.SceneManager).on("change", function (v) {
                if (v.isAdditionalChange) {
                    // If scene was added
                    v.changedScene.on("structure-changed", function () {
                        debug.debuggerAPI.scenes.setScene(v.changedScene.ID, v.changedScene);
                    });
                } else {}
            });
        }
    }]);

    return SceneStructureDebugger;
}(_DebuggerModuleBase3.default);

exports.default = SceneStructureDebugger;

},{"../../ContextComponents":8,"../../JThreeContext":267,"./DebuggerModuleBase":156}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebGLNotSupportedException = exports.AbstractClassMethodCalledException = exports.SingularMatrixException = exports.InvalidStringException = exports.InvalidArgumentException = exports.JThreeException = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _JThreeObject2 = require("./Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* This class is root class perform as exception arguments in jThree.
*/

var JThreeException = exports.JThreeException = function (_JThreeObject) {
    _inherits(JThreeException, _JThreeObject);

    function JThreeException(name, message) {
        _classCallCheck(this, JThreeException);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(JThreeException).call(this));

        _this.name = name;
        _this.message = message;
        return _this;
    }

    _createClass(JThreeException, [{
        key: "toString",
        value: function toString() {
            return "Exception:" + _get(Object.getPrototypeOf(JThreeException.prototype), "toString", this).call(this) + "\nName:" + this.name + "\nMessage:" + this.message;
        }
    }]);

    return JThreeException;
}(_JThreeObject3.default);

var InvalidArgumentException = exports.InvalidArgumentException = function (_JThreeException) {
    _inherits(InvalidArgumentException, _JThreeException);

    function InvalidArgumentException(message) {
        _classCallCheck(this, InvalidArgumentException);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(InvalidArgumentException).call(this, "Invalid argument was passed.", message));
    }

    return InvalidArgumentException;
}(JThreeException);

var InvalidStringException = exports.InvalidStringException = function (_JThreeException2) {
    _inherits(InvalidStringException, _JThreeException2);

    function InvalidStringException(message) {
        _classCallCheck(this, InvalidStringException);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(InvalidStringException).call(this, "Invalid string was passed.", message));
    }

    return InvalidStringException;
}(JThreeException);

var SingularMatrixException = exports.SingularMatrixException = function (_JThreeException3) {
    _inherits(SingularMatrixException, _JThreeException3);

    function SingularMatrixException(m) {
        _classCallCheck(this, SingularMatrixException);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SingularMatrixException).call(this, "Passed matrix is singular matrix", "passed matrix:" + m.toString()));
    }

    return SingularMatrixException;
}(JThreeException);

var AbstractClassMethodCalledException = exports.AbstractClassMethodCalledException = function (_JThreeException4) {
    _inherits(AbstractClassMethodCalledException, _JThreeException4);

    function AbstractClassMethodCalledException() {
        _classCallCheck(this, AbstractClassMethodCalledException);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(AbstractClassMethodCalledException).call(this, "Invalid method was called.", "This method is abstract method, cant call by this instance"));
    }

    return AbstractClassMethodCalledException;
}(JThreeException);

var WebGLNotSupportedException = exports.WebGLNotSupportedException = function (_JThreeException5) {
    _inherits(WebGLNotSupportedException, _JThreeException5);

    function WebGLNotSupportedException() {
        _classCallCheck(this, WebGLNotSupportedException);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(WebGLNotSupportedException).call(this, "WebGL is not supported", "This browser is not supporting WebGL. Context generation for WebGL was failed."));
    }

    return WebGLNotSupportedException;
}(JThreeException);

},{"./Base/JThreeObject":3}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject2 = require("../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

var _GomlAttribute = require("./GomlAttribute");

var _GomlAttribute2 = _interopRequireDefault(_GomlAttribute);

var _lodash = require("lodash.isundefined");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The class managing attributes of a node.
 */

var AttributeDictionary = function (_JThreeObject) {
    _inherits(AttributeDictionary, _JThreeObject);

    /**
     * @param {node} the node this attribute dictionary has.
     */

    function AttributeDictionary(node) {
        _classCallCheck(this, AttributeDictionary);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AttributeDictionary).call(this));

        _this._attributes = {};
        _this._node = node;
        return _this;
    }

    _createClass(AttributeDictionary, [{
        key: "forEachAttr",
        value: function forEachAttr(callbackfn) {
            var _this2 = this;

            Object.keys(this._attributes).forEach(function (k) {
                var v = _this2._attributes[k];
                callbackfn(v, k, _this2._attributes);
            }, this);
            return this;
        }
    }, {
        key: "getValue",
        value: function getValue(attrName) {
            var attr = this._attributes[attrName];
            if (attr === undefined) {
                console.warn("attribute \"" + attrName + "\" is not found.");
            } else {
                return attr.Value;
            }
        }
    }, {
        key: "getValueStr",
        value: function getValueStr(attrName) {
            var attr = this._attributes[attrName];
            if (attr === undefined) {
                console.warn("attribute \"" + attrName + "\" is not found.");
            } else {
                return attr.ValueStr;
            }
        }
    }, {
        key: "setValue",
        value: function setValue(attrName, value) {
            var attr = this._attributes[attrName];
            if (attr === undefined) {
                console.warn("attribute \"" + attrName + "\" is not found.");
            } else {
                if (attr.constant) {
                    console.error("attribute: " + attrName + " is constant attribute");
                    return;
                }
                attr.Value = value;
            }
        }
    }, {
        key: "setValueStr",
        value: function setValueStr(attrName, value) {
            this.setValue(attrName, value);
        }
    }, {
        key: "getAttribute",
        value: function getAttribute(attrName) {
            return this._attributes[attrName];
        }
    }, {
        key: "getAllAttributes",
        value: function getAllAttributes() {
            return this._attributes;
        }
        /**
         * Check the attribute passed is defined or not.
         */

    }, {
        key: "isDefined",
        value: function isDefined(attrName) {
            return this._attributes[attrName] !== undefined;
        }
        /**
         * Define attributes to the node.
         *
         * This method must not be called outside of Node classes.
         * If you define already defined attribute, it will be replaced.
         */

    }, {
        key: "defineAttribute",
        value: function defineAttribute(attributes) {
            // console.log("attributes_declaration", attributes);
            for (var key in attributes) {
                var attribute = attributes[key];
                var converter = this._node.nodeManager.configurator.getConverter(attribute.converter);
                if (!converter && (!attribute.reserved || !(0, _lodash2.default)(attribute.converter))) {
                    throw new Error("Converter \"" + attribute.converter + "\" is not found");
                }
                var existed_attribute = this.getAttribute(key);
                var gomlAttribute = null;
                if (existed_attribute && existed_attribute.reserved) {
                    // console.log("define_attribute(override)", key, attribute, this.node.getTypeName());
                    gomlAttribute = existed_attribute;
                    gomlAttribute.Converter = converter;
                    gomlAttribute.constant = attribute.constant;
                    gomlAttribute.Value = gomlAttribute.ValueStr;
                    gomlAttribute.reserved = false;
                    gomlAttribute.on("changed", attribute.onchanged.bind(this._node));
                } else {
                    gomlAttribute = new _GomlAttribute2.default(key, attribute.value, converter, attribute.reserved, attribute.constant);
                    if (attribute.reserved) {} else {
                        // console.log("define_attribute", key, attribute, this.node.getTypeName());
                        if (attribute.onchanged) {
                            gomlAttribute.on("changed", attribute.onchanged.bind(this._node));
                        } else {
                            console.warn("attribute \"" + key + "\" does not have onchange event handler. this causes lack of attribute's consistency.");
                        }
                    }
                    this._attributes[key] = gomlAttribute;
                }
                if (this._node.Mounted && !gomlAttribute.reserved) {
                    gomlAttribute.notifyValueChanged();
                }
            }
        }
        /**
         * Reserve attribute for define.
         *
         * This method could be called from outside of Node classes.
         */

    }, {
        key: "reserveAttribute",
        value: function reserveAttribute(name, value) {
            var attribute = _defineProperty({}, name, { value: value, reserved: true });
            this.defineAttribute(attribute);
            return this.getAttribute(name);
        }
        /**
         * Emit change events to all attributes
         */

    }, {
        key: "emitChangeAll",
        value: function emitChangeAll() {
            var _this3 = this;

            Object.keys(this._attributes).forEach(function (k) {
                var v = _this3._attributes[k];
                if (typeof v.Value !== "undefined") {
                    v.notifyValueChanged();
                }
            });
        }
    }, {
        key: "updateValue",
        value: function updateValue(attrName) {
            var _this4 = this;

            if (typeof attrName === "undefined") {
                Object.keys(this._attributes).forEach(function (k) {
                    var v = _this4._attributes[k];
                    v.notifyValueChanged();
                });
            } else {
                var target = this._attributes[attrName];
                target.notifyValueChanged();
            }
        }
    }]);

    return AttributeDictionary;
}(_JThreeObject3.default);

exports.default = AttributeDictionary;

},{"../Base/JThreeObject":3,"./GomlAttribute":175,"lodash.isundefined":336}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject = require("../Base/JThreeObject");

var _JThreeObject2 = _interopRequireDefault(_JThreeObject);

var _Quaternion = require("../Math/Quaternion");

var _Quaternion2 = _interopRequireDefault(_Quaternion);

var _Vector = require("../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Utility class to parse the arguments of attributes.
 */

var AttributeParser = function (_jThreeObject) {
    _inherits(AttributeParser, _jThreeObject);

    function AttributeParser() {
        _classCallCheck(this, AttributeParser);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(AttributeParser).apply(this, arguments));
    }

    _createClass(AttributeParser, null, [{
        key: "parseAngle",

        /**
         * Parse angle strings.
         * "p" means Pi. Ex) 3/4 p
         * "d" means degree. if this unit was specified, the argument will be parsed as degree. Ex) 90d
         * @param input the string to parse.
         * @returns {number} parsed angle in radians.
         */
        value: function parseAngle(input) {
            var regex = /^ *(-? *(?:0|[1-9]\d*)(?: *\.\d+)?) *(?:\/ *((?:0|[1-9]\d*)(?: *\.\d+)?))? *(p|prad|deg|d|r|rad)? *$/gm;
            var result = regex.exec(input);
            if (result == null) {
                throw new Error("faild parse Angle string:'" + input + "'");
            }
            var numerator = parseFloat(result[1]);
            if (result[2]) {
                numerator /= parseFloat(result[2]);
            }
            var unit = result[3];
            if (unit == null) {
                unit = "d";
            }
            if (unit === "r" || unit === "rad") {
                return numerator;
            }
            if (unit === "p" || unit === "prad") {
                return numerator * Math.PI;
            }
            return numerator / 180 * Math.PI;
        }
        /**
         * Parse angle string in 3D.
         * "p" means Pi. Ex) 3/4 p
         * "d" means degree. if this unit was specified, the argument will be parsed as degree. Ex) 90d
         * "eular(x,y,z)" means rotation in eular. This means Z-X-Y rotation like Unity.
         * "axis(angle,x,y,z)" means rotation around specified axis. This means angle radians will be rotated around the axis (x,y,z).
         * This angle can be specified with the character "p" or "d".
         * "x(angle)","y(angle)" or "z(angle)" means rotation around unit axis.
         * This angle can be specified with the character "p" or "d".
         * @param input the string to be parsed as angle in 3D.
         * @returns {Quaternion} parsed rotation in Quaternion.
         */

    }, {
        key: "parseRotation3D",
        value: function parseRotation3D(input) {
            var reg1 = /^ *(x|y|z) *\(([^\(\)]+)\) *$/gm;
            var reg2 = /^ *axis *\(([^\(\),]+),([^\(\),]+),([^\(\),]+),([^\(\),]+)\) *$/gm;
            var reg3 = /^ *([^\(\),]+),([^\(\),]+),([^\(\),]+) *$/gm;
            var result = reg1.exec(input);
            if (result) {
                if (result[1] === "x") {
                    return _Quaternion2.default.angleAxis(AttributeParser.parseAngle(result[2]), _Vector2.default.XUnit);
                }
                if (result[1] === "y") {
                    return _Quaternion2.default.angleAxis(AttributeParser.parseAngle(result[2]), _Vector2.default.YUnit);
                }
                if (result[1] === "z") {
                    return _Quaternion2.default.angleAxis(AttributeParser.parseAngle(result[2]), _Vector2.default.ZUnit);
                }
            }
            var res2 = reg2.exec(input);
            if (res2) {
                var rotation = AttributeParser.parseAngle(res2[1]);
                var x = parseFloat(res2[2]);
                var y = parseFloat(res2[3]);
                var z = parseFloat(res2[4]);
                return _Quaternion2.default.angleAxis(rotation, new _Vector2.default(x, y, z));
            }
            var res3 = reg3.exec(input);
            if (res3) {
                return _Quaternion2.default.euler(AttributeParser.parseAngle(res3[1]), AttributeParser.parseAngle(res3[2]), AttributeParser.parseAngle(res3[3]));
            }
            throw new Error("Unknown format for rotation3D:'" + input + "'");
        }
    }]);

    return AttributeParser;
}(_JThreeObject2.default);

exports.default = AttributeParser;

},{"../Base/JThreeObject":3,"../Math/Quaternion":275,"../Math/Vector3":278}],162:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject = require("../Base/JThreeObject");

var _JThreeObject2 = _interopRequireDefault(_JThreeObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AttributePromiseRegistry = function (_jThreeObject) {
    _inherits(AttributePromiseRegistry, _jThreeObject);

    function AttributePromiseRegistry() {
        _classCallCheck(this, AttributePromiseRegistry);

        /**
         * If true, async syncing is now available.
         * @type {boolean}
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AttributePromiseRegistry).call(this));

        _this.enabled = false;
        /**
         * promise objects which is registed.
         */
        _this._promises = [];
        /**
         * this flag is true when async method is called.
         * @type {boolean}
         */
        _this._asyncing = false;
        /**
         * all expected arguments object of all promises.
         * @type {GomlAttribute[]}
         */
        _this._asyncObjects = [];
        /**
         * callback function which is called when all promise objects are resolved.
         * @type {[type]}
         */
        _this._allOfCallbackfn = null;
        return _this;
    }
    /**
     * register promise object and expected callback arguments object when promise is resolved.
     * @param {Q.Promise<GomlAttribute>} promise        [description]
     * @param {GomlAttribute}            callbackObject [description]
     */


    _createClass(AttributePromiseRegistry, [{
        key: "register",
        value: function register(promise, callbackObject) {
            var _this2 = this;

            this._promises.push(promise);
            this._asyncObjects.push(callbackObject);
            if (this._asyncing) {
                promise.then(function (ga) {
                    _this2._thenCallbackfn(ga);
                });
            }
        }
        /**
         * sync all registered promises.
         * @param {() => void} callbackfn [description]
         */

    }, {
        key: "async",
        value: function async(callbackfn) {
            var _this3 = this;

            this._asyncing = true;
            this._allOfCallbackfn = callbackfn;
            this._promises.forEach(function (p) {
                p.then(function (ga) {
                    _this3._thenCallbackfn(ga);
                });
            });
        }
        /**
         * clear all async sequence.
         */

    }, {
        key: "clear",
        value: function clear() {
            this._asyncing = false;
            this._promises = [];
            this._asyncObjects = [];
            this._allOfCallbackfn = null;
        }
        /**
         * [_thenCallbackfn description]
         * @param {GomlAttribute} ga [description]
         */

    }, {
        key: "_thenCallbackfn",
        value: function _thenCallbackfn(ga) {
            var index = this._asyncObjects.indexOf(ga);
            if (index !== -1) {
                this._asyncObjects.splice(index, 1);
            } else {
                throw Error("registered object does not equal to callback object");
            }
            console.log(this._asyncObjects);
            if (this._asyncObjects.length === 0) {
                this._allOfCallbackfn();
                this.clear();
            }
        }
    }]);

    return AttributePromiseRegistry;
}(_JThreeObject2.default);

exports.default = AttributePromiseRegistry;

},{"../Base/JThreeObject":3}],163:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AttributeParser = require("../AttributeParser");

var _AttributeParser2 = _interopRequireDefault(_AttributeParser);

var _AttributeConverterBase = require("./AttributeConverterBase");

var _AttributeConverterBase2 = _interopRequireDefault(_AttributeConverterBase);

var _lodash = require("lodash.isnumber");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AngleAttributeConverter = function (_AttributeConverterBa) {
    _inherits(AngleAttributeConverter, _AttributeConverterBa);

    function AngleAttributeConverter() {
        var _Object$getPrototypeO;

        _classCallCheck(this, AngleAttributeConverter);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(AngleAttributeConverter)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.name = "angle";
        return _this;
    }

    _createClass(AngleAttributeConverter, [{
        key: "toStringAttr",
        value: function toStringAttr(val) {
            return val.toString();
        }
    }, {
        key: "toObjectAttr",
        value: function toObjectAttr(attr) {
            return (0, _lodash2.default)(attr) ? attr : _AttributeParser2.default.parseAngle(attr);
        }
    }]);

    return AngleAttributeConverter;
}(_AttributeConverterBase2.default);

exports.default = AngleAttributeConverter;

},{"../AttributeParser":161,"./AttributeConverterBase":164,"lodash.isnumber":333}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _JThreeObject2 = require("../../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AttributeConverterBase = function (_JThreeObject) {
    _inherits(AttributeConverterBase, _JThreeObject);

    function AttributeConverterBase() {
        var _Object$getPrototypeO;

        _classCallCheck(this, AttributeConverterBase);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(AttributeConverterBase)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.name = null;
        return _this;
    }

    return AttributeConverterBase;
}(_JThreeObject3.default);

exports.default = AttributeConverterBase;

},{"../../Base/JThreeObject":3}],165:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AttributeConverterBase = require("./AttributeConverterBase");

var _AttributeConverterBase2 = _interopRequireDefault(_AttributeConverterBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BooleanAttributeConverter = function (_AttributeConverterBa) {
    _inherits(BooleanAttributeConverter, _AttributeConverterBa);

    function BooleanAttributeConverter() {
        var _Object$getPrototypeO;

        _classCallCheck(this, BooleanAttributeConverter);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(BooleanAttributeConverter)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.name = "boolean";
        return _this;
    }

    _createClass(BooleanAttributeConverter, [{
        key: "toStringAttr",
        value: function toStringAttr(val) {
            return val.toString();
        }
    }, {
        key: "toObjectAttr",
        value: function toObjectAttr(attr) {
            return attr === true || attr === false ? attr : attr === "true";
        }
    }]);

    return BooleanAttributeConverter;
}(_AttributeConverterBase2.default);

exports.default = BooleanAttributeConverter;

},{"./AttributeConverterBase":164}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AttributeConverterBase = require("./AttributeConverterBase");

var _AttributeConverterBase2 = _interopRequireDefault(_AttributeConverterBase);

var _Color = require("../../Math/Color3");

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Color3AttributeConverter = function (_AttributeConverterBa) {
    _inherits(Color3AttributeConverter, _AttributeConverterBa);

    function Color3AttributeConverter() {
        var _Object$getPrototypeO;

        _classCallCheck(this, Color3AttributeConverter);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Color3AttributeConverter)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.name = "color3";
        return _this;
    }

    _createClass(Color3AttributeConverter, [{
        key: "toStringAttr",
        value: function toStringAttr(val) {
            return val.toString();
        }
    }, {
        key: "toObjectAttr",
        value: function toObjectAttr(attr) {
            return attr instanceof _Color2.default ? attr : _Color2.default.parse(attr);
        }
    }]);

    return Color3AttributeConverter;
}(_AttributeConverterBase2.default);

exports.default = Color3AttributeConverter;

},{"../../Math/Color3":269,"./AttributeConverterBase":164}],167:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AttributeConverterBase = require("./AttributeConverterBase");

var _AttributeConverterBase2 = _interopRequireDefault(_AttributeConverterBase);

var _Color = require("../../Math/Color4");

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Color4AttributeConverter = function (_AttributeConverterBa) {
    _inherits(Color4AttributeConverter, _AttributeConverterBa);

    function Color4AttributeConverter() {
        var _Object$getPrototypeO;

        _classCallCheck(this, Color4AttributeConverter);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Color4AttributeConverter)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.name = "color4";
        return _this;
    }

    _createClass(Color4AttributeConverter, [{
        key: "toStringAttr",
        value: function toStringAttr(val) {
            return val.toString();
        }
    }, {
        key: "toObjectAttr",
        value: function toObjectAttr(attr) {
            return attr instanceof _Color2.default ? attr : _Color2.default.parse(attr);
        }
    }]);

    return Color4AttributeConverter;
}(_AttributeConverterBase2.default);

exports.default = Color4AttributeConverter;

},{"../../Math/Color4":270,"./AttributeConverterBase":164}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AttributeConverterBase = require("./AttributeConverterBase");

var _AttributeConverterBase2 = _interopRequireDefault(_AttributeConverterBase);

var _lodash = require("lodash.isfunction");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FunctionAttributeConverter = function (_AttributeConverterBa) {
    _inherits(FunctionAttributeConverter, _AttributeConverterBa);

    function FunctionAttributeConverter() {
        var _Object$getPrototypeO;

        _classCallCheck(this, FunctionAttributeConverter);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(FunctionAttributeConverter)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.name = "function";
        return _this;
    }

    _createClass(FunctionAttributeConverter, [{
        key: "toStringAttr",
        value: function toStringAttr(val) {
            return val.toString().match(/function\sanonymous\(\)\s\{\n([\s\S]+)\n\}/m)[1];
        }
    }, {
        key: "toObjectAttr",
        value: function toObjectAttr(attr) {
            return (0, _lodash2.default)(attr) ? attr : new Function(attr);
        }
    }]);

    return FunctionAttributeConverter;
}(_AttributeConverterBase2.default);

exports.default = FunctionAttributeConverter;

},{"./AttributeConverterBase":164,"lodash.isfunction":332}],169:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AttributeConverterBase = require("./AttributeConverterBase");

var _AttributeConverterBase2 = _interopRequireDefault(_AttributeConverterBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IntegerAttributeConverter = function (_AttributeConverterBa) {
    _inherits(IntegerAttributeConverter, _AttributeConverterBa);

    function IntegerAttributeConverter() {
        var _Object$getPrototypeO;

        _classCallCheck(this, IntegerAttributeConverter);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(IntegerAttributeConverter)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.name = "int";
        return _this;
    }

    _createClass(IntegerAttributeConverter, [{
        key: "toStringAttr",
        value: function toStringAttr(val) {
            return val.toString();
        }
    }, {
        key: "toObjectAttr",
        value: function toObjectAttr(attr) {
            return parseInt(attr, 10);
        }
    }]);

    return IntegerAttributeConverter;
}(_AttributeConverterBase2.default);

exports.default = IntegerAttributeConverter;

},{"./AttributeConverterBase":164}],170:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AttributeConverterBase = require("./AttributeConverterBase");

var _AttributeConverterBase2 = _interopRequireDefault(_AttributeConverterBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NumberAttributeConverter = function (_AttributeConverterBa) {
    _inherits(NumberAttributeConverter, _AttributeConverterBa);

    function NumberAttributeConverter() {
        var _Object$getPrototypeO;

        _classCallCheck(this, NumberAttributeConverter);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(NumberAttributeConverter)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.name = "float";
        return _this;
    }

    _createClass(NumberAttributeConverter, [{
        key: "toStringAttr",
        value: function toStringAttr(val) {
            return val.toString();
        }
    }, {
        key: "toObjectAttr",
        value: function toObjectAttr(attr) {
            return Number(attr);
        }
    }]);

    return NumberAttributeConverter;
}(_AttributeConverterBase2.default);

exports.default = NumberAttributeConverter;

},{"./AttributeConverterBase":164}],171:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject2 = require("../../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

var _AttributeParser = require("../AttributeParser");

var _AttributeParser2 = _interopRequireDefault(_AttributeParser);

var _Quaternion = require("../../Math/Quaternion");

var _Quaternion2 = _interopRequireDefault(_Quaternion);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RotationAttributeConverter = function (_JThreeObject) {
    _inherits(RotationAttributeConverter, _JThreeObject);

    function RotationAttributeConverter() {
        var _Object$getPrototypeO;

        _classCallCheck(this, RotationAttributeConverter);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(RotationAttributeConverter)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this.name = "rotation";
        return _this;
    }

    _createClass(RotationAttributeConverter, [{
        key: "toStringAttr",
        value: function toStringAttr(val) {
            return val.toAngleAxisString();
        }
    }, {
        key: "toObjectAttr",
        value: function toObjectAttr(attr) {
            return attr instanceof _Quaternion2.default ? attr : _AttributeParser2.default.parseRotation3D(attr);
        }
    }]);

    return RotationAttributeConverter;
}(_JThreeObject3.default);

exports.default = RotationAttributeConverter;

},{"../../Base/JThreeObject":3,"../../Math/Quaternion":275,"../AttributeParser":161}],172:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AttributeConverterBase = require("./AttributeConverterBase");

var _AttributeConverterBase2 = _interopRequireDefault(_AttributeConverterBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var StringAttributeConverter = function (_AttributeConverterBa) {
    _inherits(StringAttributeConverter, _AttributeConverterBa);

    function StringAttributeConverter() {
        _classCallCheck(this, StringAttributeConverter);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(StringAttributeConverter).apply(this, arguments));
    }

    _createClass(StringAttributeConverter, [{
        key: "toStringAttr",
        value: function toStringAttr(val) {
            return String(val);
        }
    }, {
        key: "toObjectAttr",
        value: function toObjectAttr(attr) {
            return String(attr);
        }
    }]);

    return StringAttributeConverter;
}(_AttributeConverterBase2.default);

exports.default = StringAttributeConverter;

},{"./AttributeConverterBase":164}],173:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AttributeConverterBase = require("./AttributeConverterBase");

var _AttributeConverterBase2 = _interopRequireDefault(_AttributeConverterBase);

var _Vector = require("../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Vector3AttributeConverter = function (_AttributeConverterBa) {
    _inherits(Vector3AttributeConverter, _AttributeConverterBa);

    function Vector3AttributeConverter() {
        _classCallCheck(this, Vector3AttributeConverter);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Vector3AttributeConverter).apply(this, arguments));
    }

    _createClass(Vector3AttributeConverter, [{
        key: "toStringAttr",
        value: function toStringAttr(val) {
            return val.toString();
        }
    }, {
        key: "toObjectAttr",
        value: function toObjectAttr(attr) {
            return attr instanceof _Vector2.default ? attr : _Vector2.default.parse(attr);
        }
    }]);

    return Vector3AttributeConverter;
}(_AttributeConverterBase2.default);

exports.default = Vector3AttributeConverter;

},{"../../Math/Vector3":278,"./AttributeConverterBase":164}],174:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _GomlTreeNodeBase2 = require("./GomlTreeNodeBase");

var _GomlTreeNodeBase3 = _interopRequireDefault(_GomlTreeNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The goml node relating to any core object.
 */

var CoreRelatedNodeBase = function (_GomlTreeNodeBase) {
  _inherits(CoreRelatedNodeBase, _GomlTreeNodeBase);

  function CoreRelatedNodeBase() {
    _classCallCheck(this, CoreRelatedNodeBase);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(CoreRelatedNodeBase).apply(this, arguments));
  }

  return CoreRelatedNodeBase;
}(_GomlTreeNodeBase3.default);

exports.default = CoreRelatedNodeBase;

},{"./GomlTreeNodeBase":183}],175:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectEEWithID2 = require("../Base/JThreeObjectEEWithID");

var _JThreeObjectEEWithID3 = _interopRequireDefault(_JThreeObjectEEWithID2);

var _StringAttributeConverter = require("./Converter/StringAttributeConverter");

var _StringAttributeConverter2 = _interopRequireDefault(_StringAttributeConverter);

var _JThreeContext = require("../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides the feature to manage attribute of GOML.
 */

var GomlAttribute = function (_JThreeObjectEEWithID) {
    _inherits(GomlAttribute, _JThreeObjectEEWithID);

    function GomlAttribute(name, value, converter, reserved, constant) {
        _classCallCheck(this, GomlAttribute);

        /**
         * falseの時はattributeが更新された際のeventは呼ばれません。trueの時、attributeが初期化されていることを示します。
         * @type {boolean}
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GomlAttribute).call(this, name));

        _this.initialized = false;
        /**
         * When reserved flag is true, this attribute is not defined from Node's constructor and expected to be defined in Node.
         * This attribute will be true when it is defined not in Node but in Element.
         * @type {boolean}
         */
        _this.reserved = false;
        /**
         * deferred for handling async initializing of attribute.
         * @type {boolean}
         */
        _this._deferred = null;
        _this._initializeSequence = false;
        _this._nodeManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.NodeManager);
        _this.constant = constant !== undefined ? constant : false;
        _this.reserved = reserved !== undefined ? reserved : false;
        _this.Converter = converter;
        _this.Value = value;
        return _this;
    }
    /**
     * Attributeが初期化されていることを示すinitializedのフラグを建て、attributeが更新された際のeventが有効になるようにします。
     *
     * このメソッドはGomlNodeのインスタンスが生成された後に呼ばれ、GomlNodeのコンストラクタ内でset:Valueが呼ばれてもeventは発生しません。
     */


    _createClass(GomlAttribute, [{
        key: "initialize",
        value: function initialize() {
            if (this.__value === undefined) {
                console.warn("Attribute " + this.Name + " is undefined.");
            }
            // console.log("initialized", this.ID, this.value);
            if (this.reserved) {
                // overrideが期待されているattributeの初期化
                // notifyValueChangedでdeferredが解決される
                // temp時にinitializeSequenceが開始される
                // 一箇所でpromiseを集めるための処置
                this._initializeSequence = true;
            } else if (!this.constant && this.listeners("changed").length !== 0) {
                // 通常時のAttributeの初期化
                // onchangeのイベントのコールバック内でdoneでdeferredが解決される
                this._initializeSequence = true;
                if (this._nodeManager.attributePromiseRegistry.enabled) {
                    this._deferred = _q2.default.defer();
                    this._nodeManager.attributePromiseRegistry.register(this._deferred.promise, this);
                }
                this.emit("changed", this);
            } else {
                // onchangeハンドラが無い、又は定数の場合はpromiseを生成しない。
                this.initialized = true;
            }
        }
        /**
         * This method must be called inside onchange event callback.
         */

    }, {
        key: "done",
        value: function done() {
            if (this._initializeSequence) {
                this.initialized = true;
                this._initializeSequence = false;
                // console.log("resolve attribute (done)", this.Name);
                if (this._nodeManager.attributePromiseRegistry.enabled) {
                    this._deferred.resolve(this);
                }
            }
        }
    }, {
        key: "notifyValueChanged",

        /**
         * Use this method when you emit chenge event.
         * Do not use #emit()
         *
         * on change event will be fired when #initialized property is true.
         * When this attribute is reserved and #initializeSequence is true, change event will also be fired even if not initilized.
         */
        value: function notifyValueChanged() {
            if (this.constant) {
                return;
            }
            if (this.initialized || this._initializeSequence) {
                if (this._initializeSequence) {
                    this._deferred = _q2.default.defer();
                    this._nodeManager.attributePromiseRegistry.register(this._deferred.promise, this);
                }
                this.emit("changed", this);
            }
        }
    }, {
        key: "Name",
        get: function get() {
            return this.id;
        }
    }, {
        key: "Value",
        get: function get() {
            return this.__value;
        },
        set: function set(val) {
            // console.log("setattr", this.Name, val);
            if (this.constant && this.__value !== undefined) {
                console.warn("attribute \"" + this.id + "\" is immutable");
                return;
            }
            if (typeof val === "string") {
                this.__value = this.Converter.toObjectAttr(val);
            } else {
                try {
                    this.Converter.toStringAttr(val);
                } catch (e) {
                    console.warn("type of attribute: " + this.Name + "(" + val + ") is not adapt to converter: " + this.Converter.getTypeName(), val);
                }
                this.__value = val;
            }
            // console.log("setattr_obj", this.Name, this.value);
            if (this.initialized) {
                this.emit("changed", this);
            }
        }
        /**
         * Get converter
         *
         * If converter is undefined, string converter will be used as default.
         * @return {AttributeConverterBase} converter
         */

    }, {
        key: "ValueStr",
        get: function get() {
            return this.__value == null ? "" : this.Converter.toStringAttr(this.__value);
        }
    }, {
        key: "Converter",
        get: function get() {
            return this.__converter ? this.__converter : new _StringAttributeConverter2.default();
        },
        set: function set(converter) {
            if (this.__converter === undefined) {
                this.__converter = converter;
            } else {
                var attr_value = this.Converter.toStringAttr(this.Value);
                this.__converter = converter;
                this.Value = attr_value;
            }
        }
    }]);

    return GomlAttribute;
}(_JThreeObjectEEWithID3.default);

exports.default = GomlAttribute;

},{"../Base/JThreeObjectEEWithID":5,"../ContextComponents":8,"../JThreeContext":267,"./Converter/StringAttributeConverter":172,"q":338}],176:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject2 = require("../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

var _GomlConverterList = require("./GomlConverterList");

var _GomlConverterList2 = _interopRequireDefault(_GomlConverterList);

var _GomlNodeList = require("./GomlNodeList");

var _GomlNodeList2 = _interopRequireDefault(_GomlNodeList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides configurations that will be used when parse GOML.
 * These properties is intended to be used for extending by plugin feature.
 */

var GomlConfigurator = function (_JThreeObject) {
    _inherits(GomlConfigurator, _JThreeObject);

    /**
     * `TagFactory`, `Converter`の定義を行っています
     *
     * `TagFactory`はNodeを生成するために必要です。ここではタグ名とTagFactoryの関連付けを行っております。
     */

    function GomlConfigurator() {
        _classCallCheck(this, GomlConfigurator);

        /**
         * List of converter function classes.
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GomlConfigurator).call(this));

        _this._converters = {};
        /**
         * All list of goml tags that will be parsed and instanciated when parse GOML.
         *
         * Keyはタグ名の文字列(大文字)、ValueはGomlNodeのコンストラクタ
         */
        _this._gomlNodes = {};
        _this._initializeConverters();
        _this._initializeGomlNodes();
        return _this;
    }

    _createClass(GomlConfigurator, [{
        key: "getConverter",
        value: function getConverter(name) {
            return this._converters[name];
        }
        /**
         * タグ名からGomlNodeを取得します
         *
         * @param  {string} tagName タグ名
         * @return {GomlTreeNodeBase}
         */

    }, {
        key: "getGomlNode",
        value: function getGomlNode(tagName) {
            return this._gomlNodes[tagName.toUpperCase()];
        }
        /**
         * Initialize converters from list.
         */

    }, {
        key: "_initializeConverters",
        value: function _initializeConverters() {
            var list = _GomlConverterList2.default;
            for (var key in list) {
                var type = list[key];
                this._converters[key] = new type();
                this._converters[key].name = key;
            }
        }
        /**
         * タグ名とNodeの関連付けを行っています。
         */

    }, {
        key: "_initializeGomlNodes",
        value: function _initializeGomlNodes() {
            var _this2 = this;

            var newList = _GomlNodeList2.default;
            newList.forEach(function (v) {
                for (var key in v.NodeTypes) {
                    var keyInString = key;
                    keyInString = keyInString.toUpperCase(); // transform into upper case
                    var nodeType = v.NodeTypes[keyInString]; // nodeTypeはGomlNodeのコンストラクタ
                    _this2._gomlNodes[keyInString] = nodeType;
                }
            });
        }
    }]);

    return GomlConfigurator;
}(_JThreeObject3.default);

exports.default = GomlConfigurator;

},{"../Base/JThreeObject":3,"./GomlConverterList":177,"./GomlNodeList":180}],177:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _AngleAttributeConverter = require("./Converter/AngleAttributeConverter");

var _AngleAttributeConverter2 = _interopRequireDefault(_AngleAttributeConverter);

var _NumberAttributeConverter = require("./Converter/NumberAttributeConverter");

var _NumberAttributeConverter2 = _interopRequireDefault(_NumberAttributeConverter);

var _IntegerAttributeConverter = require("./Converter/IntegerAttributeConverter");

var _IntegerAttributeConverter2 = _interopRequireDefault(_IntegerAttributeConverter);

var _Vector3AttributeConverter = require("./Converter/Vector3AttributeConverter");

var _Vector3AttributeConverter2 = _interopRequireDefault(_Vector3AttributeConverter);

var _RotationAttributeConverter = require("./Converter/RotationAttributeConverter");

var _RotationAttributeConverter2 = _interopRequireDefault(_RotationAttributeConverter);

var _Color4AttributeConverter = require("./Converter/Color4AttributeConverter");

var _Color4AttributeConverter2 = _interopRequireDefault(_Color4AttributeConverter);

var _Color3AttributeConverter = require("./Converter/Color3AttributeConverter");

var _Color3AttributeConverter2 = _interopRequireDefault(_Color3AttributeConverter);

var _BooleanAttributeConverter = require("./Converter/BooleanAttributeConverter");

var _BooleanAttributeConverter2 = _interopRequireDefault(_BooleanAttributeConverter);

var _StringAttributeConverter = require("./Converter/StringAttributeConverter");

var _StringAttributeConverter2 = _interopRequireDefault(_StringAttributeConverter);

var _FunctionAttributeConverter = require("./Converter/FunctionAttributeConverter");

var _FunctionAttributeConverter2 = _interopRequireDefault(_FunctionAttributeConverter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * List for constructor functions of converter classes.
 * Converters manage how an attribute will be parsed, converted into string, or animated.
 */

var converterList = {
    "angle": _AngleAttributeConverter2.default,
    "float": _NumberAttributeConverter2.default,
    "int": _IntegerAttributeConverter2.default,
    "vec3": _Vector3AttributeConverter2.default,
    "rotation": _RotationAttributeConverter2.default,
    "color4": _Color4AttributeConverter2.default,
    "color3": _Color3AttributeConverter2.default,
    "boolean": _BooleanAttributeConverter2.default,
    "string": _StringAttributeConverter2.default,
    "function": _FunctionAttributeConverter2.default
};
exports.default = converterList;

},{"./Converter/AngleAttributeConverter":163,"./Converter/BooleanAttributeConverter":165,"./Converter/Color3AttributeConverter":166,"./Converter/Color4AttributeConverter":167,"./Converter/FunctionAttributeConverter":168,"./Converter/IntegerAttributeConverter":169,"./Converter/NumberAttributeConverter":170,"./Converter/RotationAttributeConverter":171,"./Converter/StringAttributeConverter":172,"./Converter/Vector3AttributeConverter":173}],178:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject = require("../Base/JThreeObject");

var _JThreeObject2 = _interopRequireDefault(_JThreeObject);

var _JThreeLogger = require("../Base/JThreeLogger");

var _JThreeLogger2 = _interopRequireDefault(_JThreeLogger);

var _JThreeContext = require("../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The class for loading goml.
 */

var GomlLoader = function (_jThreeObject) {
    _inherits(GomlLoader, _jThreeObject);

    /**
     * Constructor. User no need to call this constructor by yourself.
     */

    function GomlLoader(nodeManager, selfTag) {
        _classCallCheck(this, GomlLoader);

        // obtain the script tag that is refering this source code.

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GomlLoader).call(this));

        _this._selfTag = selfTag;
        _this._nodeManager = nodeManager;
        var resourceLoader = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceLoader);
        _this._gomlLoadingDeferred = resourceLoader.getResourceLoadingDeffered();
        resourceLoader.promise.then(function () {
            console.log("load finished!!");
        }, undefined, function (v) {
            // console.log(`loading resource...${v.completedResource / v.resourceCount * 100}%`);
        });
        return _this;
    }
    /**
     * Attempt to load GOMLs that placed in HTML file.
     */


    _createClass(GomlLoader, [{
        key: "initForPage",
        value: function initForPage() {
            _JThreeLogger2.default.sectionLog("Goml loader", "Goml initialization was started.");
            // to load <script src="j3.js" x-goml="HERE"/>
            this._attemptToLoadGomlInScriptAttr();
            // to load the script that is type of text/goml
            var gomls = document.querySelectorAll("script[type=\'text/goml\']");
            for (var i = 0; i < gomls.length; i++) {
                this._loadScriptTag(gomls[i]);
            }
        }
        /**
         * Load goml script for current jthree v3 syntax.
         *
         * Attempt to load x-goml attribute from script tag refering this source.
         * <script x-goml='path/to/goml'></script>
         */

    }, {
        key: "_attemptToLoadGomlInScriptAttr",
        value: function _attemptToLoadGomlInScriptAttr() {
            var _this2 = this;

            var url = this._selfTag.getAttribute("x-goml");
            if (!url) {
                return;
            }
            var xhr = new XMLHttpRequest();
            xhr.addEventListener("load", function () {
                _this2._scriptLoaded(new DOMParser().parseFromString(xhr.response, "text/xml").documentElement);
            });
            xhr.open("GET", url);
            xhr.responseType = "text";
            xhr.send();
        }
        /**
         * Load goml script for legacy jthree v2 syntax.
         *
         * Attempt to load src or innerText from script tag refering this source.
         * <script type='text/goml' src='path/to/goml'></script>
         * or
         * <script type='text/goml'>{{goml}}</script>
         *
         * @param {HTMLElement} scriptTag HTMLElement object of script tag
         */

    }, {
        key: "_loadScriptTag",
        value: function _loadScriptTag(scriptTag) {
            var _this3 = this;

            var srcSource = scriptTag.getAttribute("src"),
                xhr = new XMLHttpRequest();
            if (srcSource) {
                // use xhr to get script of src
                xhr.addEventListener("load", function () {
                    _this3._scriptLoaded(new DOMParser().parseFromString(xhr.response, "text/xml").documentElement);
                });
                xhr.open("GET", srcSource);
                xhr.responseType = "text";
                xhr.send();
            } else {
                for (var i = 0; i + 1 <= scriptTag.childNodes.length; i++) {
                    var gomlElement = scriptTag.childNodes[i];
                    if (gomlElement.nodeType === 3) {
                        this._scriptLoaded(new DOMParser().parseFromString(gomlElement.nodeValue, "text/xml").documentElement);
                    }
                }
            }
        }
        /**
         * parse goml source to node tree and load each node
         *
         * @param {HTMLElement} source goml source
         */

    }, {
        key: "_scriptLoaded",
        value: function _scriptLoaded(source) {
            var _this4 = this;

            this._nodeManager.setNodeToRootByElement(source, function (err) {
                if (err) {
                    throw err;
                }
                // onfullfilled
                console.log("all attribute initialized");
                _this4._gomlLoadingDeferred.resolve(null);
            });
        }
    }]);

    return GomlLoader;
}(_JThreeObject2.default);

exports.default = GomlLoader;

},{"../Base/JThreeLogger":2,"../Base/JThreeObject":3,"../ContextComponents":8,"../JThreeContext":267}],179:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject = require("../Base/JThreeObject");

var _JThreeObject2 = _interopRequireDefault(_JThreeObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Dictionary class to cache GOML node objects.
 */

var GomlNodeDictionary = function (_jThreeObject) {
    _inherits(GomlNodeDictionary, _jThreeObject);

    function GomlNodeDictionary() {
        var _Object$getPrototypeO;

        _classCallCheck(this, GomlNodeDictionary);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        /**
         * Assosiative array that indexed by group and name, which assosiate GomlTreeNodeBase and callback functions.
         * @type {GomlTreeNodeBase}
         */

        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(GomlNodeDictionary)).call.apply(_Object$getPrototypeO, [this].concat(args)));

        _this._dictionary = {};
        /**
         * Assosiative array that indexed by ID, which assosiate group and name string.
         * @type {string}
         */
        _this._iDDictionary = {};
        return _this;
    }
    /**
     * add or update Object by group and name
     * @param {string}           group group string
     * @param {string}           name  name string
     * @param {GomlTreeNodeBase} obj   node object
     */


    _createClass(GomlNodeDictionary, [{
        key: "addNode",
        value: function addNode(group, name, node) {
            if (typeof group === "undefined" || typeof name === "undefined") {
                console.error("group or name is undefined. group: " + group + ", name: " + name);
            }
            // console.log("addNode", group, name, node);
            // register
            if (!this._dictionary[group]) {
                this._dictionary[group] = {};
            }
            if (!this._dictionary[group][name]) {
                this._dictionary[group][name] = { node: void 0, cb: [] };
            }
            var target = this._dictionary[group][name];
            var group_name = this._iDDictionary[node.id];
            target.node = node;
            // when node is exist in other group and name
            if (group_name) {
                if (!(group_name.group === group && group_name.name === name)) {
                    if (target.node.Mounted) {
                        // notify remove
                        this._dictionary[group_name.group][group_name.name].cb.forEach(function (fn) {
                            fn(null);
                        });
                        // console.log("callWithNode(notify-remove)", null, `cb:${this.dictionary[group_name.group][group_name.name].cb.length}`);
                        delete this._dictionary[group_name.group][group_name.name];
                    }
                }
            }
            this._iDDictionary[target.node.id] = { group: group, name: name };
            if (target.node.Mounted) {
                // console.log("callWithNode(on-add)", target.node.getTypeName(), `cb:${target.cb.length}`);
                target.cb.forEach(function (fn) {
                    fn(target.node);
                });
            } else {
                target.node.on("on-mount", function () {
                    // console.log("callWithNode(on-mount)", target.node.getTypeName(), `cb:${target.cb.length}`);
                    target.cb.forEach(function (fn) {
                        fn(target.node);
                    });
                });
            }
            target.node.on("on-unmount", function () {
                // console.log("callWithNode(on-mount)", null, `cb:${target.cb.length}`);
                target.cb.forEach(function (fn) {
                    fn(null);
                });
            });
        }
        /**
         * get node. callback function is call when target node is changed.
         * @param {string}                              group      group string
         * @param {string}                              name       name string
         * @param {(node: GomlTreeNodeBase) => void} callbackfn callback function for notifying node changes.
         */

    }, {
        key: "getNode",
        value: function getNode(group, name, callbackfn) {
            if (typeof group === "undefined" || typeof name === "undefined") {
                console.error("group or name is undefined. group: " + group + ", name: " + name);
            }
            // console.log("getNode", group, name);
            // register
            if (!this._dictionary[group]) {
                this._dictionary[group] = {};
            }
            if (!this._dictionary[group][name]) {
                this._dictionary[group][name] = { node: void 0, cb: [] };
            }
            // console.log(this.dictionary);
            var target = this._dictionary[group][name];
            if (target.cb.length >= 100) {} else {
                target.cb.push(callbackfn);
            }
            // call immediately
            // console.log("callWithNode(on-get)", target.node ? (target.node.Mounted ? target.node : null) : undefined, `cb:${target.cb.length}`);
            callbackfn(target.node ? target.node.Mounted ? target.node : null : null);
        }
    }]);

    return GomlNodeDictionary;
}(_JThreeObject2.default);

exports.default = GomlNodeDictionary;

},{"../Base/JThreeObject":3}],180:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _GomlNodeListElement = require("./GomlNodeListElement");

var _GomlNodeListElement2 = _interopRequireDefault(_GomlNodeListElement);

var _CanvasesNode = require("./Nodes/TopLevel/CanvasesNode");

var _CanvasesNode2 = _interopRequireDefault(_CanvasesNode);

var _ResourcesNode = require("./Nodes/TopLevel/ResourcesNode");

var _ResourcesNode2 = _interopRequireDefault(_ResourcesNode);

var _ScenesNode = require("./Nodes/TopLevel/ScenesNode");

var _ScenesNode2 = _interopRequireDefault(_ScenesNode);

var _TemplatesNode = require("./Nodes/TopLevel/TemplatesNode");

var _TemplatesNode2 = _interopRequireDefault(_TemplatesNode);

var _LoadersNode = require("./Nodes/TopLevel/LoadersNode");

var _LoadersNode2 = _interopRequireDefault(_LoadersNode);

var _GomlNode = require("./Nodes/TopLevel/GomlNode");

var _GomlNode2 = _interopRequireDefault(_GomlNode);

var _TriangleGeometryNode = require("./Nodes/Geometries/TriangleGeometryNode");

var _TriangleGeometryNode2 = _interopRequireDefault(_TriangleGeometryNode);

var _GridGeometryNode = require("./Nodes/Geometries/GridGeometryNode");

var _GridGeometryNode2 = _interopRequireDefault(_GridGeometryNode);

var _CubeGeometryNode = require("./Nodes/Geometries/CubeGeometryNode");

var _CubeGeometryNode2 = _interopRequireDefault(_CubeGeometryNode);

var _SphereGeometryNode = require("./Nodes/Geometries/SphereGeometryNode");

var _SphereGeometryNode2 = _interopRequireDefault(_SphereGeometryNode);

var _CircleGeometryNode = require("./Nodes/Geometries/CircleGeometryNode");

var _CircleGeometryNode2 = _interopRequireDefault(_CircleGeometryNode);

var _CylinderGeometryNode = require("./Nodes/Geometries/CylinderGeometryNode");

var _CylinderGeometryNode2 = _interopRequireDefault(_CylinderGeometryNode);

var _QuadGeometryNode = require("./Nodes/Geometries/QuadGeometryNode");

var _QuadGeometryNode2 = _interopRequireDefault(_QuadGeometryNode);

var _ConeGeometryNode = require("./Nodes/Geometries/ConeGeometryNode");

var _ConeGeometryNode2 = _interopRequireDefault(_ConeGeometryNode);

var _CanvasNode = require("./Nodes/Canvases/CanvasNode");

var _CanvasNode2 = _interopRequireDefault(_CanvasNode);

var _ViewPortNode = require("./Nodes/Renderers/ViewPortNode");

var _ViewPortNode2 = _interopRequireDefault(_ViewPortNode);

var _SceneNode = require("./Nodes/SceneNode");

var _SceneNode2 = _interopRequireDefault(_SceneNode);

var _MaterialNode = require("./Nodes/Materials/MaterialNode");

var _MaterialNode2 = _interopRequireDefault(_MaterialNode);

var _CameraNode = require("./Nodes/SceneObjects/Cameras/CameraNode");

var _CameraNode2 = _interopRequireDefault(_CameraNode);

var _OrthoCameraNode = require("./Nodes/SceneObjects/Cameras/OrthoCameraNode");

var _OrthoCameraNode2 = _interopRequireDefault(_OrthoCameraNode);

var _MeshNode = require("./Nodes/SceneObjects/MeshNode");

var _MeshNode2 = _interopRequireDefault(_MeshNode);

var _ObjectNode = require("./Nodes/SceneObjects/ObjectNode");

var _ObjectNode2 = _interopRequireDefault(_ObjectNode);

var _PointLightNode = require("./Nodes/SceneObjects/Lights/PointLightNode");

var _PointLightNode2 = _interopRequireDefault(_PointLightNode);

var _DirectionalLightNode = require("./Nodes/SceneObjects/Lights/DirectionalLightNode");

var _DirectionalLightNode2 = _interopRequireDefault(_DirectionalLightNode);

var _AreaLightNode = require("./Nodes/SceneObjects/Lights/AreaLightNode");

var _AreaLightNode2 = _interopRequireDefault(_AreaLightNode);

var _SpotLightNode = require("./Nodes/SceneObjects/Lights/SpotLightNode");

var _SpotLightNode2 = _interopRequireDefault(_SpotLightNode);

var _SceneLightNode = require("./Nodes/SceneObjects/Lights/SceneLightNode");

var _SceneLightNode2 = _interopRequireDefault(_SceneLightNode);

var _PMXNode = require("../PMX/Goml/PMXNode");

var _PMXNode2 = _interopRequireDefault(_PMXNode);

var _TextureNode = require("./Nodes/Texture/TextureNode");

var _TextureNode2 = _interopRequireDefault(_TextureNode);

var _CubeTextureNode = require("./Nodes/Texture/CubeTextureNode");

var _CubeTextureNode2 = _interopRequireDefault(_CubeTextureNode);

var _TemplateNode = require("./Nodes/Templates/TemplateNode");

var _TemplateNode2 = _interopRequireDefault(_TemplateNode);

var _LoaderNode = require("./Nodes/Loaders/LoaderNode");

var _LoaderNode2 = _interopRequireDefault(_LoaderNode);

var _VMDNode = require("../VMD/Goml/VMDNode");

var _VMDNode2 = _interopRequireDefault(_VMDNode);

var _XNode = require("../X/Goml/XNode");

var _XNode2 = _interopRequireDefault(_XNode);

var _ImportNode = require("./Nodes/Imports/ImportNode");

var _ImportNode2 = _interopRequireDefault(_ImportNode);

var _ImportsNode = require("./Nodes/TopLevel/ImportsNode");

var _ImportsNode2 = _interopRequireDefault(_ImportsNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var gomlList = [new _GomlNodeListElement2.default("jthree.toplevel", {
    "CANVASES": _CanvasesNode2.default,
    "RESOURCES": _ResourcesNode2.default,
    "SCENES": _ScenesNode2.default,
    "TEMPLATES": _TemplatesNode2.default,
    "LOADERS": _LoadersNode2.default,
    "IMPORTS": _ImportsNode2.default,
    "GOML": _GomlNode2.default
}), new _GomlNodeListElement2.default("jthree.geometries", {
    "TRI": _TriangleGeometryNode2.default,
    "GRID": _GridGeometryNode2.default,
    "CUBE": _CubeGeometryNode2.default,
    "SPHERE": _SphereGeometryNode2.default,
    "CIRCLE": _CircleGeometryNode2.default,
    "CYLINDER": _CylinderGeometryNode2.default,
    "QUAD": _QuadGeometryNode2.default,
    "CONE": _ConeGeometryNode2.default
}), new _GomlNodeListElement2.default("jthree.basic", {
    "CANVAS": _CanvasNode2.default,
    "VIEWPORT": _ViewPortNode2.default,
    "SCENE": _SceneNode2.default
}), new _GomlNodeListElement2.default("jthree.materials", {
    "MATERIAL": _MaterialNode2.default
}), new _GomlNodeListElement2.default("jthree.sceneobject", {
    "CAMERA": _CameraNode2.default,
    "OCAMERA": _OrthoCameraNode2.default,
    "MESH": _MeshNode2.default,
    "OBJECT": _ObjectNode2.default,
    "PLIGHT": _PointLightNode2.default,
    "DLIGHT": _DirectionalLightNode2.default,
    "ALIGHT": _AreaLightNode2.default,
    "SLIGHT": _SpotLightNode2.default,
    "SCENELIGHT": _SceneLightNode2.default,
    "PMX": _PMXNode2.default
}), new _GomlNodeListElement2.default("jthree.textures", {
    "TEXTURE": _TextureNode2.default,
    "CUBETEXTURE": _CubeTextureNode2.default
}), new _GomlNodeListElement2.default("jthree.template", {
    "TEMPLATE": _TemplateNode2.default
}), new _GomlNodeListElement2.default("jthree.loader", {
    "LOADER": _LoaderNode2.default
}),
// new GomlNodeListElement("jthree.pmx.morph",
//   {
//     "MORPH": PMXMorphNode,
//   }),
// new GomlNodeListElement("jthree.pmx.bone",
//   {
//     "BONE": PMXBoneNode,
//   }),
new _GomlNodeListElement2.default("jthree.pmx.contents", {
    // "MORPHS": PMXMorphsNode,
    // "BONES": PMXBonesNode,
    "VMD": _VMDNode2.default
}), new _GomlNodeListElement2.default("x", {
    "X": _XNode2.default
}), new _GomlNodeListElement2.default("jthree.import", {
    "IMPORT": _ImportNode2.default
})];
exports.default = gomlList;

},{"../PMX/Goml/PMXNode":298,"../VMD/Goml/VMDNode":304,"../X/Goml/XNode":311,"./GomlNodeListElement":181,"./Nodes/Canvases/CanvasNode":186,"./Nodes/Geometries/CircleGeometryNode":187,"./Nodes/Geometries/ConeGeometryNode":188,"./Nodes/Geometries/CubeGeometryNode":189,"./Nodes/Geometries/CylinderGeometryNode":190,"./Nodes/Geometries/GridGeometryNode":192,"./Nodes/Geometries/QuadGeometryNode":193,"./Nodes/Geometries/SphereGeometryNode":194,"./Nodes/Geometries/TriangleGeometryNode":195,"./Nodes/Imports/ImportNode":196,"./Nodes/Loaders/LoaderNode":197,"./Nodes/Materials/MaterialNode":198,"./Nodes/Renderers/ViewPortNode":200,"./Nodes/SceneNode":201,"./Nodes/SceneObjects/Cameras/CameraNode":202,"./Nodes/SceneObjects/Cameras/OrthoCameraNode":204,"./Nodes/SceneObjects/Lights/AreaLightNode":205,"./Nodes/SceneObjects/Lights/DirectionalLightNode":206,"./Nodes/SceneObjects/Lights/PointLightNode":208,"./Nodes/SceneObjects/Lights/SceneLightNode":209,"./Nodes/SceneObjects/Lights/SpotLightNode":210,"./Nodes/SceneObjects/MeshNode":211,"./Nodes/SceneObjects/ObjectNode":212,"./Nodes/Templates/TemplateNode":214,"./Nodes/Texture/CubeTextureNode":215,"./Nodes/Texture/TextureNode":216,"./Nodes/TopLevel/CanvasesNode":218,"./Nodes/TopLevel/GomlNode":219,"./Nodes/TopLevel/ImportsNode":220,"./Nodes/TopLevel/LoadersNode":221,"./Nodes/TopLevel/ResourcesNode":223,"./Nodes/TopLevel/ScenesNode":224,"./Nodes/TopLevel/TemplatesNode":225}],181:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject2 = require("../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * GomlNodeをグループとしてまとめて管理します
 */

var GomlNodeListElement = function (_JThreeObject) {
    _inherits(GomlNodeListElement, _JThreeObject);

    /**
     * constructor
     *
     * @param {string} group    グループ識別用の文字列。すべて大文字で管理されています。
     * @param {any}}  nodeTypes グループ内のGomlNodeのconstructorをまとめるObject。Tag名がKeyとなっています。
     */

    function GomlNodeListElement(group, nodeTypes) {
        _classCallCheck(this, GomlNodeListElement);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GomlNodeListElement).call(this));

        _this._group = group;
        _this._nodeTypes = nodeTypes;
        return _this;
    }

    _createClass(GomlNodeListElement, [{
        key: "Group",
        get: function get() {
            return this._group;
        }
    }, {
        key: "NodeTypes",
        get: function get() {
            return this._nodeTypes;
        }
    }]);

    return GomlNodeListElement;
}(_JThreeObject3.default);

exports.default = GomlNodeListElement;

},{"../Base/JThreeObject":3}],182:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Parser of Goml to Node utilities.
 * This class do not store any nodes and goml properties.
 */

var GomlParser = function () {
    function GomlParser() {
        _classCallCheck(this, GomlParser);
    }

    _createClass(GomlParser, null, [{
        key: "parse",

        /**
         * Parse Goml to Node
         * @param {HTMLElement} soruce [description]
         */
        value: function parse(soruce, configurator) {
            return GomlParser.parseChild(soruce, configurator);
        }
    }, {
        key: "parseChild",
        value: function parseChild(child, configurator) {
            // obtain factory class for the node
            var elem = child;
            var newNode = GomlParser._createNode(elem, configurator);
            // タグ名が無効、又はattibuteが無効だった場合にはパースはキャンセルされる。HTMLElement側のattrにparseされていないことを記述
            if (newNode) {
                // call this function recursive
                var children = elem.childNodes;
                if (children && children.length !== 0) {
                    for (var i = 0; i < children.length; i++) {
                        if (children[i].nodeType !== 1) {
                            continue;
                        }
                        // generate instances for every children nodes
                        var e = children[i];
                        var newChildNode = GomlParser.parseChild(e, configurator);
                        if (newChildNode) {
                            newNode.addChild(newChildNode);
                        }
                    }
                }
                // console.log("parseChild finish:", newNode);
                return newNode;
            } else {
                // when specified node could not be found
                console.warn("\"" + elem.tagName + "\" was not parsed.");
                return null;
            }
        }
        /**
         * GomlNodeの生成、初期化を行います。
         *
         * GomlNodeの生成のライフサイクルを定義しています。
         * @param  {HTMLElement}      elem         [description]
         * @param  {GomlConfigurator} configurator [description]
         * @return {GomlTreeNodeBase}              [description]
         */

    }, {
        key: "_createNode",
        value: function _createNode(elem, configurator) {
            // console.log("START");
            var tagName = elem.tagName;
            // console.log(`createNode: ${tagName}`);
            var nodeType = configurator.getGomlNode(tagName);
            /**
             * インスタンス生成
             * それぞれのGomlNodeのattributeの定義、attribute更新時のイベント、child, parent更新時のイベントの定義
             */
            if (nodeType === undefined) {
                throw new Error("Tag " + tagName + " is not found.");
            }
            var newNode = new nodeType();
            /**
             * HTMLElementのattributeとのバインディング
             *
             * Nodeの必須Attributes一覧を取得し、HTMLElementに存在しなければ追加。
             * HTMLElementのすべてのattributesを取得し、NodeのAttributesに反映。なかった場合にはreserveする。
             */
            // console.log(elem.outerHTML);
            newNode.attributes.forEachAttr(function (attr, key) {
                if (!elem.getAttribute(key)) {
                    // console.log("add essential attr:", key, attr.ValueStr, attr.Value);
                    elem.setAttribute(key, attr.ValueStr);
                }
            });
            for (var i = 0; i <= elem.attributes.length - 1; i++) {
                var attr = elem.attributes[i];
                (function (attr_) {
                    var attrKey = attr_.nodeName;
                    var attrValue = attr_.nodeValue;
                    var gomlAttribute = newNode.attributes.getAttribute(attrKey);
                    // console.log("attribute_binding", attrKey, attrValue, gomlAttribute);
                    if (!gomlAttribute) {
                        gomlAttribute = newNode.attributes.reserveAttribute(attrKey, attrValue);
                    } else {
                        gomlAttribute.Value = attrValue;
                    }
                    gomlAttribute.on("changed", function (ga) {
                        elem.setAttribute(attrKey, ga.ValueStr);
                    });
                })(attr);
            }
            newNode.props.setProp("elem", elem);
            elem.setAttribute("x-j3-id", newNode.id);
            // console.log("END");
            return newNode;
        }
    }]);

    return GomlParser;
}();

exports.default = GomlParser;

},{}],183:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AttributeDictionary = require("./AttributeDictionary");

var _AttributeDictionary2 = _interopRequireDefault(_AttributeDictionary);

var _TreeNodeBase2 = require("./TreeNodeBase");

var _TreeNodeBase3 = _interopRequireDefault(_TreeNodeBase2);

var _JThreeContext = require("../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _NodeProps = require("./NodeProps");

var _NodeProps2 = _interopRequireDefault(_NodeProps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This is the most base class in all GomlNode
 */

var GomlTreeNodeBase = function (_TreeNodeBase) {
    _inherits(GomlTreeNodeBase, _TreeNodeBase);

    /**
     * コンストラクタ内ではattributeの定義、attributeの変化時のイベント、child, parentが更新された際のイベントを設定します。
     */

    function GomlTreeNodeBase() {
        _classCallCheck(this, GomlTreeNodeBase);

        /**
         * props for Node.
         * @type {NodeProps}
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GomlTreeNodeBase).call(this));

        _this.props = new _NodeProps2.default();
        /**
         * Group is named after groupPrefixes that supplied from parents.
         * If this property is not overridden, no prefix will be added.
         * @type {string}
         */
        _this.__groupPrefix = "";
        // load node manager
        _this.nodeManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.NodeManager);
        // after configuration, this node is going to add to NodesById
        _this.nodeManager.nodesById[_this.id] = _this;
        _this.attributes = new _AttributeDictionary2.default(_this);
        // apply attributes
        _this.on("node-mount-process-finished", function (mounted) {
            var attrs = _this.attributes.getAllAttributes();
            var attrs_kv = {};
            Object.keys(attrs).forEach(function (v) {
                attrs_kv[v] = attrs[v].Value;
            });
            // console.log("ga initialize", this.getTypeName(), attrs_kv);
            if (mounted) {
                _this.attributes.forEachAttr(function (ga) {
                    ga.initialize();
                });
            }
        });
        return _this;
    }
    /**
     * get group prefixes array that is concatenated from ansestors of tree.
     * @return {string[]} array of group prefix
     */


    _createClass(GomlTreeNodeBase, [{
        key: "nodeExport",

        /**
         * Add node to expose for requiring from other node.
         * @param {string} name String to require argument. This must be uniqe.
         */
        value: function nodeExport(name) {
            var group = [].concat(["jthree"], this.GroupPrefix).join(".");
            this.nodeManager.nodeRegister.addNode(group, name, this);
        }
        /**
         * Require other node. callbackfn is called when the momoent when this method is called or, soecified node is added, updated or removed.
         * If specified node has not added yet, callbackfn is called with null.
         * If specified node is removed, callbackfn is called with null.
         *
         * @param {string}                              group      group string that group prefixes array joined with '.'.
         * @param {string}                              name       name identify among specified group.
         * @param {(node: GomlTreeNodeBase) => void} callbackfn callback function called with required node.
         */

    }, {
        key: "nodeImport",
        value: function nodeImport(group, name, callbackfn) {
            this.nodeManager.nodeRegister.getNode(group, name, callbackfn);
        }
        /**
         * This method is called in each frame while mounted.
         * **NOTE** This method will be removed.
         */

    }, {
        key: "update",
        value: function update() {
            return;
        }
    }, {
        key: "GroupPrefix",
        get: function get() {
            var groupPrefixArray = [];
            if (this.__parent) {
                groupPrefixArray = this.__parent.GroupPrefix;
            }
            if (this.__groupPrefix !== "") {
                groupPrefixArray.push(this.__groupPrefix);
            }
            return groupPrefixArray;
        }
    }]);

    return GomlTreeNodeBase;
}(_TreeNodeBase3.default);

exports.default = GomlTreeNodeBase;

},{"../ContextComponents":8,"../JThreeContext":267,"./AttributeDictionary":160,"./NodeProps":185,"./TreeNodeBase":226}],184:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject2 = require("../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

var _GomlNodeDictionary = require("../Goml/GomlNodeDictionary");

var _GomlNodeDictionary2 = _interopRequireDefault(_GomlNodeDictionary);

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _GomlConfigurator = require("./GomlConfigurator");

var _GomlConfigurator2 = _interopRequireDefault(_GomlConfigurator);

var _JThreeContext = require("../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _AttributePromiseRegistry = require("./AttributePromiseRegistry");

var _AttributePromiseRegistry2 = _interopRequireDefault(_AttributePromiseRegistry);

var _GomlParser = require("./GomlParser");

var _GomlParser2 = _interopRequireDefault(_GomlParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NodeManager = function (_JThreeObject) {
    _inherits(NodeManager, _JThreeObject);

    function NodeManager() {
        _classCallCheck(this, NodeManager);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(NodeManager).call(this));

        _this.nodeRegister = new _GomlNodeDictionary2.default();
        _this.attributePromiseRegistry = new _AttributePromiseRegistry2.default();
        _this.nodesById = {};
        _this.ready = false;
        /**
         * this configurator will load any tag information by require.
         */
        _this.configurator = new _GomlConfigurator2.default();
        var loopManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.LoopManager);
        loopManager.addAction(3000, function () {
            return _this.update();
        });
        return _this;
    }

    _createClass(NodeManager, [{
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.NodeManager;
        }
    }, {
        key: "update",
        value: function update() {
            if (!this.ready) {
                return;
            }
            this.gomlRoot.callRecursive(function (v) {
                return v.update();
            });
        }
        /**
         * get Node by unique id.
         * @param  {string}           id Unique id string.
         * @return {GomlTreeNodeBase}    Related goml Node.
         */

    }, {
        key: "getNode",
        value: function getNode(id) {
            return this.nodesById[id];
        }
        /**
         * get goml Node by HTMLElement object.
         * @param  {HTMLElement}      elem HTMLElement object.
         * @return {GomlTreeNodeBase}      Related goml Node object.
         */

    }, {
        key: "getNodeByElement",
        value: function getNodeByElement(elem) {
            var id = elem.getAttribute("x-j3-id");
            return this.getNode(id);
        }
        /**
         * get HTMLElement by goml Node object.
         * @param  {GomlTreeNodeBase} node Goml Node object.
         * @return {HTMLElement}           Related HTMLElement object.
         */

    }, {
        key: "getElementByNode",
        value: function getElementByNode(node) {
            return node.props.getProp("elem");
        }
        /**
         * get Node by query inside context
         * @param  {string}             query   query string.
         * @param  {GomlTreeNodeBase}   context target Node that search for by query.
         * @return {GomlTreeNodeBase[]}         result Node
         */

    }, {
        key: "getNodeByQuery",
        value: function getNodeByQuery(query, context) {
            var result = [];
            var target = context ? context.props.getProp("elem") : this.htmlRoot;
            var found = target.querySelectorAll(query);
            for (var index = 0; index < found.length; index++) {
                var id = found[index].getAttribute("x-j3-id");
                result.push(this.getNode(id));
            }
            return result;
        }
        /**
         * Insert goml Node by string.
         * @param {string}           goml       Source string.
         * @param {GomlTreeNodeBase} parentNode The parent Node of inserted children.
         * @param {number}           index      Index of children which will be inserted.
         */

    }, {
        key: "insertNodeByString",
        value: function insertNodeByString(goml, parentNode, index) {
            var source = new DOMParser().parseFromString(goml, "text/xml").documentElement;
            this.insertNodeByElement(source, parentNode, index);
        }
        /**
         * Insert goml Node by HTMLElement object.
         * @param {HTMLElement}      source     Source HTMLElement object.
         * @param {GomlTreeNodeBase} parentNode The parent Node of inserted children.
         * @param {number}           index      Index of children which will be inserted. If you ommision this, insert to end.
         */

    }, {
        key: "insertNodeByElement",
        value: function insertNodeByElement(source, parentNode, index) {
            var newNode = _GomlParser2.default.parse(source, this.configurator);
            parentNode.addChild(newNode, index);
            this.insertNode(newNode, parentNode, index);
        }
        /**
         * Insert Node
         * @param {GomlTreeNodeBase} contentNode insert target Node
         * @param {GomlTreeNodeBase} parentNode parent node which is inserted.
         * @param {number}           index      index of node which target will be inserted. If index is not given, node will be inserted to the end of children.
         */

    }, {
        key: "insertNode",
        value: function insertNode(contentNode, parentNode, index) {
            parentNode.addChild(contentNode, index);
            var parentElement = parentNode.props.getProp("elem");
            var targetElement = contentNode.props.getProp("elem");
            var referenceElement = null;
            if (index != null) {
                var nodeIndex = this._getNodeListIndexByElementIndex(parentElement, index);
                referenceElement = parentElement[nodeIndex];
            }
            parentElement.insertBefore(targetElement, referenceElement);
        }
        /**
         * Remove Node. Root of Node cannot be removed.
         * @param {GomlTreeNodeBase} targetNode remove target Node.
         */

    }, {
        key: "removeNode",
        value: function removeNode(targetNode) {
            targetNode.remove();
            var targetElement = targetNode.props.getProp("elem");
            targetElement.remove();
        }
        /**
         * Move node
         * @param {GomlTreeNodeBase} contentNode target node to move
         * @param {GomlTreeNodeBase} parentNode parent node insert in
         */

    }, {
        key: "moveNode",
        value: function moveNode(contentNode, parentNode, index) {
            if (contentNode.isRoot) {
                if (contentNode.Mounted) {
                    throw new Error("Mounted root node cannot be moved.");
                }
            } else {
                this.removeNode(contentNode);
            }
            this.insertNode(contentNode, parentNode, index);
        }
        /**
         * set goml Node by string.
         * @param {string}     goml       Source string.
         * @param {() => void} callbackfn callback function which will be called when all attributes are initialized.
         */

    }, {
        key: "setNodeToRootByString",
        value: function setNodeToRootByString(goml, callbackfn) {
            var source = new DOMParser().parseFromString(goml, "text/xml").documentElement;
            this.setNodeToRootByElement(source, callbackfn);
        }
        /**
         * set goml Node by HTMLElement object.
         * @param {HTMLElement} source     Source HTMLElement object.
         * @param {() => void}  callbackfn callback function which will be called when all attributes are initialized.
         */

    }, {
        key: "setNodeToRootByElement",
        value: function setNodeToRootByElement(source, callbackfn) {
            var _this2 = this;

            this.attributePromiseRegistry.enabled = true;
            this.htmlRoot = source;
            if (source === undefined || source.tagName.toUpperCase() !== "GOML") {
                callbackfn(new Error("Root node must be \"goml\""));
                return;
            }
            var parsedNode = _GomlParser2.default.parse(source, this.configurator);
            parsedNode.Mounted = true;
            this.gomlRoot = parsedNode;
            console.log("Goml loading was completed");
            this.ready = true;
            var moduleManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ModuleManager);
            moduleManager.ready = true;
            this.attributePromiseRegistry.async(function () {
                _this2.attributePromiseRegistry.enabled = false;
                callbackfn(null);
            });
        }
        /**
         * Get index in NodeList object by index in Element array.
         * @param  {HTMLElement} targetElement target element for searching index. If this argument is negative number, index will be searched from last.
         * @param  {number}      elementIndex  index in Element array
         * @return {number}                    index in NodeList
         */

    }, {
        key: "_getNodeListIndexByElementIndex",
        value: function _getNodeListIndexByElementIndex(targetElement, elementIndex) {
            var nodeListArray = Array.prototype.slice.call(targetElement.childNodes);
            elementIndex = elementIndex < 0 ? nodeListArray.length + elementIndex : elementIndex;
            return nodeListArray.indexOf(nodeListArray.filter(function (v) {
                return v.nodeType === 1;
            })[elementIndex]);
        }
    }]);

    return NodeManager;
}(_JThreeObject3.default);

exports.default = NodeManager;

},{"../Base/JThreeObject":3,"../ContextComponents":8,"../Goml/GomlNodeDictionary":179,"../JThreeContext":267,"./AttributePromiseRegistry":162,"./GomlConfigurator":176,"./GomlParser":182}],185:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require("events");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NodeProps = function (_EventEmitter) {
    _inherits(NodeProps, _EventEmitter);

    function NodeProps() {
        _classCallCheck(this, NodeProps);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(NodeProps).call(this));

        _this._props = {};
        return _this;
    }
    /**
     * set Prop. Relative events is fired.
     * @param  {string} key   [description]
     * @param  {any}    value [description]
     * @return {IProps}       [description]
     */


    _createClass(NodeProps, [{
        key: "setProp",
        value: function setProp(key, value) {
            this._props[key] = value;
            this.emit(key, value);
            return _defineProperty({}, key, value);
        }
        /**
         * Set event listener to prop.
         * instantly_exec is true, callbackfn will be called instantly.
         * @param  {string}                key            [description]
         * @param  {(value: any) => void} callbackfn     [description]
         * @param  {boolean}               instantly_exec [description]
         * @return {(value: any) => void}                [description]
         */

    }, {
        key: "setEventToProp",
        value: function setEventToProp(key, callbackfn, instantly_exec) {
            this.on(key, callbackfn);
            if (instantly_exec && this._props[key] !== undefined) {
                callbackfn(this._props[key]);
            }
            return callbackfn;
        }
        /**
         * Get props.
         * This method is not recommended to use due to lack of consistency.
         * Use #setEventToProp to add change handler.
         *
         * @param  {string} key [description]
         * @return {any}        [description]
         */

    }, {
        key: "getProp",
        value: function getProp(key) {
            return this._props[key];
        }
    }]);

    return NodeProps;
}(_events.EventEmitter);

exports.default = NodeProps;

},{"events":318}],186:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CoreRelatedNodeBase2 = require("../../CoreRelatedNodeBase");

var _CoreRelatedNodeBase3 = _interopRequireDefault(_CoreRelatedNodeBase2);

var _CanvasElementBuilder = require("../../../Core/Canvas/CanvasElementBuilder");

var _CanvasElementBuilder2 = _interopRequireDefault(_CanvasElementBuilder);

var _Canvas = require("../../../Core/Canvas/Canvas");

var _Canvas2 = _interopRequireDefault(_Canvas);

var _JThreeContext = require("../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CanvasNode = function (_CoreRelatedNodeBase) {
    _inherits(CanvasNode, _CoreRelatedNodeBase);

    function CanvasNode() {
        _classCallCheck(this, CanvasNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CanvasNode).call(this));

        _this.attributes.defineAttribute({
            "frame": {
                value: undefined,
                converter: "string",
                constant: true
            },
            "width": {
                value: 640,
                converter: "float",
                onchanged: function onchanged(v) {
                    _this.emit("resize");
                    _this.__sizeChanged(v.Value, _this.attributes.getValue("height"));
                    v.done();
                }
            },
            "height": {
                value: 480,
                converter: "float",
                onchanged: function onchanged(v) {
                    _this.emit("resize");
                    _this.__sizeChanged(_this.attributes.getValue("width"), v.Value);
                    v.done();
                }
            },
            "loader": {
                value: undefined,
                converter: "string",
                constant: true
            },
            "clearColor": {
                value: "#0000",
                converter: "color4",
                onchanged: function onchanged(v) {
                    _this.target.clearColor = v.Value;
                    v.done();
                }
            }
        });
        return _this;
    }

    _createClass(CanvasNode, [{
        key: "__onMount",
        value: function __onMount() {
            var _this2 = this;

            _get(Object.getPrototypeOf(CanvasNode.prototype), "__onMount", this).call(this);
            // generate canvas
            var canvas = document.querySelector(this.Frame);
            this.canvasFrames = _CanvasElementBuilder2.default.generate(canvas, this.attributes.getValue("width"), this.attributes.getValue("height"));
            // initialize contexts
            this.target = new _Canvas2.default(this.canvasFrames.canvas);
            _JThreeContext2.default.getContextComponent(_ContextComponents2.default.CanvasManager).addCanvas(this.target);
            // construct loader
            var defaultLoader = undefined;
            // TODO: pnly
            // if (this.attributes.getValue("loader") !== "undefined" && this.nodeManager.nodeRegister.hasGroup("jthree.loader")) {
            //   var loaderNode = (this.nodeManager.nodeRegister.getObject("jthree.loader", this.attributes.getValue("loader")) as any);
            //   if (loaderNode) defaultLoader = loaderNode.loaderHTML;
            // }
            if (!defaultLoader) {
                defaultLoader = require("../../../static/defaultLoader.html");
            }
            this.canvasFrames.loaderContainer.innerHTML = defaultLoader;
            var progressLoaders = this.canvasFrames.loaderContainer.querySelectorAll(".x-j3-loader-progress");
            _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceLoader).promise.then(function () {
                var loaders = _this2.canvasFrames.resizeDetecter.querySelectorAll(".x-j3-loader-container");
                for (var i = 0; i < loaders.length; i++) {
                    var loader = loaders.item(i);
                    loader.remove();
                }
            }, function () {
                return;
            }, function (p) {
                for (var i = 0; i < progressLoaders.length; i++) {
                    var progress = progressLoaders.item(i);
                    progress.style.width = p.completedResource / p.resourceCount * 100 + "%";
                }
            });
        }
    }, {
        key: "__sizeChanged",
        value: function __sizeChanged(width, height) {
            this.canvasFrames.canvas.width = width;
            this.canvasFrames.canvas.height = height;
        }
    }, {
        key: "Frame",
        get: function get() {
            return this.attributes.getValue("frame") || "body";
        }
    }, {
        key: "DefaultWidth",
        get: function get() {
            return this.canvasFrames.container.clientWidth;
        }
    }, {
        key: "DefaultHeight",
        get: function get() {
            return this.canvasFrames.container.clientHeight;
        }
    }]);

    return CanvasNode;
}(_CoreRelatedNodeBase3.default);

exports.default = CanvasNode;

},{"../../../ContextComponents":8,"../../../Core/Canvas/Canvas":9,"../../../Core/Canvas/CanvasElementBuilder":10,"../../../JThreeContext":267,"../../../static/defaultLoader.html":317,"../../CoreRelatedNodeBase":174}],187:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GeometryNodeBase2 = require("./GeometryNodeBase");

var _GeometryNodeBase3 = _interopRequireDefault(_GeometryNodeBase2);

var _CircleGeometry = require("../../../Core/Geometries/CircleGeometry");

var _CircleGeometry2 = _interopRequireDefault(_CircleGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CircleGeometryNode = function (_GeometryNodeBase) {
    _inherits(CircleGeometryNode, _GeometryNodeBase);

    function CircleGeometryNode() {
        _classCallCheck(this, CircleGeometryNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CircleGeometryNode).call(this));

        _this.attributes.defineAttribute({
            "divide": {
                value: 30,
                converter: "int",
                onchanged: _this._onDivideAttrChanged
            }
        });
        return _this;
    }

    _createClass(CircleGeometryNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(CircleGeometryNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "__constructGeometry",
        value: function __constructGeometry(name) {
            return new _CircleGeometry2.default(name);
        }
    }, {
        key: "_onDivideAttrChanged",
        value: function _onDivideAttrChanged(attr) {
            this.target.DiviceCount = attr.Value;
            attr.done();
        }
    }]);

    return CircleGeometryNode;
}(_GeometryNodeBase3.default);

exports.default = CircleGeometryNode;

},{"../../../Core/Geometries/CircleGeometry":26,"./GeometryNodeBase":191}],188:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _ConeGeometry = require("../../../Core/Geometries/ConeGeometry");

var _ConeGeometry2 = _interopRequireDefault(_ConeGeometry);

var _GeometryNodeBase2 = require("./GeometryNodeBase");

var _GeometryNodeBase3 = _interopRequireDefault(_GeometryNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ConeGeometryNode = function (_GeometryNodeBase) {
    _inherits(ConeGeometryNode, _GeometryNodeBase);

    function ConeGeometryNode() {
        _classCallCheck(this, ConeGeometryNode);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ConeGeometryNode).call(this));
    }

    _createClass(ConeGeometryNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(ConeGeometryNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "__constructGeometry",
        value: function __constructGeometry(name) {
            return new _ConeGeometry2.default(name);
        }
    }]);

    return ConeGeometryNode;
}(_GeometryNodeBase3.default);

exports.default = ConeGeometryNode;

},{"../../../Core/Geometries/ConeGeometry":27,"./GeometryNodeBase":191}],189:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GeometryNodeBase2 = require("./GeometryNodeBase");

var _GeometryNodeBase3 = _interopRequireDefault(_GeometryNodeBase2);

var _CubeGeometry = require("../../../Core/Geometries/CubeGeometry");

var _CubeGeometry2 = _interopRequireDefault(_CubeGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CubeGeometryNode = function (_GeometryNodeBase) {
    _inherits(CubeGeometryNode, _GeometryNodeBase);

    function CubeGeometryNode() {
        _classCallCheck(this, CubeGeometryNode);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(CubeGeometryNode).call(this));
    }

    _createClass(CubeGeometryNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(CubeGeometryNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "__constructGeometry",
        value: function __constructGeometry(name) {
            return new _CubeGeometry2.default(name);
        }
    }]);

    return CubeGeometryNode;
}(_GeometryNodeBase3.default);

exports.default = CubeGeometryNode;

},{"../../../Core/Geometries/CubeGeometry":28,"./GeometryNodeBase":191}],190:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GeometryNodeBase2 = require("./GeometryNodeBase");

var _GeometryNodeBase3 = _interopRequireDefault(_GeometryNodeBase2);

var _CylinderGeometry = require("../../../Core/Geometries/CylinderGeometry");

var _CylinderGeometry2 = _interopRequireDefault(_CylinderGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CylinderGeometryNode = function (_GeometryNodeBase) {
    _inherits(CylinderGeometryNode, _GeometryNodeBase);

    function CylinderGeometryNode() {
        _classCallCheck(this, CylinderGeometryNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CylinderGeometryNode).call(this));

        _this.attributes.defineAttribute({
            "divide": {
                value: 30,
                converter: "int",
                onchanged: _this._onDivideAttrChanged
            }
        });
        return _this;
    }

    _createClass(CylinderGeometryNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(CylinderGeometryNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "__constructGeometry",
        value: function __constructGeometry(name) {
            return new _CylinderGeometry2.default(name);
        }
    }, {
        key: "_onDivideAttrChanged",
        value: function _onDivideAttrChanged(attr) {
            this.target.DivideCount = attr.Value;
            attr.done();
        }
    }]);

    return CylinderGeometryNode;
}(_GeometryNodeBase3.default);

exports.default = CylinderGeometryNode;

},{"../../../Core/Geometries/CylinderGeometry":29,"./GeometryNodeBase":191}],191:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CoreRelatedNodeBase2 = require("../../CoreRelatedNodeBase");

var _CoreRelatedNodeBase3 = _interopRequireDefault(_CoreRelatedNodeBase2);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* Base class for managing geometry node.
*/

var GeometryNodeBase = function (_CoreRelatedNodeBase) {
    _inherits(GeometryNodeBase, _CoreRelatedNodeBase);

    function GeometryNodeBase() {
        _classCallCheck(this, GeometryNodeBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GeometryNodeBase).call(this));

        _this.__groupPrefix = "geometry";
        _this._primitiveRegistory = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.PrimitiveRegistory);
        _this.attributes.defineAttribute({
            "name": {
                value: undefined,
                converter: "string",
                onchanged: _this._onNameAttrChanged.bind(_this)
            }
        });
        return _this;
    }

    _createClass(GeometryNodeBase, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(GeometryNodeBase.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "_onNameAttrChanged",
        value: function _onNameAttrChanged(attr) {
            var name = attr.Value;
            if (typeof name !== "string") {
                throw Error(this.getTypeName() + ": name attribute must be required.");
            }
            if (this._name !== name) {
                if (typeof this._name !== "undefined" && this._primitiveRegistory.getPrimitive(this._name)) {
                    this._primitiveRegistory.deregisterPrimitive(this._name);
                }
                this._name = name;
                this.target = this.__constructGeometry(this._name);
                if (this.target) {
                    this._primitiveRegistory.registerPrimitive(this._name, this.target);
                    console.log("registered", this._name);
                    this.nodeExport(this._name);
                }
            }
            attr.done();
        }
    }]);

    return GeometryNodeBase;
}(_CoreRelatedNodeBase3.default);

exports.default = GeometryNodeBase;

},{"../../../ContextComponents":8,"../../../JThreeContext":267,"../../CoreRelatedNodeBase":174}],192:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GeometryNodeBase2 = require("./GeometryNodeBase");

var _GeometryNodeBase3 = _interopRequireDefault(_GeometryNodeBase2);

var _GridGeometry = require("../../../Core/Geometries/GridGeometry");

var _GridGeometry2 = _interopRequireDefault(_GridGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GridGeometryNode = function (_GeometryNodeBase) {
    _inherits(GridGeometryNode, _GeometryNodeBase);

    function GridGeometryNode() {
        _classCallCheck(this, GridGeometryNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GridGeometryNode).call(this));

        _this.attributes.defineAttribute({
            "hdiv": {
                value: 10,
                converter: "float",
                onchanged: _this._onHdivAttrChanged
            },
            "vdiv": {
                value: 10,
                converter: "float",
                onchanged: _this._onVdivAttrChanged
            }
        });
        return _this;
    }

    _createClass(GridGeometryNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(GridGeometryNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "__constructGeometry",
        value: function __constructGeometry(name) {
            return new _GridGeometry2.default(name);
        }
    }, {
        key: "_onHdivAttrChanged",
        value: function _onHdivAttrChanged(attr) {
            this.target.HolizontalDivide = attr.Value;
            attr.done();
        }
    }, {
        key: "_onVdivAttrChanged",
        value: function _onVdivAttrChanged(attr) {
            this.target.VerticalDivide = attr.Value;
            attr.done();
        }
    }]);

    return GridGeometryNode;
}(_GeometryNodeBase3.default);

exports.default = GridGeometryNode;

},{"../../../Core/Geometries/GridGeometry":30,"./GeometryNodeBase":191}],193:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GeometryNodeBase2 = require("./GeometryNodeBase");

var _GeometryNodeBase3 = _interopRequireDefault(_GeometryNodeBase2);

var _QuadGeometry = require("../../../Core/Geometries/QuadGeometry");

var _QuadGeometry2 = _interopRequireDefault(_QuadGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var QuadGeometryNode = function (_GeometryNodeBase) {
    _inherits(QuadGeometryNode, _GeometryNodeBase);

    function QuadGeometryNode() {
        _classCallCheck(this, QuadGeometryNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(QuadGeometryNode).call(this));

        _this.attributes.defineAttribute({
            "divx": {
                value: 1,
                converter: "int",
                onchanged: function onchanged(v) {
                    if (v.Value > 0) {
                        _this.target.DivX = v.Value;
                    }
                    v.done();
                }
            },
            "divy": {
                value: 1,
                converter: "int",
                onchanged: function onchanged(v) {
                    if (v.Value > 0) {
                        _this.target.DivY = v.Value;
                    }
                    v.done();
                }
            }
        });
        return _this;
    }

    _createClass(QuadGeometryNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(QuadGeometryNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "__constructGeometry",
        value: function __constructGeometry(name) {
            return new _QuadGeometry2.default(name);
        }
    }]);

    return QuadGeometryNode;
}(_GeometryNodeBase3.default);

exports.default = QuadGeometryNode;

},{"../../../Core/Geometries/QuadGeometry":31,"./GeometryNodeBase":191}],194:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SphereGeometry = require("../../../Core/Geometries/SphereGeometry");

var _SphereGeometry2 = _interopRequireDefault(_SphereGeometry);

var _GeometryNodeBase2 = require("./GeometryNodeBase");

var _GeometryNodeBase3 = _interopRequireDefault(_GeometryNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CubeGeometryNode = function (_GeometryNodeBase) {
    _inherits(CubeGeometryNode, _GeometryNodeBase);

    function CubeGeometryNode() {
        _classCallCheck(this, CubeGeometryNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CubeGeometryNode).call(this));

        _this.attributes.defineAttribute({
            "divx": {
                value: 20,
                converter: "int",
                onchanged: function onchanged(v) {
                    if (v.Value > 1.0) {
                        _this.target.DivX = v.Value;
                    }
                    v.done();
                }
            },
            "divy": {
                value: 20,
                converter: "int",
                onchanged: function onchanged(v) {
                    if (v.Value > 1.0) {
                        _this.target.DivY = v.Value;
                    }
                    v.done();
                }
            }
        });
        return _this;
    }

    _createClass(CubeGeometryNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(CubeGeometryNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "__constructGeometry",
        value: function __constructGeometry(name) {
            return new _SphereGeometry2.default(name);
        }
    }]);

    return CubeGeometryNode;
}(_GeometryNodeBase3.default);

exports.default = CubeGeometryNode;

},{"../../../Core/Geometries/SphereGeometry":32,"./GeometryNodeBase":191}],195:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GeometryNodeBase2 = require("./GeometryNodeBase");

var _GeometryNodeBase3 = _interopRequireDefault(_GeometryNodeBase2);

var _Vector = require("../../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _TriangleGeometry = require("../../../Core/Geometries/TriangleGeometry");

var _TriangleGeometry2 = _interopRequireDefault(_TriangleGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GomlTreeTriNode = function (_GeometryNodeBase) {
    _inherits(GomlTreeTriNode, _GeometryNodeBase);

    function GomlTreeTriNode() {
        _classCallCheck(this, GomlTreeTriNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GomlTreeTriNode).call(this));

        _this.attributes.defineAttribute({
            "first": {
                value: new _Vector2.default(-1, 0, 0),
                converter: "vec3",
                onchanged: _this._onFirstAttrChanged
            },
            "second": {
                value: new _Vector2.default(0, 1, 0),
                converter: "vec3",
                onchanged: _this._onSecondAttrChanged
            },
            "third": {
                value: new _Vector2.default(1, 0, 0),
                converter: "vec3",
                onchanged: _this._onThirdAttrChanged
            }
        });
        return _this;
    }

    _createClass(GomlTreeTriNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(GomlTreeTriNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "__constructGeometry",
        value: function __constructGeometry(name) {
            return new _TriangleGeometry2.default(name);
        }
    }, {
        key: "_onFirstAttrChanged",
        value: function _onFirstAttrChanged(attr) {
            this.target.First = attr.Value;
            attr.done();
        }
    }, {
        key: "_onSecondAttrChanged",
        value: function _onSecondAttrChanged(attr) {
            this.target.Second = attr.Value;
            attr.done();
        }
    }, {
        key: "_onThirdAttrChanged",
        value: function _onThirdAttrChanged(attr) {
            this.target.Third = attr.Value;
            attr.done();
        }
    }]);

    return GomlTreeTriNode;
}(_GeometryNodeBase3.default);

exports.default = GomlTreeTriNode;

},{"../../../Core/Geometries/TriangleGeometry":33,"../../../Math/Vector3":278,"./GeometryNodeBase":191}],196:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GomlTreeNodeBase2 = require("../../GomlTreeNodeBase");

var _GomlTreeNodeBase3 = _interopRequireDefault(_GomlTreeNodeBase2);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ImportNode = function (_GomlTreeNodeBase) {
    _inherits(ImportNode, _GomlTreeNodeBase);

    function ImportNode() {
        _classCallCheck(this, ImportNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ImportNode).call(this));

        _this._type = null;
        _this.attributes.defineAttribute({
            "type": {
                value: undefined,
                converter: "string",
                onchanged: _this._onTypeAttrChanged.bind(_this)
            },
            "src": {
                value: undefined,
                converter: "string",
                onchanged: _this._onSrcAttrChanged.bind(_this)
            }
        });
        _this._materialManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.MaterialManager);
        return _this;
    }

    _createClass(ImportNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(ImportNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "_onTypeAttrChanged",
        value: function _onTypeAttrChanged(attr) {
            if (["material"].indexOf(attr.Value) !== -1) {
                this._type = attr.Value;
                attr.done();
            } else {
                throw new Error("Unknown type: " + attr.Value);
            }
        }
    }, {
        key: "_onSrcAttrChanged",
        value: function _onSrcAttrChanged(attr) {
            var path = attr.Value;
            if (!this._type) {
                switch (path.match(/\.(\w+?)$/)[1]) {
                    case "xmml":
                        this._type = "material";
                        break;
                }
            }
            if (this._type) {
                this._getImport(path, attr.done.bind(attr));
            }
        }
    }, {
        key: "_getImport",
        value: function _getImport(path, done) {
            var _this2 = this;

            var xhr = new XMLHttpRequest();
            xhr.open("GET", path, true);
            xhr.setRequestHeader("Accept", "text");
            xhr.onload = function () {
                if (xhr.status === 200) {
                    var exportName = null;
                    switch (_this2._type) {
                        case "material":
                            var matName = _this2._materialManager.registerMaterial(xhr.responseText);
                            exportName = "material-" + matName;
                            break;
                    }
                    _this2.nodeExport(exportName);
                }
                done();
            };
            xhr.onerror = function (err) {
                console.error(err);
                done();
            };
            xhr.send(null);
        }
    }]);

    return ImportNode;
}(_GomlTreeNodeBase3.default);

exports.default = ImportNode;

},{"../../../ContextComponents":8,"../../../JThreeContext":267,"../../GomlTreeNodeBase":183}],197:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GomlTreeNodeBase2 = require("../../GomlTreeNodeBase");

var _GomlTreeNodeBase3 = _interopRequireDefault(_GomlTreeNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LoaderNode = function (_GomlTreeNodeBase) {
    _inherits(LoaderNode, _GomlTreeNodeBase);

    function LoaderNode() {
        _classCallCheck(this, LoaderNode);

        // this.loaderHTML = elem.innerHTML;

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LoaderNode).call(this));

        _this.loaderHTML = ""; // TODO: pnly
        _this.attributes.defineAttribute({
            "name": {
                value: undefined,
                converter: "string",
                onchanged: _this._onNameAttrChanged
            }
        });
        return _this;
    }

    _createClass(LoaderNode, [{
        key: "_onNameAttrChanged",
        value: function _onNameAttrChanged(attr) {
            this.nodeExport(this.attributes.getValue("name"));
            attr.done();
        }
    }]);

    return LoaderNode;
}(_GomlTreeNodeBase3.default);

exports.default = LoaderNode;

},{"../../GomlTreeNodeBase":183}],198:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _MaterialNodeBase2 = require("./MaterialNodeBase");

var _MaterialNodeBase3 = _interopRequireDefault(_MaterialNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MaterialNode = function (_MaterialNodeBase) {
    _inherits(MaterialNode, _MaterialNodeBase);

    function MaterialNode() {
        _classCallCheck(this, MaterialNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MaterialNode).call(this));

        _this.attributes.defineAttribute({
            "type": {
                value: "builtin.phong",
                converter: "string",
                onchanged: _this._onTypeAttrChanged
            }
        });
        return _this;
    }

    _createClass(MaterialNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(MaterialNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "_onTypeAttrChanged",
        value: function _onTypeAttrChanged(attr) {
            var _this2 = this;

            var material = this.__getMaterialFromMatName(attr.Value);
            if (material) {
                this.__setMaterial(material, function () {
                    attr.done();
                });
            } else {
                this.nodeImport("jthree.import", "material-" + attr.Value, function (node) {
                    if (node) {
                        material = _this2.__getMaterialFromMatName(attr.Value);
                        _this2.__setMaterial(material, function () {
                            attr.done();
                        });
                    }
                });
            }
        }
    }]);

    return MaterialNode;
}(_MaterialNodeBase3.default);

exports.default = MaterialNode;

},{"./MaterialNodeBase":199}],199:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CoreRelatedNodeBase2 = require("../../CoreRelatedNodeBase");

var _CoreRelatedNodeBase3 = _interopRequireDefault(_CoreRelatedNodeBase2);

var _Color = require("../../../Math/Color4");

var _Color2 = _interopRequireDefault(_Color);

var _JThreeContext = require("../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _Vector = require("../../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _Vector3 = require("../../../Math/Vector2");

var _Vector4 = _interopRequireDefault(_Vector3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MaterialNodeBase = function (_CoreRelatedNodeBase) {
    _inherits(MaterialNodeBase, _CoreRelatedNodeBase);

    function MaterialNodeBase() {
        _classCallCheck(this, MaterialNodeBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MaterialNodeBase).call(this));

        _this.__groupPrefix = "material";
        _this._name = "";
        _this.attributes.defineAttribute({
            "name": {
                value: undefined,
                converter: "string",
                onchanged: _this._onNameAttrChanged
            }
        });
        return _this;
    }

    _createClass(MaterialNodeBase, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(MaterialNodeBase.prototype), "__onMount", this).call(this);
        }
        /**
         * Construct material. This method must be overridden.
         * @return {Material} [description]
         */

    }, {
        key: "__setMaterial",
        value: function __setMaterial(material, callbackfn) {
            var _this2 = this;

            this.target = material;
            this._name = this.attributes.getValue("name");
            this.target.on("ready", function () {
                _this2._generateAttributeForPasses();
                _this2.nodeExport(_this2._name);
                callbackfn();
            });
        }
    }, {
        key: "__getMaterialFromMatName",
        value: function __getMaterialFromMatName(name) {
            return _JThreeContext2.default.getContextComponent(_ContextComponents2.default.MaterialManager).constructMaterial(name);
        }
    }, {
        key: "_onNameAttrChanged",
        value: function _onNameAttrChanged(attr) {
            var name = attr.Value;
            if (typeof name !== "string") {
                throw Error(this.getTypeName() + ": name attribute must be required.");
            }
            this._name = name;
            if (this.target && this.target.Initialized) {
                this.nodeExport(this._name);
            }
            attr.done();
        }
    }, {
        key: "_generateAttributeForPasses",
        value: function _generateAttributeForPasses() {
            if (this.target["_passes"]) {
                var passes = this.target["_passes"];
                var passVariables = {};
                for (var i = 0; i < passes.length; i++) {
                    var pass = passes[i];
                    var uniforms = pass.passDescription.programDescription.uniforms;
                    for (var variableName in uniforms) {
                        if (variableName[0] === "_") {
                            continue; // Ignore system variables
                        }
                        if (!passVariables[variableName]) {
                            // When the pass variable are not found yet.
                            passVariables[variableName] = uniforms[variableName];
                        } else {
                            // When the pass variable are already found.
                            if (passVariables[variableName] === uniforms[variableName]) {
                                continue; // When the variable was found and same type.(This is not matter)
                            } else {
                                    console.error("Material can not contain same variables even if these variable are included in different passes");
                                }
                        }
                    }
                }
                var attributes = {};
                for (var _variableName in passVariables) {
                    var attribute = this._generateAttributeForVariable(_variableName, passVariables[_variableName]);
                    if (attribute) {
                        attributes[_variableName] = attribute;
                    }
                }
                this.attributes.defineAttribute(attributes);
            }
        }
    }, {
        key: "_generateAttributeForVariable",
        value: function _generateAttributeForVariable(variableName, variableInfo) {
            var _this3 = this;

            var converter = undefined;
            var initialValue = undefined;
            if (variableInfo.variableType === "vec2") {
                converter = "vec2";
                initialValue = _Vector4.default.Zero;
            }
            if (variableInfo.variableType === "vec3") {
                converter = "color3";
                initialValue = _Vector2.default.Zero;
            }
            if (variableInfo.variableType === "vec4") {
                converter = "color4"; // TODO add vector4 converter
                initialValue = new _Color2.default(0, 0, 0, 1);
            }
            if (variableInfo.variableType === "float") {
                converter = "float"; // This should be float
                initialValue = 0.0;
            }
            if (variableInfo.variableType === "sampler2D") {
                return {
                    converter: "string",
                    value: "",
                    onchanged: function onchanged(attr) {
                        if (attr.Value) {
                            _this3.nodeImport("jthree.resource.Texture2D", attr.Value, function (node) {
                                if (node) {
                                    _this3.target.shaderVariables[variableName] = node.target;
                                    attr.done();
                                } else {}
                            });
                        }
                    }
                };
            }
            if (variableInfo.variableType === "samplerCube") {
                return {
                    converter: "string",
                    value: "",
                    onchanged: function onchanged(attr) {
                        if (attr.Value) {
                            _this3.nodeImport("jthree.resource.TextureCube", attr.Value, function (node) {
                                if (node) {
                                    _this3.target.shaderVariables[variableName] = node.target;
                                    attr.done();
                                } else {}
                            });
                        }
                    }
                };
            }
            if (!converter) {
                console.warn("Variable forwarding for " + variableInfo.variableType + " is not implemented yet. Attribute declaration of " + variableInfo.variableName + " was skipped.");
                return undefined;
            }
            return {
                converter: converter,
                value: initialValue,
                onchanged: function onchanged(attr) {
                    _this3.target.shaderVariables[variableName] = attr.Value;
                    attr.done();
                }
            };
        }
    }, {
        key: "Material",
        get: function get() {
            return this.target;
        }
    }]);

    return MaterialNodeBase;
}(_CoreRelatedNodeBase3.default);

exports.default = MaterialNodeBase;

},{"../../../ContextComponents":8,"../../../JThreeContext":267,"../../../Math/Color4":270,"../../../Math/Vector2":277,"../../../Math/Vector3":278,"../../CoreRelatedNodeBase":174}],200:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CoreRelatedNodeBase2 = require("../../CoreRelatedNodeBase");

var _CoreRelatedNodeBase3 = _interopRequireDefault(_CoreRelatedNodeBase2);

var _Rectangle = require("../../../Math/Rectangle");

var _Rectangle2 = _interopRequireDefault(_Rectangle);

var _RendererFactory = require("../../../Core/Renderers/RendererFactory");

var _RendererFactory2 = _interopRequireDefault(_RendererFactory);

var _EventBroadcaster = require("../../../Interface/Events/EventBroadcaster");

var _EventBroadcaster2 = _interopRequireDefault(_EventBroadcaster);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ViewPortNode = function (_CoreRelatedNodeBase) {
    _inherits(ViewPortNode, _CoreRelatedNodeBase);

    function ViewPortNode() {
        _classCallCheck(this, ViewPortNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ViewPortNode).call(this));

        _this._eventBroadcaster = new _EventBroadcaster2.default();
        _this.attributes.defineAttribute({
            "cam": {
                value: undefined,
                converter: "string",
                onchanged: _this._onCamAttrChanged.bind(_this)
            },
            "width": {
                value: 640,
                converter: "float",
                onchanged: function onchanged(attr) {
                    _this._width = attr.Value;
                    _this._updateViewportArea();
                    attr.done();
                }
            },
            "height": {
                value: 480,
                converter: "float",
                onchanged: function onchanged(attr) {
                    _this._height = attr.Value;
                    _this._updateViewportArea();
                    attr.done();
                }
            },
            "left": {
                value: 0,
                converter: "float",
                onchanged: function onchanged(attr) {
                    _this._left = attr.Value;
                    _this._updateViewportArea();
                    attr.done();
                }
            },
            "top": {
                value: 0,
                converter: "float",
                onchanged: function onchanged(attr) {
                    _this._top = attr.Value;
                    _this._updateViewportArea();
                    attr.done();
                }
            },
            "backgroundType": {
                value: "color",
                converter: "string",
                onchanged: function onchanged(attr) {
                    if (attr.Value !== "skybox" && _this._skyBoxStageChain) {
                        // this.targetRenderer.renderPath.deleteStage(this.skyBoxStageChain); TODO fix this
                        _this._skyBoxStageChain = null;
                    }
                    attr.done();
                }
            },
            "skybox": {
                value: null,
                converter: "string",
                onchanged: _this._onSkyboxAttrChanged.bind(_this)
            },
            "config": {
                converter: "string",
                value: "default",
                onchanged: _this._onConfigAttrChanged.bind(_this)
            },
            "name": {
                converter: "string",
                value: undefined,
                onchanged: function onchanged(attr) {
                    _this.target.name = attr.Value;
                    attr.done();
                }
            }
        });
        return _this;
    }

    _createClass(ViewPortNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(ViewPortNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "__onUnmount",
        value: function __onUnmount() {
            _get(Object.getPrototypeOf(ViewPortNode.prototype), "__onUnmount", this).call(this);
            this._eventBroadcaster.detachEvents();
        }
    }, {
        key: "_onConfigAttrChanged",
        value: function _onConfigAttrChanged(attr) {
            if (this.__parent.getTypeName() !== "CanvasNode") {
                throw Error("viewport must be the direct child of canvas");
            }
            this._parentCanvas = this.__parent;
            var defaultRect = this._parentCanvas.target.region;
            if (this.target) {
                this._eventBroadcaster.detachEvents();
            }
            this.target = _RendererFactory2.default.generateRenderer(this._parentCanvas.target, defaultRect, attr.Value);
            this._eventBroadcaster.attachEvents(this.target);
            attr.done();
        }
    }, {
        key: "_onCamAttrChanged",
        value: function _onCamAttrChanged(attr) {
            this._resolveCamera(attr.Value, attr.done.bind(attr));
        }
    }, {
        key: "_onSkyboxAttrChanged",
        value: function _onSkyboxAttrChanged(attr) {
            var _this2 = this;

            if (this.attributes.getValue("backgroundType") === "skybox") {
                this.nodeImport("jthree.resource.TextureCube", attr.Value, function (node) {
                    if (node) {
                        if (!_this2._skyBoxStageChain) {
                            _this2._skyBoxStageChain = {
                                buffers: {
                                    OUT: "main"
                                },
                                stage: "jthree.basic.skybox",
                                variables: {}
                            };
                            _this2.target.renderPath.insertWithIndex(0, _this2._skyBoxStageChain);
                        }
                        _this2._skyBoxStageChain.variables["skybox"] = node.target;
                        attr.done();
                    } else {
                        attr.done();
                    }
                });
            } else {
                attr.done();
            }
        }
    }, {
        key: "_updateViewportArea",
        value: function _updateViewportArea() {
            // console.log("updateViewportArea");
            if (this._parentCanvas) {
                if (this._parentCanvas.canvasFrames.container) {
                    // when canvas HTMLElement is applied
                    var frame = this._parentCanvas.canvasFrames.container;
                    var W = frame.clientWidth;
                    var H = frame.clientHeight;
                    var left = this._left > 1 ? this._left : W * this._left;
                    var top = this._top > 1 ? this._top : H * this._top;
                    var width = this._width > 1 ? this._width : W * this._width;
                    var height = this._height > 1 ? this._height : H * this._height;
                    this.target.region = new _Rectangle2.default(left, top, width, height);
                } else {
                    // when canvas HTMLElement is not applied
                    this.target.region = new _Rectangle2.default(this._left, this._top, this._width, this._height);
                }
                if (this.target.camera.getTypeName() === "PerspectiveCamera") {
                    this.target.camera.Aspect = this._width / this._height;
                }
            }
        }
    }, {
        key: "_resolveCamera",
        value: function _resolveCamera(cam, done) {
            var _this3 = this;

            this.nodeImport("jthree.scene.camera", cam, function (cameraNode) {
                if (cameraNode) {
                    if (cameraNode.ContainedSceneNode != null) {
                        _this3.target.setCamera(cameraNode.target);
                        _this3._updateViewportArea();
                    } else {
                        console.error("cant retrieve scene!");
                    }
                }
                done();
            });
        }
    }]);

    return ViewPortNode;
}(_CoreRelatedNodeBase3.default);

exports.default = ViewPortNode;

},{"../../../Core/Renderers/RendererFactory":105,"../../../Interface/Events/EventBroadcaster":246,"../../../Math/Rectangle":276,"../../CoreRelatedNodeBase":174}],201:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CoreRelatedNodeBase2 = require("../CoreRelatedNodeBase");

var _CoreRelatedNodeBase3 = _interopRequireDefault(_CoreRelatedNodeBase2);

var _Scene = require("../../Core/Scene");

var _Scene2 = _interopRequireDefault(_Scene);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SceneNode = function (_CoreRelatedNodeBase) {
    _inherits(SceneNode, _CoreRelatedNodeBase);

    function SceneNode() {
        _classCallCheck(this, SceneNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SceneNode).call(this));

        _this.attributes.defineAttribute({
            "ambient": {
                value: "#111",
                converter: "color3",
                onchanged: _this._onAmbientAttrChanged
            },
            "name": {
                value: "",
                converter: "string",
                onchanged: _this._onNameAttrChanged
            }
        });
        return _this;
    }

    _createClass(SceneNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(SceneNode.prototype), "__onMount", this).call(this);
            var sceneName = this.attributes.getValue("name");
            if (sceneName === "") {
                sceneName = null;
            }
            this.target = new _Scene2.default(sceneName);
            _JThreeContext2.default.getContextComponent(_ContextComponents2.default.SceneManager).addScene(this.target);
        }
    }, {
        key: "__onUnmount",
        value: function __onUnmount() {
            _get(Object.getPrototypeOf(SceneNode.prototype), "__onUnmount", this).call(this);
            _JThreeContext2.default.getContextComponent(_ContextComponents2.default.SceneManager).removeScene(this.target);
            // TODO: pnly GC
        }
    }, {
        key: "_onNameAttrChanged",
        value: function _onNameAttrChanged(attr) {
            this.target.id = attr.Value;
            attr.done();
        }
    }, {
        key: "_onAmbientAttrChanged",
        value: function _onAmbientAttrChanged(attr) {
            this.target.sceneAmbient = attr.Value;
            attr.done();
        }
    }]);

    return SceneNode;
}(_CoreRelatedNodeBase3.default);

exports.default = SceneNode;

},{"../../ContextComponents":8,"../../Core/Scene":137,"../../JThreeContext":267,"../CoreRelatedNodeBase":174}],202:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _PerspectiveCamera = require("../../../../Core/SceneObjects/Camera/PerspectiveCamera");

var _PerspectiveCamera2 = _interopRequireDefault(_PerspectiveCamera);

var _CameraNodeBase2 = require("./CameraNodeBase");

var _CameraNodeBase3 = _interopRequireDefault(_CameraNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CameraNode = function (_CameraNodeBase) {
    _inherits(CameraNode, _CameraNodeBase);

    function CameraNode() {
        _classCallCheck(this, CameraNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CameraNode).call(this));

        _this.attributes.defineAttribute({
            "fovy": {
                value: Math.PI / 4,
                converter: "angle",
                onchanged: _this._onFovyAttrChanged.bind(_this)
            },
            "aspect": {
                value: 0,
                converter: "float",
                onchanged: _this._onAspectAttrChanged.bind(_this)
            },
            "near": {
                value: 0.1,
                converter: "float",
                onchanged: _this._onNearAttrChanged.bind(_this)
            },
            "far": {
                value: 10,
                converter: "float",
                onchanged: _this._onFarAttrChanged.bind(_this)
            }
        });
        _this.on("update-scene-object", function (obj) {
            _this._onFovyAttrChanged.call(_this, _this.attributes.getAttribute("fovy"));
            _this._onAspectAttrChanged.call(_this, _this.attributes.getAttribute("aspect"));
            _this._onNearAttrChanged.call(_this, _this.attributes.getAttribute("near"));
            _this._onFarAttrChanged.call(_this, _this.attributes.getAttribute("far"));
        });
        return _this;
    }

    _createClass(CameraNode, [{
        key: "__constructCamera",
        value: function __constructCamera() {
            return new _PerspectiveCamera2.default();
        }
    }, {
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(CameraNode.prototype), "__onMount", this).call(this);
        }
    }, {
        key: "_onFovyAttrChanged",
        value: function _onFovyAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.Fovy = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onAspectAttrChanged",
        value: function _onAspectAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.Aspect = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onNearAttrChanged",
        value: function _onNearAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.Near = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onFarAttrChanged",
        value: function _onFarAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.Far = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "Fovy",
        get: function get() {
            return this.attributes.getValue("fovy");
        }
    }, {
        key: "Aspect",
        get: function get() {
            return this.attributes.getValue("aspect");
        }
    }, {
        key: "Near",
        get: function get() {
            return this.attributes.getValue("near");
        }
    }, {
        key: "Far",
        get: function get() {
            return this.attributes.getValue("far");
        }
    }]);

    return CameraNode;
}(_CameraNodeBase3.default);

exports.default = CameraNode;

},{"../../../../Core/SceneObjects/Camera/PerspectiveCamera":142,"./CameraNodeBase":203}],203:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SceneObjectNodeBase2 = require("../SceneObjectNodeBase");

var _SceneObjectNodeBase3 = _interopRequireDefault(_SceneObjectNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CameraNodeBase = function (_SceneObjectNodeBase) {
    _inherits(CameraNodeBase, _SceneObjectNodeBase);

    function CameraNodeBase() {
        _classCallCheck(this, CameraNodeBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CameraNodeBase).call(this));

        _this.__groupPrefix = "camera";
        _this.attributes.getAttribute("name").on("changed", _this._onNameAttrChanged.bind(_this));
        return _this;
    }
    /**
     * Construct camera. This method should be overridden.
     * @return {Camera} [description]
     */


    _createClass(CameraNodeBase, [{
        key: "__constructCamera",
        value: function __constructCamera() {
            return null;
        }
        /**
         * Construct camera and set to TargetSceneObject.
         * This Node is exported.
         */

    }, {
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(CameraNodeBase.prototype), "__onMount", this).call(this);
            this.TargetSceneObject = this.__constructCamera();
        }
        /**
         * Export node when name attribute changed.
         * @param {GomlAttribute} attr [description]
         */

    }, {
        key: "_onNameAttrChanged",
        value: function _onNameAttrChanged(attr) {
            var name = attr.Value;
            if (typeof name !== "string") {
                throw Error(this.getTypeName() + ": name attribute must be required.");
            }
            this.nodeExport(name);
            attr.done();
        }
    }]);

    return CameraNodeBase;
}(_SceneObjectNodeBase3.default);

exports.default = CameraNodeBase;

},{"../SceneObjectNodeBase":213}],204:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _OrthoCamera = require("../../../../Core/SceneObjects/Camera/OrthoCamera");

var _OrthoCamera2 = _interopRequireDefault(_OrthoCamera);

var _CameraNodeBase2 = require("./CameraNodeBase");

var _CameraNodeBase3 = _interopRequireDefault(_CameraNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OrthoCameraNode = function (_CameraNodeBase) {
    _inherits(OrthoCameraNode, _CameraNodeBase);

    function OrthoCameraNode() {
        _classCallCheck(this, OrthoCameraNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(OrthoCameraNode).call(this));

        _this.attributes.defineAttribute({
            "left": {
                value: -100,
                converter: "float",
                onchanged: _this._onLeftAttrChanged.bind(_this)
            },
            "right": {
                value: 100,
                converter: "float",
                onchanged: _this._onRightAttrChanged.bind(_this)
            },
            "bottom": {
                value: -100,
                converter: "float",
                onchanged: _this._onBottomAttrChanged.bind(_this)
            },
            "top": {
                value: 100,
                converter: "float",
                onchanged: _this._onTopAttrChanged.bind(_this)
            },
            "near": {
                value: -100,
                converter: "float",
                onchanged: _this._onNearAttrChanged.bind(_this)
            },
            "far": {
                value: -100,
                converter: "float",
                onchanged: _this._onFarAttrChanged.bind(_this)
            }
        });
        _this.on("update-scene-object", function (obj) {
            _this._onLeftAttrChanged.call(_this, _this.attributes.getAttribute("left"));
            _this._onRightAttrChanged.call(_this, _this.attributes.getAttribute("right"));
            _this._onBottomAttrChanged.call(_this, _this.attributes.getAttribute("bottom"));
            _this._onTopAttrChanged.call(_this, _this.attributes.getAttribute("top"));
            _this._onNearAttrChanged.call(_this, _this.attributes.getAttribute("near"));
            _this._onFarAttrChanged.call(_this, _this.attributes.getAttribute("far"));
        });
        return _this;
    }

    _createClass(OrthoCameraNode, [{
        key: "__constructCamera",
        value: function __constructCamera() {
            return new _OrthoCamera2.default();
        }
    }, {
        key: "_onLeftAttrChanged",
        value: function _onLeftAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.Left = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onRightAttrChanged",
        value: function _onRightAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.Right = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onBottomAttrChanged",
        value: function _onBottomAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.Bottom = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onTopAttrChanged",
        value: function _onTopAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.Top = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onNearAttrChanged",
        value: function _onNearAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.Near = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onFarAttrChanged",
        value: function _onFarAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.Far = attr.Value;
                attr.done();
            }
        }
    }]);

    return OrthoCameraNode;
}(_CameraNodeBase3.default);

exports.default = OrthoCameraNode;

},{"../../../../Core/SceneObjects/Camera/OrthoCamera":141,"./CameraNodeBase":203}],205:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AreaLight = require("../../../../Core/SceneObjects/Light/Impl/AreaLight");

var _AreaLight2 = _interopRequireDefault(_AreaLight);

var _LightNodeBase2 = require("./LightNodeBase");

var _LightNodeBase3 = _interopRequireDefault(_LightNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AreaLightNode = function (_LightNodeBase) {
    _inherits(AreaLightNode, _LightNodeBase);

    function AreaLightNode() {
        _classCallCheck(this, AreaLightNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AreaLightNode).call(this));

        _this.attributes.defineAttribute({
            "intensity": {
                value: 1,
                converter: "float",
                onchanged: _this._onIntensityAttrChanged.bind(_this)
            }
        });
        _this.on("update-scene-object", function (obj) {
            _this._onIntensityAttrChanged.call(_this, _this.attributes.getAttribute("intensity"));
        });
        return _this;
    }

    _createClass(AreaLightNode, [{
        key: "__constructLight",
        value: function __constructLight() {
            return new _AreaLight2.default();
        }
    }, {
        key: "_onIntensityAttrChanged",
        value: function _onIntensityAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.intensity = attr.Value;
                attr.done();
            }
        }
    }]);

    return AreaLightNode;
}(_LightNodeBase3.default);

exports.default = AreaLightNode;

},{"../../../../Core/SceneObjects/Light/Impl/AreaLight":144,"./LightNodeBase":207}],206:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DirectionalLight = require("../../../../Core/SceneObjects/Light/Impl/DirectionalLight");

var _DirectionalLight2 = _interopRequireDefault(_DirectionalLight);

var _LightNodeBase2 = require("./LightNodeBase");

var _LightNodeBase3 = _interopRequireDefault(_LightNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DirectionalLightNode = function (_LightNodeBase) {
    _inherits(DirectionalLightNode, _LightNodeBase);

    function DirectionalLightNode() {
        _classCallCheck(this, DirectionalLightNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DirectionalLightNode).call(this));

        _this.attributes.defineAttribute({
            "intensity": {
                value: 1,
                converter: "float",
                onchanged: _this._onIntensityAttrChanged.bind(_this)
            },
            "bias": {
                value: 0.01,
                converter: "float",
                onchanged: _this._onBiasAttrChanged.bind(_this)
            }
        });
        _this.on("update-scene-object", function (obj) {
            _this._onIntensityAttrChanged.call(_this, _this.attributes.getAttribute("intensity"));
            _this._onBiasAttrChanged.call(_this, _this.attributes.getAttribute("bias"));
        });
        return _this;
    }

    _createClass(DirectionalLightNode, [{
        key: "__constructLight",
        value: function __constructLight() {
            return new _DirectionalLight2.default();
        }
    }, {
        key: "_onIntensityAttrChanged",
        value: function _onIntensityAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.intensity = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onBiasAttrChanged",
        value: function _onBiasAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.bias = attr.Value;
                attr.done();
            }
        }
    }]);

    return DirectionalLightNode;
}(_LightNodeBase3.default);

exports.default = DirectionalLightNode;

},{"../../../../Core/SceneObjects/Light/Impl/DirectionalLight":145,"./LightNodeBase":207}],207:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SceneObjectNodeBase2 = require("../SceneObjectNodeBase");

var _SceneObjectNodeBase3 = _interopRequireDefault(_SceneObjectNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LightNodeBase = function (_SceneObjectNodeBase) {
    _inherits(LightNodeBase, _SceneObjectNodeBase);

    function LightNodeBase() {
        _classCallCheck(this, LightNodeBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LightNodeBase).call(this));

        _this.attributes.defineAttribute({
            "color": {
                value: "white",
                converter: "color3",
                onchanged: _this._onColorAttrChanged.bind(_this)
            }
        });
        _this.on("update-scene-object", function (obj) {
            _this._onColorAttrChanged.call(_this, _this.attributes.getAttribute("color"));
        });
        return _this;
    }
    /**
     * Construct target light object when this method was called.
    * This method should be overridden.
     */


    _createClass(LightNodeBase, [{
        key: "__constructLight",
        value: function __constructLight() {
            return null;
        }
    }, {
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(LightNodeBase.prototype), "__onMount", this).call(this);
            this.TargetSceneObject = this.__constructLight();
        }
    }, {
        key: "_onColorAttrChanged",
        value: function _onColorAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.Color = attr.Value;
                attr.done();
            }
        }
    }]);

    return LightNodeBase;
}(_SceneObjectNodeBase3.default);

exports.default = LightNodeBase;

},{"../SceneObjectNodeBase":213}],208:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _LightNodeBase2 = require("./LightNodeBase");

var _LightNodeBase3 = _interopRequireDefault(_LightNodeBase2);

var _PointLight = require("../../../../Core/SceneObjects/Light/Impl/PointLight");

var _PointLight2 = _interopRequireDefault(_PointLight);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PointLightNode = function (_LightNodeBase) {
    _inherits(PointLightNode, _LightNodeBase);

    function PointLightNode() {
        _classCallCheck(this, PointLightNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PointLightNode).call(this));

        _this.attributes.defineAttribute({
            "intensity": {
                value: 1,
                converter: "float",
                onchanged: _this._onIntensityAttrChanged.bind(_this)
            },
            "decay": {
                value: 1,
                converter: "float",
                onchanged: _this._onDecayAttrChanged.bind(_this)
            },
            "distance": {
                value: 1,
                converter: "float",
                onchanged: _this._onDistanceAttrChanged.bind(_this)
            }
        });
        _this.on("update-scene-object", function (obj) {
            _this._onIntensityAttrChanged.call(_this, _this.attributes.getAttribute("intensity"));
            _this._onDecayAttrChanged.call(_this, _this.attributes.getAttribute("decay"));
            _this._onDistanceAttrChanged.call(_this, _this.attributes.getAttribute("distance"));
        });
        return _this;
    }

    _createClass(PointLightNode, [{
        key: "__constructLight",
        value: function __constructLight() {
            return new _PointLight2.default();
        }
    }, {
        key: "_onIntensityAttrChanged",
        value: function _onIntensityAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.intensity = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onDecayAttrChanged",
        value: function _onDecayAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.decay = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onDistanceAttrChanged",
        value: function _onDistanceAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.distance = attr.Value;
                attr.done();
            }
        }
    }]);

    return PointLightNode;
}(_LightNodeBase3.default);

exports.default = PointLightNode;

},{"../../../../Core/SceneObjects/Light/Impl/PointLight":146,"./LightNodeBase":207}],209:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _LightNodeBase2 = require("./LightNodeBase");

var _LightNodeBase3 = _interopRequireDefault(_LightNodeBase2);

var _SceneLight = require("../../../../Core/SceneObjects/Light/Impl/SceneLight");

var _SceneLight2 = _interopRequireDefault(_SceneLight);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SceneLightNode = function (_LightNodeBase) {
    _inherits(SceneLightNode, _LightNodeBase);

    function SceneLightNode() {
        _classCallCheck(this, SceneLightNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SceneLightNode).call(this));

        _this.attributes.defineAttribute({
            "intensity": {
                value: 1,
                converter: "float",
                onchanged: _this._onIntensityAttrChanged.bind(_this)
            }
        });
        _this.on("update-scene-object", function (obj) {
            _this._onIntensityAttrChanged.call(_this, _this.attributes.getAttribute("intensity"));
        });
        return _this;
    }

    _createClass(SceneLightNode, [{
        key: "__constructLight",
        value: function __constructLight() {
            return new _SceneLight2.default();
        }
    }, {
        key: "_onIntensityAttrChanged",
        value: function _onIntensityAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.intensity = attr.Value;
                attr.done();
            }
        }
    }]);

    return SceneLightNode;
}(_LightNodeBase3.default);

exports.default = SceneLightNode;

},{"../../../../Core/SceneObjects/Light/Impl/SceneLight":147,"./LightNodeBase":207}],210:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SpotLight = require("../../../../Core/SceneObjects/Light/Impl/SpotLight");

var _SpotLight2 = _interopRequireDefault(_SpotLight);

var _LightNodeBase2 = require("./LightNodeBase");

var _LightNodeBase3 = _interopRequireDefault(_LightNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SpotLightNode = function (_LightNodeBase) {
    _inherits(SpotLightNode, _LightNodeBase);

    function SpotLightNode() {
        _classCallCheck(this, SpotLightNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SpotLightNode).call(this));

        _this.attributes.defineAttribute({
            "intensity": {
                value: 1,
                converter: "float",
                onchanged: _this._onIntensityAttrChanged.bind(_this)
            },
            "innerAngle": {
                value: 0.2,
                converter: "angle",
                onchanged: _this._onInnerAngleAttrChanged.bind(_this)
            },
            "outerAngle": {
                value: 0.5,
                converter: "angle",
                onchanged: _this._onOuterAngleAttrChanged.bind(_this)
            },
            "innerDistance": {
                value: 4,
                converter: "float",
                onchanged: _this._onInnerDistanceAttrChanged.bind(_this)
            },
            "outerDistance": {
                value: 15,
                converter: "float",
                onchanged: _this._onOuterDistanceAttrChanged.bind(_this)
            },
            "distanceDecay": {
                value: 1,
                converter: "float",
                onchanged: _this._onDistanceDecayAttrChanged.bind(_this)
            },
            "angleDecay": {
                value: 1,
                converter: "float",
                onchanged: _this._onAngleDecayAttrChanged.bind(_this)
            }
        });
        _this.on("update-scene-object", function (obj) {
            _this._onIntensityAttrChanged.call(_this, _this.attributes.getAttribute("intensity"));
            _this._onInnerAngleAttrChanged.call(_this, _this.attributes.getAttribute("innerAngle"));
            _this._onOuterAngleAttrChanged.call(_this, _this.attributes.getAttribute("outerAngle"));
            _this._onInnerDistanceAttrChanged.call(_this, _this.attributes.getAttribute("innerDistance"));
            _this._onOuterDistanceAttrChanged.call(_this, _this.attributes.getAttribute("outerDistance"));
            _this._onDistanceDecayAttrChanged.call(_this, _this.attributes.getAttribute("distanceDecay"));
            _this._onAngleDecayAttrChanged.call(_this, _this.attributes.getAttribute("angleDecay"));
        });
        return _this;
    }

    _createClass(SpotLightNode, [{
        key: "__constructLight",
        value: function __constructLight() {
            return new _SpotLight2.default();
        }
    }, {
        key: "_onIntensityAttrChanged",
        value: function _onIntensityAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.intensity = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onInnerAngleAttrChanged",
        value: function _onInnerAngleAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.innerAngle = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onOuterAngleAttrChanged",
        value: function _onOuterAngleAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.outerAngle = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onInnerDistanceAttrChanged",
        value: function _onInnerDistanceAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.innerDistance = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onOuterDistanceAttrChanged",
        value: function _onOuterDistanceAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.outerDistance = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onDistanceDecayAttrChanged",
        value: function _onDistanceDecayAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.distanceDecay = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onAngleDecayAttrChanged",
        value: function _onAngleDecayAttrChanged(attr) {
            if (this.TargetSceneObject) {
                this.TargetSceneObject.angleDecay = attr.Value;
                attr.done();
            }
        }
    }]);

    return SpotLightNode;
}(_LightNodeBase3.default);

exports.default = SpotLightNode;

},{"../../../../Core/SceneObjects/Light/Impl/SpotLight":148,"./LightNodeBase":207}],211:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SceneObjectNodeBase2 = require("./SceneObjectNodeBase");

var _SceneObjectNodeBase3 = _interopRequireDefault(_SceneObjectNodeBase2);

var _BasicMeshObject = require("../../../Core/SceneObjects/BasicMeshObject");

var _BasicMeshObject2 = _interopRequireDefault(_BasicMeshObject);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeshNode = function (_SceneObjectNodeBase) {
    _inherits(MeshNode, _SceneObjectNodeBase);

    function MeshNode() {
        _classCallCheck(this, MeshNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MeshNode).call(this));

        _this._geo = null;
        _this._mat = null;
        /**
         * Geomatry instance
         * @type {Geometry}
         */
        _this._geo_instance = null;
        /**
         * Material instance
         */
        _this._mat_instance = null;
        _this.attributes.defineAttribute({
            "geo": {
                value: undefined,
                converter: "string",
                onchanged: _this._onGeoAttrChanged.bind(_this)
            },
            "mat": {
                value: undefined,
                converter: "string",
                onchanged: _this._onMatAttrChanged.bind(_this)
            }
        });
        return _this;
    }

    _createClass(MeshNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(MeshNode.prototype), "__onMount", this).call(this);
        }
        /**
         * Called when geo attribute is changed
         * @param {GomlAttribute} attr [description]
         */

    }, {
        key: "_onGeoAttrChanged",
        value: function _onGeoAttrChanged(attr) {
            var _this2 = this;

            this._geo = attr.Value;
            this._geo_instance = null;
            // console.warn("onGeoAttrChanged", attr.Value);
            this._geo_instance = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.PrimitiveRegistory).getPrimitive(this._geo);
            if (this._geo_instance) {
                // console.log("primitive exist", this._geo);
                this._updateTarget();
                attr.done();
            } else {
                // console.log("primitive not exist", this._geo);
                this._geo_instance = null;
                this.nodeImport("jthree.resource.geometry", this._geo, function (geo) {
                    if (geo) {
                        // console.log("geometry reseived", this._geo);
                        _this2._geo_instance = geo.target;
                    } else {
                        _this2._geo_instance = null;
                    }
                    _this2._updateTarget();
                    attr.done();
                });
            }
        }
        /**
         * Called when mat attribute is changed
         * @param {GomlAttribute} attr [description]
         */

    }, {
        key: "_onMatAttrChanged",
        value: function _onMatAttrChanged(attr) {
            var _this3 = this;

            this._mat = attr.Value;
            this._mat_instance = null;
            // console.warn("onMatAttrChanged", attr.Value);
            this.nodeImport("jthree.resource.material", this._mat, function (mat) {
                // console.info("material was updated");
                if (mat) {
                    _this3._mat_instance = mat.target;
                } else {
                    _this3._mat_instance = null;
                }
                _this3._updateTarget();
                attr.done();
            });
        }
    }, {
        key: "_updateTarget",
        value: function _updateTarget() {
            // console.info(this._geo_instance, this._mat_instance);
            if (this._geo_instance && this._mat_instance) {
                // console.info("target was updated");
                this.TargetSceneObject = new _BasicMeshObject2.default(this._geo_instance, this._mat_instance);
            }
        }
    }]);

    return MeshNode;
}(_SceneObjectNodeBase3.default);

exports.default = MeshNode;

},{"../../../ContextComponents":8,"../../../Core/SceneObjects/BasicMeshObject":139,"../../../JThreeContext":267,"./SceneObjectNodeBase":213}],212:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SceneObjectNodeBase2 = require("./SceneObjectNodeBase");

var _SceneObjectNodeBase3 = _interopRequireDefault(_SceneObjectNodeBase2);

var _SceneObject = require("../../../Core/SceneObjects/SceneObject");

var _SceneObject2 = _interopRequireDefault(_SceneObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// import GomlParser from "../../GomlParser.ts";

var ObjectNode = function (_SceneObjectNodeBase) {
    _inherits(ObjectNode, _SceneObjectNodeBase);

    // private targetTemplate: TemplateNode;

    function ObjectNode() {
        _classCallCheck(this, ObjectNode);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ObjectNode).call(this));
        // TODO: pnly
        // var templateName=elem.getAttribute("template");
        // if(templateName)
        // {
        //   this.targetTemplate=<TemplateNode>this.nodeManager.nodeRegister.getObject("jthree.template",templateName);
        // GomlParser.instanciateTemplate(this.targetTemplate.GetGomlToInstanciate(this.element),this);
        // }
    }

    _createClass(ObjectNode, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(ObjectNode.prototype), "__onMount", this).call(this);
            this.TargetSceneObject = new _SceneObject2.default();
        }
    }]);

    return ObjectNode;
}(_SceneObjectNodeBase3.default);

exports.default = ObjectNode;

},{"../../../Core/SceneObjects/SceneObject":151,"./SceneObjectNodeBase":213}],213:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CoreRelatedNodeBase2 = require("../../CoreRelatedNodeBase");

var _CoreRelatedNodeBase3 = _interopRequireDefault(_CoreRelatedNodeBase2);

var _Vector = require("../../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _Quaternion = require("../../../Math/Quaternion");

var _Quaternion2 = _interopRequireDefault(_Quaternion);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SceneObjectNodeBase = function (_CoreRelatedNodeBase) {
    _inherits(SceneObjectNodeBase, _CoreRelatedNodeBase);

    function SceneObjectNodeBase() {
        _classCallCheck(this, SceneObjectNodeBase);

        /**
        * SceneObjectNode directly containing this node
        */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SceneObjectNodeBase).call(this));

        _this._parentSceneObjectNode = null;
        /**
        * SceneNode containing this node
        */
        _this._containedSceneNode = null;
        _this.attributes.defineAttribute({
            "position": {
                value: new _Vector2.default(0, 0, 0),
                converter: "vec3",
                onchanged: _this._onPositionAttrChanged__SceneObjectNodeBase.bind(_this)
            },
            "scale": {
                value: new _Vector2.default(1, 1, 1),
                converter: "vec3",
                onchanged: _this._onScaleAttrChanged__SceneObjectNodeBase.bind(_this)
            },
            "rotation": {
                value: _Quaternion2.default.Identity,
                converter: "rotation",
                onchanged: _this._onRotationAttrChanged__SceneObjectNodeBase.bind(_this)
            },
            "name": {
                value: void 0,
                converter: "string",
                onchanged: _this._onNameAttrChanged__SceneObjectNodeBase.bind(_this)
            }
        });
        _this.on("update-scene-object", function (obj) {
            _this._onPositionAttrChanged__SceneObjectNodeBase.call(_this, _this.attributes.getAttribute("position"));
            _this._onScaleAttrChanged__SceneObjectNodeBase.call(_this, _this.attributes.getAttribute("scale"));
            _this._onRotationAttrChanged__SceneObjectNodeBase.call(_this, _this.attributes.getAttribute("rotation"));
            _this._onNameAttrChanged__SceneObjectNodeBase.call(_this, _this.attributes.getAttribute("name"));
        });
        return _this;
    }

    _createClass(SceneObjectNodeBase, [{
        key: "__onMount",
        value: function __onMount() {
            _get(Object.getPrototypeOf(SceneObjectNodeBase.prototype), "__onMount", this).call(this);
            var containedSceneNode = null;
            var parentSceneObjectNode = null;
            // This parent node is scene node.
            if (this.__parent.getTypeName() === "SceneNode") {
                containedSceneNode = this.__parent;
                parentSceneObjectNode = null;
            } else {
                // check parent extends SceneObjectNodeBase or not.
                if (typeof this.__parent.ContainedSceneNode === "undefined") {
                    console.error(this.__parent.toString() + " is not extends SceneObjectNodeBase. Is this really ok to be contained in Scene tag?");
                    return;
                } else {
                    parentSceneObjectNode = this.__parent;
                    containedSceneNode = parentSceneObjectNode.ContainedSceneNode;
                }
            }
            this._containedSceneNode = containedSceneNode;
            this._parentSceneObjectNode = parentSceneObjectNode;
        }
    }, {
        key: "__onUnmount",
        value: function __onUnmount() {
            _get(Object.getPrototypeOf(SceneObjectNodeBase.prototype), "__onUnmount", this).call(this);
            this.TargetSceneObject = null;
        }
    }, {
        key: "_onPositionAttrChanged__SceneObjectNodeBase",
        value: function _onPositionAttrChanged__SceneObjectNodeBase(attr) {
            if (this.target) {
                this.target.Transformer.Position = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onScaleAttrChanged__SceneObjectNodeBase",
        value: function _onScaleAttrChanged__SceneObjectNodeBase(attr) {
            if (this.target) {
                this.target.Transformer.Scale = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onRotationAttrChanged__SceneObjectNodeBase",
        value: function _onRotationAttrChanged__SceneObjectNodeBase(attr) {
            if (this.target) {
                this.target.Transformer.Rotation = attr.Value;
                attr.done();
            }
        }
    }, {
        key: "_onNameAttrChanged__SceneObjectNodeBase",
        value: function _onNameAttrChanged__SceneObjectNodeBase(attr) {
            if (this.target) {
                this.target.name = attr.Value;
                attr.done();
            }
        }
        /**
         * update SceneObject child. using this.target to access previous object, so do not change it before call this method.
         * @param {SceneObject} obj [description]
         */

    }, {
        key: "_updateSceneObjectChild",
        value: function _updateSceneObjectChild(obj) {
            if (typeof obj === "undefined") {
                console.error(this.getTypeName() + ": sceneObject is undefined. It must be null or instance.");
                obj = null;
            }
            // previous object is exist in child, remove child
            if (this.target !== null) {
                if (this._parentSceneObjectNode === null) {
                    this._containedSceneNode.target.removeObject(this.target);
                } else {
                    if (this._parentSceneObjectNode.TargetSceneObject === null) {
                        throw new Error("Something fatal occured. Parent scene object is lost.");
                    }
                    this._parentSceneObjectNode.TargetSceneObject.removeChild(this.target);
                }
            }
            // if obj is not null, insert obj. if null, do nothing.
            if (obj !== null) {
                if (this._parentSceneObjectNode === null) {
                    this._containedSceneNode.target.addObject(obj, this.index);
                } else {
                    if (this._parentSceneObjectNode.TargetSceneObject === null) {
                        throw new Error("Something fatal occured. Parent scene object is lost.");
                    }
                    this._parentSceneObjectNode.TargetSceneObject.addChild(obj, this.index);
                }
            }
        }
        /**
         * Change the SceneObject that is applied to Scene Hierarchy.
         * @param {SceneObject} obj [description]
         */

    }, {
        key: "ParentSceneObjectNode",
        get: function get() {
            return this._parentSceneObjectNode;
        }
    }, {
        key: "ContainedSceneNode",
        get: function get() {
            return this._containedSceneNode;
        }
    }, {
        key: "TargetSceneObject",
        set: function set(obj) {
            this._updateSceneObjectChild(obj);
            this.target = obj;
            this.target.relatedNode = this; // TODO: pnly consider GC.
            this.emit("update-scene-object", this.target);
        }
        /**
         * Get the SceneObject that is applied to Scene Hierarchy.
         * @return {SceneObject} [description]
         */
        ,
        get: function get() {
            return this.target;
        }
    }]);

    return SceneObjectNodeBase;
}(_CoreRelatedNodeBase3.default);

exports.default = SceneObjectNodeBase;

},{"../../../Math/Quaternion":275,"../../../Math/Vector3":278,"../../CoreRelatedNodeBase":174}],214:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GomlTreeNodeBase2 = require("../../GomlTreeNodeBase");

var _GomlTreeNodeBase3 = _interopRequireDefault(_GomlTreeNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TemplateNode = function (_GomlTreeNodeBase) {
    _inherits(TemplateNode, _GomlTreeNodeBase);

    function TemplateNode() {
        _classCallCheck(this, TemplateNode);

        // private static parentIgnore: string[] = ["template"];
        // private static templateIgnore: string[] = ["name"];

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TemplateNode).call(this));

        _this._templateGoml = "";
        // var name=elem.getAttribute("name");
        // if(name)
        // {
        //   this.nodeManager.nodeRegister.addObject("jthree.template",name,this);
        //   this.templateGoml=elem.innerHTML;
        // }else{
        //   console.error("template tag should be specified name.")
        // }
        return _this;
    }

    _createClass(TemplateNode, [{
        key: "getGomlToInstanciate",
        value: function getGomlToInstanciate(instanciateParent) {
            // var valueMap:{[key:string]:string}={};
            // var templateAttributes=this.element.attributes;
            // for (var i = 0; i < templateAttributes.length; i++) {
            //   var attribute = templateAttributes.item(i);
            //   if(TemplateNode.templateIgnore.indexOf(attribute.name)===-1)
            //   {
            //     valueMap[attribute.name]=attribute.value;
            //   }
            // }
            // var instanciateParentAttributes=instanciateParent.attributes;
            // for (var i = 0; i < instanciateParentAttributes.length; i++) {
            //   var attribute = instanciateParentAttributes.item(i);
            //   if(TemplateNode.parentIgnore.indexOf(attribute.name)===-1)
            //   {
            //     valueMap[attribute.name]=attribute.value;
            //   }
            // }
            // var replaceTarget:string = this.TemplateGoml;
            // for(var replaceKey in valueMap)
            // {
            //   var value = valueMap[replaceKey];
            //   replaceTarget=replaceTarget.replace(`{{${replaceKey}}}`,value);
            // }
            // return replaceTarget;
            return "";
        }
    }, {
        key: "TemplateGoml",
        get: function get() {
            return this._templateGoml;
        }
    }]);

    return TemplateNode;
}(_GomlTreeNodeBase3.default);

exports.default = TemplateNode;

},{"../../GomlTreeNodeBase":183}],215:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _TextureNodeBase2 = require("./TextureNodeBase");

var _TextureNodeBase3 = _interopRequireDefault(_TextureNodeBase2);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Cube texture resource node.
 */

var CubeTextureNode = function (_TextureNodeBase) {
    _inherits(CubeTextureNode, _TextureNodeBase);

    function CubeTextureNode() {
        _classCallCheck(this, CubeTextureNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CubeTextureNode).call(this));

        _this.__groupPrefix = "TextureCube";
        _this.attributes.defineAttribute({
            srcs: {
                // this src should be passed by splitted with ' '(space).
                // src urls should be arranged in the layout below.
                // PositiveX NegativeX PositiveY NegativeY PositiveZ NegativeZ
                converter: "string",
                src: undefined,
                constant: true
            }
        });
        return _this;
    }

    _createClass(CubeTextureNode, [{
        key: "__constructTexture",
        value: function __constructTexture(name, rm) {
            var deferred = _q2.default.defer();
            var srcsv = this.attributes.getValue("srcs");
            if (srcsv) {
                var srcs = srcsv.split(" ");
                rm.loadCubeTexture(srcs).then(function (texture) {
                    deferred.resolve(texture);
                });
            } else {
                process.nextTick(function () {
                    deferred.resolve(null);
                });
            }
            return deferred.promise;
        }
    }]);

    return CubeTextureNode;
}(_TextureNodeBase3.default);

exports.default = CubeTextureNode;

}).call(this,require('_process'))

},{"./TextureNodeBase":217,"_process":319,"q":338}],216:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ImageLoader = require("../../../Core/Resources/ImageLoader");

var _ImageLoader2 = _interopRequireDefault(_ImageLoader);

var _TextureNodeBase2 = require("./TextureNodeBase");

var _TextureNodeBase3 = _interopRequireDefault(_TextureNodeBase2);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Basic 2d texture resource node.
 */

var TextureNode = function (_TextureNodeBase) {
    _inherits(TextureNode, _TextureNodeBase);

    function TextureNode() {
        _classCallCheck(this, TextureNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TextureNode).call(this));

        _this.__groupPrefix = "Texture2D";
        _this.attributes.defineAttribute({
            src: {
                converter: "string",
                src: undefined,
                onchanged: _this._onSrcAttrChanged.bind(_this)
            }
        });
        _this.on("update-target", function (obj) {
            _this._onSrcAttrChanged.call(_this, _this.attributes.getAttribute("src"));
        });
        return _this;
    }

    _createClass(TextureNode, [{
        key: "__constructTexture",
        value: function __constructTexture(name, rm) {
            var deferred = _q2.default.defer();
            if (this.attributes.getValue("src")) {
                rm.loadTexture(this.attributes.getValue("src")).then(function (texture) {
                    deferred.resolve(texture);
                });
            } else {
                process.nextTick(function () {
                    deferred.resolve(null);
                });
            }
            return deferred.promise;
        }
    }, {
        key: "_onSrcAttrChanged",
        value: function _onSrcAttrChanged(attr) {
            var _this2 = this;

            if (this.target) {
                _ImageLoader2.default.loadImage(attr.Value).then(function (imgTag) {
                    _this2.target.ImageSource = imgTag;
                });
                attr.done();
            }
        }
    }]);

    return TextureNode;
}(_TextureNodeBase3.default);

exports.default = TextureNode;

}).call(this,require('_process'))

},{"../../../Core/Resources/ImageLoader":119,"./TextureNodeBase":217,"_process":319,"q":338}],217:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CoreRelatedNodeBase2 = require("../../CoreRelatedNodeBase");

var _CoreRelatedNodeBase3 = _interopRequireDefault(_CoreRelatedNodeBase2);

var _GLEnumParser = require("../../../Core/Canvas/GL/GLEnumParser");

var _GLEnumParser2 = _interopRequireDefault(_GLEnumParser);

var _JThreeContext = require("../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * All texture resource node class inherit this class.
 */

var TextureNodeBase = function (_CoreRelatedNodeBase) {
    _inherits(TextureNodeBase, _CoreRelatedNodeBase);

    function TextureNodeBase() {
        _classCallCheck(this, TextureNodeBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TextureNodeBase).call(this));

        _this.attributes.defineAttribute({
            name: {
                value: undefined,
                converter: "string",
                constant: true
            },
            minFilter: {
                value: "LINEAR",
                converter: "string",
                onchanged: function onchanged(attr) {
                    if (_this.target) {
                        _this.target.MinFilter = _GLEnumParser2.default.parseTextureMinFilter(attr.Value);
                        attr.done();
                    }
                }
            },
            magFilter: {
                value: "LINEAR",
                converter: "string",
                onchanged: function onchanged(attr) {
                    if (_this.target) {
                        _this.target.MagFilter = _GLEnumParser2.default.parseTextureMagFilter(attr.Value);
                        attr.done();
                    }
                }
            },
            twrap: {
                value: "CLAMP_TO_EDGE",
                converter: "string",
                onchanged: function onchanged(attr) {
                    if (_this.target) {
                        _this.target.TWrap = _GLEnumParser2.default.parseTextureWrapMode(attr.Value);
                        attr.done();
                    }
                }
            },
            swrap: {
                value: "CLAMP_TO_EDGE",
                converter: "string",
                onchanged: function onchanged(attr) {
                    if (_this.target) {
                        _this.target.SWrap = _GLEnumParser2.default.parseTextureWrapMode(attr.Value);
                        attr.done();
                    }
                }
            }
        });
        _this.on("update-target", function (obj) {
            _this._onMinFilterAttrChanged.call(_this, _this.attributes.getAttribute("minFilter"));
            _this._onMagFilterAttrChanged.call(_this, _this.attributes.getAttribute("magFilter"));
            _this._onTWrapAttrChanged.call(_this, _this.attributes.getAttribute("twrap"));
            _this._onSWrapAttrChanged.call(_this, _this.attributes.getAttribute("swrap"));
        });
        return _this;
    }

    _createClass(TextureNodeBase, [{
        key: "__onMount",
        value: function __onMount() {
            var _this2 = this;

            _get(Object.getPrototypeOf(TextureNodeBase.prototype), "__onMount", this).call(this);
            var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
            var name = this.attributes.getValue("name");
            this.__constructTexture(name, rm).then(function (texture) {
                _this2.target = texture;
                _this2.emit("update-target", _this2.target);
                _this2.nodeExport(name);
            });
        }
    }, {
        key: "_onMinFilterAttrChanged",
        value: function _onMinFilterAttrChanged(attr) {
            if (this.target) {
                this.target.MinFilter = _GLEnumParser2.default.parseTextureMinFilter(attr.Value);
                attr.done();
            }
        }
    }, {
        key: "_onMagFilterAttrChanged",
        value: function _onMagFilterAttrChanged(attr) {
            if (this.target) {
                this.target.MagFilter = _GLEnumParser2.default.parseTextureMagFilter(attr.Value);
                attr.done();
            }
        }
    }, {
        key: "_onTWrapAttrChanged",
        value: function _onTWrapAttrChanged(attr) {
            if (this.target) {
                this.target.TWrap = _GLEnumParser2.default.parseTextureWrapMode(attr.Value);
                attr.done();
            }
        }
    }, {
        key: "_onSWrapAttrChanged",
        value: function _onSWrapAttrChanged(attr) {
            if (this.target) {
                this.target.SWrap = _GLEnumParser2.default.parseTextureWrapMode(attr.Value);
                attr.done();
            }
        }
    }]);

    return TextureNodeBase;
}(_CoreRelatedNodeBase3.default);

exports.default = TextureNodeBase;

},{"../../../ContextComponents":8,"../../../Core/Canvas/GL/GLEnumParser":19,"../../../JThreeContext":267,"../../CoreRelatedNodeBase":174}],218:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _OrderedTopLevelNodeBase = require("./OrderedTopLevelNodeBase");

var _OrderedTopLevelNodeBase2 = _interopRequireDefault(_OrderedTopLevelNodeBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CanvasesNode = function (_OrderedTopLevelNodeB) {
    _inherits(CanvasesNode, _OrderedTopLevelNodeB);

    function CanvasesNode() {
        _classCallCheck(this, CanvasesNode);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(CanvasesNode).call(this));
    }

    _createClass(CanvasesNode, [{
        key: "loadPriorty",
        get: function get() {
            return 2000;
        }
    }]);

    return CanvasesNode;
}(_OrderedTopLevelNodeBase2.default);

exports.default = CanvasesNode;

},{"./OrderedTopLevelNodeBase":222}],219:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GomlTreeNodeBase2 = require("../../GomlTreeNodeBase");

var _GomlTreeNodeBase3 = _interopRequireDefault(_GomlTreeNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GomlNode = function (_GomlTreeNodeBase) {
    _inherits(GomlNode, _GomlTreeNodeBase);

    function GomlNode() {
        _classCallCheck(this, GomlNode);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(GomlNode).call(this));
    }
    /**
     * Add child to this node
     */


    _createClass(GomlNode, [{
        key: "addChild",
        value: function addChild(child) {
            _get(Object.getPrototypeOf(GomlNode.prototype), "addChild", this).call(this, child);
            this.__children.sort(function (n1, n2) {
                return n1.loadPriorty - n2.loadPriorty;
            });
        }
    }]);

    return GomlNode;
}(_GomlTreeNodeBase3.default);

exports.default = GomlNode;

},{"../../GomlTreeNodeBase":183}],220:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _OrderedTopLevelNodeBase = require("./OrderedTopLevelNodeBase");

var _OrderedTopLevelNodeBase2 = _interopRequireDefault(_OrderedTopLevelNodeBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CanvasesNode = function (_OrderedTopLevelNodeB) {
    _inherits(CanvasesNode, _OrderedTopLevelNodeB);

    function CanvasesNode() {
        _classCallCheck(this, CanvasesNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CanvasesNode).call(this));

        _this.__groupPrefix = "import";
        return _this;
    }

    _createClass(CanvasesNode, [{
        key: "loadPriorty",
        get: function get() {
            return 0;
        }
    }]);

    return CanvasesNode;
}(_OrderedTopLevelNodeBase2.default);

exports.default = CanvasesNode;

},{"./OrderedTopLevelNodeBase":222}],221:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _OrderedTopLevelNodeBase = require("./OrderedTopLevelNodeBase");

var _OrderedTopLevelNodeBase2 = _interopRequireDefault(_OrderedTopLevelNodeBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LoadersNode = function (_OrderedTopLevelNodeB) {
    _inherits(LoadersNode, _OrderedTopLevelNodeB);

    function LoadersNode() {
        _classCallCheck(this, LoadersNode);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(LoadersNode).call(this));
    }

    _createClass(LoadersNode, [{
        key: "loadPriorty",
        get: function get() {
            return 1000;
        }
    }]);

    return LoadersNode;
}(_OrderedTopLevelNodeBase2.default);

exports.default = LoadersNode;

},{"./OrderedTopLevelNodeBase":222}],222:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GomlTreeNodeBase2 = require("../../GomlTreeNodeBase");

var _GomlTreeNodeBase3 = _interopRequireDefault(_GomlTreeNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OrderedTopLevelNodeBase = function (_GomlTreeNodeBase) {
    _inherits(OrderedTopLevelNodeBase, _GomlTreeNodeBase);

    function OrderedTopLevelNodeBase() {
        _classCallCheck(this, OrderedTopLevelNodeBase);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(OrderedTopLevelNodeBase).call(this));
    }

    _createClass(OrderedTopLevelNodeBase, [{
        key: "loadPriorty",
        get: function get() {
            return 0;
        }
    }]);

    return OrderedTopLevelNodeBase;
}(_GomlTreeNodeBase3.default);

exports.default = OrderedTopLevelNodeBase;

},{"../../GomlTreeNodeBase":183}],223:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _OrderedTopLevelNodeBase = require("./OrderedTopLevelNodeBase");

var _OrderedTopLevelNodeBase2 = _interopRequireDefault(_OrderedTopLevelNodeBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ResourcesNode = function (_OrderedTopLevelNodeB) {
    _inherits(ResourcesNode, _OrderedTopLevelNodeB);

    function ResourcesNode() {
        _classCallCheck(this, ResourcesNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ResourcesNode).call(this));

        _this.__groupPrefix = "resource";
        return _this;
    }

    _createClass(ResourcesNode, [{
        key: "loadPriorty",
        get: function get() {
            return 3000;
        }
    }]);

    return ResourcesNode;
}(_OrderedTopLevelNodeBase2.default);

exports.default = ResourcesNode;

},{"./OrderedTopLevelNodeBase":222}],224:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _OrderedTopLevelNodeBase = require("./OrderedTopLevelNodeBase");

var _OrderedTopLevelNodeBase2 = _interopRequireDefault(_OrderedTopLevelNodeBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ScenesNode = function (_OrderedTopLevelNodeB) {
    _inherits(ScenesNode, _OrderedTopLevelNodeB);

    function ScenesNode() {
        _classCallCheck(this, ScenesNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ScenesNode).call(this));

        _this.__groupPrefix = "scene";
        return _this;
    }

    _createClass(ScenesNode, [{
        key: "loadPriorty",
        get: function get() {
            return 5000;
        }
    }]);

    return ScenesNode;
}(_OrderedTopLevelNodeBase2.default);

exports.default = ScenesNode;

},{"./OrderedTopLevelNodeBase":222}],225:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _OrderedTopLevelNodeBase = require("./OrderedTopLevelNodeBase");

var _OrderedTopLevelNodeBase2 = _interopRequireDefault(_OrderedTopLevelNodeBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TemplatesNode = function (_OrderedTopLevelNodeB) {
    _inherits(TemplatesNode, _OrderedTopLevelNodeB);

    function TemplatesNode() {
        _classCallCheck(this, TemplatesNode);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(TemplatesNode).call(this));
    }

    _createClass(TemplatesNode, [{
        key: "loadPriorty",
        get: function get() {
            return 4000;
        }
    }]);

    return TemplatesNode;
}(_OrderedTopLevelNodeBase2.default);

exports.default = TemplatesNode;

},{"./OrderedTopLevelNodeBase":222}],226:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectEEWithID2 = require("../Base/JThreeObjectEEWithID");

var _JThreeObjectEEWithID3 = _interopRequireDefault(_JThreeObjectEEWithID2);

var _lodash = require("lodash.isnumber");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The most base class for GOML Tree
 *
 * events
 * child-added: 子が追加された時
 * child-removed: 子が削除された時
 * on-mount: 自分が有効なツリーに追加される直前。parentの参照が可能。
 * on-unmount: 自分が有効なツリーから削除される直前。parentの参照が可能。
 *
 * イベントの通知順序には注意が必要です。
 * 例として、あるNodeが子として追加された場合、子にparent-addedが呼ばれその次に自分自身にchild-addedが通知されます。
 *
 * また`this.mount`はwillではfalse, didではtrueです。
 */

var TreeNodeBase = function (_JThreeObjectEEWithID) {
    _inherits(TreeNodeBase, _JThreeObjectEEWithID);

    function TreeNodeBase() {
        _classCallCheck(this, TreeNodeBase);

        /**
         * the node array of this node
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TreeNodeBase).call(this));

        _this.__children = [];
        /**
         * this property is true when this node is mouted to available tree.
         * @type {boolean}
         */
        _this._mounted = false;
        _this.on("child-added", function (child) {
            var cb = _this.__onChildAdded;
            if (cb) {
                cb.bind(_this)(child);
            }
        });
        _this.on("child-removed", function (child) {
            var cb = _this.__onChildRemoved;
            if (cb) {
                cb.bind(_this)(child);
            }
        });
        _this.on("on-mount", function () {
            var cb = _this.__onMount;
            if (cb) {
                cb.bind(_this)();
            }
        });
        _this.on("on-unmount", function () {
            var cb = _this.__onUnmount;
            if (cb) {
                cb.bind(_this)();
            }
        });
        return _this;
    }
    /**
     * Execute delegate in each nodes recursively.
     * @param {TreeNodeBase) => void} act [description]
     */


    _createClass(TreeNodeBase, [{
        key: "callRecursive",
        value: function callRecursive(act) {
            act(this);
            this.__children.forEach(function (v) {
                v.callRecursive(act);
            });
        }
        /**
         * Execute delegate in each nodes recursively with return value
         */

    }, {
        key: "callRecursiveWithReturn",
        value: function callRecursiveWithReturn(act) {
            var ret = [];
            ret.push(act(this));
            this.__children.forEach(function (v) {
                ret = ret.concat(v.callRecursiveWithReturn(act));
            });
            return ret;
        }
        /**
         * get mounted status
         * @return {boolean} [description]
         */

    }, {
        key: "addChild",

        /**
         * Add child to this node
         * @param {TreeNodeBase} child Target node to be inserted
         * @param {number}       index Index of insert location in children. If this argument is null or undefined, target will be inserted in last. If this argument is negative number, target will be inserted in index from last.
         */
        value: function addChild(child, index) {
            child.__parent = this;
            if (!(0, _lodash2.default)(index) && index != null) {
                throw new Error("insert index should be number or null or undefined.");
            }
            var insertIndex = index == null ? this.__children.length : index;
            this.__children.splice(insertIndex, 0, child);
            if (this.Mounted) {
                child.Mounted = true;
                this.emit("child-added", child);
            }
        }
        /**
         * remove child of this node
         * @param  {TreeNodeBase} child
         */

    }, {
        key: "removeChild",
        value: function removeChild(child) {
            for (var i = 0; i < this.__children.length; i++) {
                var v = this.__children[i];
                if (v === child) {
                    child.__parent = null;
                    this.__children.splice(i, 1);
                    if (this.Mounted) {
                        child.Mounted = false;
                        this.emit("child-removed", child);
                    }
                    // TODO: events after-treatment
                    child = null;
                    break;
                }
            }
        }
        /**
         * remove myself
         */

    }, {
        key: "remove",
        value: function remove() {
            if (this.__parent) {
                console.log("remove", this.__parent);
                this.__parent.removeChild(this);
            } else {
                throw new Error("root Node cannot be removed.");
            }
        }
        /**
         * This method is called when child is added
         * This method should be overridden.
         */

    }, {
        key: "__onChildAdded",
        value: function __onChildAdded(child) {
            return;
        }
    }, {
        key: "__onChildRemoved",

        /**
         * This method is called when child is removed
         * This method should be overridden.
         */
        value: function __onChildRemoved(child) {
            return;
        }
    }, {
        key: "__onMount",

        /**
         * This method is called when this node is mounted to available tree.
         * If you change attribute here, no events are fired.
         * This method should be overridden.
         */
        value: function __onMount() {
            return;
        }
    }, {
        key: "__onUnmount",

        /**
         * This method is called when this node is unmounted from available tree.
         * You can still access parent.
         * This method should be overridden.
         */
        value: function __onUnmount() {
            return;
        }
    }, {
        key: "Mounted",
        get: function get() {
            return this._mounted;
        }
        /**
         * update mounted status and emit events
         * @param {boolean} mounted [description]
         */
        ,
        set: function set(mounted) {
            if (mounted && !this._mounted || !mounted && this._mounted) {
                this._mounted = mounted;
                if (this._mounted) {
                    this.emit("on-mount");
                    this.emit("node-mount-process-finished", this._mounted); // this will be move
                    this.__children.forEach(function (child) {
                        child.Mounted = true;
                    });
                } else {
                    this.emit("on-unmount");
                    this.emit("node-mount-process-finished", this._mounted); // this will be move
                    this.__children.forEach(function (child) {
                        child.Mounted = false;
                    });
                }
            }
        }
        /**
         * get parent of this Node
         * @return {TreeNodeBase} [description]
         */

    }, {
        key: "parent",
        get: function get() {
            return this.__parent;
        }
        /**
         * get children of this Node.
         * @return {TreeNodeBase[]} [description]
         */

    }, {
        key: "children",
        get: function get() {
            return this.__children;
        }
        /**
         * get index of this node from parent.
         * @return {number} [description]
         */

    }, {
        key: "index",
        get: function get() {
            return this.__parent.__children.indexOf(this);
        }
        /**
         * return true when this Node is Root(no parent).
         * @return {boolean} is root.
         */

    }, {
        key: "isRoot",
        get: function get() {
            return !this.__parent;
        }
    }]);

    return TreeNodeBase;
}(_JThreeObjectEEWithID3.default);

exports.default = TreeNodeBase;

},{"../Base/JThreeObjectEEWithID":5,"lodash.isnumber":333}],227:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Parser for XML
 */

var XMLParser = function () {
    /**
     * parse xml. By default, multiple root element is available.
     * @param {string}  xml    xml string for parse.
     * @param {boolean} nowrap If this flag is true, root element must be single element.
     */

    function XMLParser(xml, nowrap) {
        _classCallCheck(this, XMLParser);

        this._xml = xml;
        this._doc = new DOMParser().parseFromString(xml, "text/xml");
        if (!nowrap) {
            this._updateError();
            if (!this._error.all) {
                this._elements = [this._doc.documentElement];
            } else if (this._error.message === "Extra content at the end of the document") {
                this._doc = new DOMParser().parseFromString("<root>" + xml + "</root>", "text/xml");
                this._updateError();
                if (this.isValid) {
                    this._elements = Array.prototype.slice.call(this._doc.documentElement.childNodes);
                } else {
                    this._elements = void 0;
                }
            }
        }
    }
    /**
     * get root elements.
     * @return {HTMLElement[]} root elements
     */


    _createClass(XMLParser, [{
        key: "_updateError",
        value: function _updateError() {
            this._error = new XMLParserError(this._doc);
        }
    }, {
        key: "elements",
        get: function get() {
            return this._elements;
        }
        /**
         * get true if parsed xml id valid.
         * @return {boolean} valid or not
         */

    }, {
        key: "isValid",
        get: function get() {
            return !this.error;
        }
        /**
         * get XMLParserError.
         * @return {XMLParserError} XMLParserError object.
         */

    }, {
        key: "error",
        get: function get() {
            if (!this._error) {
                this._updateError();
            }
            if (this._error.all) {
                return this._error;
            } else {
                return;
            }
        }
        /**
         * get original xml string.
         * @return {string} xml string
         */

    }, {
        key: "xml",
        get: function get() {
            return this._xml;
        }
    }]);

    return XMLParser;
}();

var XMLParserError = exports.XMLParserError = function () {
    function XMLParserError(doc) {
        _classCallCheck(this, XMLParserError);

        var parsererrorElement = doc.querySelector("parsererror div");
        if (parsererrorElement) {
            this._all = parsererrorElement.innerHTML.replace(/^\s+|\s+$/g, "");
            this._message = this._all.match(/^.+?:\s?(.+)$/)[1];
        }
    }
    /**
     * get whole error message.
     * @return {string} error message string.
     */


    _createClass(XMLParserError, [{
        key: "all",
        get: function get() {
            return this._all;
        }
        /**
         * get message part of error.
         * @return {string} error message string.
         */

    }, {
        key: "message",
        get: function get() {
            return this._message;
        }
    }]);

    return XMLParserError;
}();

exports.default = XMLParser;

},{}],228:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GomlTreeNodeBase = require("./Goml/GomlTreeNodeBase");

var _GomlTreeNodeBase2 = _interopRequireDefault(_GomlTreeNodeBase);

var _lodash = require("lodash.isarray");

var _lodash2 = _interopRequireDefault(_lodash);

var _RenderStageRegistory = require("./Core/Renderers/RenderStageRegistory");

var _RenderStageRegistory2 = _interopRequireDefault(_RenderStageRegistory);

var _PrimitiveRegistory = require("./Core/Geometries/Base/PrimitiveRegistory");

var _PrimitiveRegistory2 = _interopRequireDefault(_PrimitiveRegistory);

var _MaterialManager = require("./Core/Materials/MaterialManager");

var _MaterialManager2 = _interopRequireDefault(_MaterialManager);

var _Timer = require("./Core/Timer");

var _Timer2 = _interopRequireDefault(_Timer);

var _J3Object = require("./Interface/J3Object");

var _J3Object2 = _interopRequireDefault(_J3Object);

var _J3ObjectMixins = require("./Interface/J3ObjectMixins");

var _J3ObjectMixins2 = _interopRequireDefault(_J3ObjectMixins);

var _JThreeContext = require("./JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _SceneManager = require("./Core/SceneManager");

var _SceneManager2 = _interopRequireDefault(_SceneManager);

var _CanvasManager = require("./Core/Canvas/CanvasManager");

var _CanvasManager2 = _interopRequireDefault(_CanvasManager);

var _LoopManager = require("./Core/LoopManager");

var _LoopManager2 = _interopRequireDefault(_LoopManager);

var _ContextComponents = require("./ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _ResourceManager = require("./Core/ResourceManager");

var _ResourceManager2 = _interopRequireDefault(_ResourceManager);

var _NodeManager = require("./Goml/NodeManager");

var _NodeManager2 = _interopRequireDefault(_NodeManager);

var _Debugger = require("./Debug/Debugger");

var _Debugger2 = _interopRequireDefault(_Debugger);

var _GomlLoader = require("./Goml/GomlLoader");

var _GomlLoader2 = _interopRequireDefault(_GomlLoader);

var _ResourceLoader = require("./Core/ResourceLoader");

var _ResourceLoader2 = _interopRequireDefault(_ResourceLoader);

var _ModuleManager = require("./Module/ModuleManager");

var _ModuleManager2 = _interopRequireDefault(_ModuleManager);

var _Quaternion = require("./Math/Quaternion");

var _Quaternion2 = _interopRequireDefault(_Quaternion);

var _Vector = require("./Math/Vector2");

var _Vector2 = _interopRequireDefault(_Vector);

var _Vector3 = require("./Math/Vector3");

var _Vector4 = _interopRequireDefault(_Vector3);

var _Vector5 = require("./Math/Vector4");

var _Vector6 = _interopRequireDefault(_Vector5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(0, _J3ObjectMixins2.default)();

/**
* the methods having the syntax like j3.SOMETHING() should be contained in this class.
* These methods declared inside of this class will be subscribed in JThreeInit.Init(),it means the first time.
*/

var JThreeStatic = function () {
    function JThreeStatic() {
        _classCallCheck(this, JThreeStatic);
    }

    _createClass(JThreeStatic, [{
        key: "Math",
        get: function get() {
            return {
                Quaternion: _Quaternion2.default,
                Vector2: _Vector2.default,
                Vector3: _Vector4.default,
                Vector4: _Vector6.default
            };
        }
    }]);

    return JThreeStatic;
}();
/**
* Provides initialization of jThree.js
* You don't need to call this class directly, jThreeInit will be called automatically when jThree.js is loaded.
*/


var JThreeInit = function () {
    function JThreeInit() {
        _classCallCheck(this, JThreeInit);
    }

    _createClass(JThreeInit, null, [{
        key: "j3",
        value: function j3(argu) {
            if (typeof argu === "string" || argu instanceof _GomlTreeNodeBase2.default || (0, _lodash2.default)(argu) && argu.every(function (v) {
                return v instanceof _GomlTreeNodeBase2.default;
            })) {
                return new _J3Object2.default(argu);
            } else if (typeof argu === "function") {
                var loader = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceLoader);
                loader.promise.then(argu).catch(function (e) {
                    console.error(e);
                });
                return;
            } else {
                throw new Error("Selector query must be string.");
            }
        }
        /**
        * This method should be called when Jthree loaded.
        */

    }, {
        key: "init",
        value: function init() {
            JThreeInit._copyGLConstants();
            var scripts = document.getElementsByTagName("script");
            JThreeInit.selfTag = scripts[scripts.length - 1];
            // register interfaces
            window["j3"] = JThreeInit.j3; // $(~~~)
            var baseCtor = JThreeStatic;
            Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
                if (name !== "constructor") {
                    var org_descriptor = Object.getOwnPropertyDescriptor(baseCtor, name);
                    var descriptor = {
                        value: baseCtor.prototype[name],
                        enumerable: false,
                        configurable: true,
                        writable: true
                    };
                    Object.defineProperty(Object.getPrototypeOf(window["j3"]), name, org_descriptor || descriptor);
                }
            });
            window["j3"]["lateStart"] = JThreeInit._startInitialize;
            _JThreeContext2.default.init();
            _JThreeContext2.default.registerContextComponent(new _LoopManager2.default());
            _JThreeContext2.default.registerContextComponent(new _Timer2.default());
            _JThreeContext2.default.registerContextComponent(new _ResourceLoader2.default());
            _JThreeContext2.default.registerContextComponent(new _SceneManager2.default());
            _JThreeContext2.default.registerContextComponent(new _CanvasManager2.default());
            _JThreeContext2.default.registerContextComponent(new _ResourceManager2.default());
            _JThreeContext2.default.registerContextComponent(new _NodeManager2.default());
            _JThreeContext2.default.registerContextComponent(new _Debugger2.default());
            _JThreeContext2.default.registerContextComponent(new _MaterialManager2.default());
            _JThreeContext2.default.registerContextComponent(new _PrimitiveRegistory2.default());
            _JThreeContext2.default.registerContextComponent(new _RenderStageRegistory2.default());
            _JThreeContext2.default.registerContextComponent(new _ModuleManager2.default());
            if (JThreeInit.selfTag.getAttribute("x-lateLoad") !== "true") {
                window.addEventListener("DOMContentLoaded", function () {
                    JThreeInit._startInitialize();
                });
            }
        }
    }, {
        key: "_copyGLConstants",
        value: function _copyGLConstants() {
            if (WebGLRenderingContext.ONE) {
                return;
            }
            for (var propName in WebGLRenderingContext.prototype) {
                if (/^[A-Z]/.test(propName)) {
                    var property = WebGLRenderingContext.prototype[propName];
                    WebGLRenderingContext[propName] = property;
                }
            }
        }
    }, {
        key: "_startInitialize",
        value: function _startInitialize() {
            var nodeManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.NodeManager); // This is not string but it is for conviniesnce.
            var loader = new _GomlLoader2.default(nodeManager, JThreeInit.selfTag);
            _JThreeContext2.default.getContextComponent(_ContextComponents2.default.PrimitiveRegistory).registerDefaultPrimitives();
            _JThreeContext2.default.getContextComponent(_ContextComponents2.default.Debugger).attach();
            var resourceLoader = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceLoader);
            loader.initForPage();
            resourceLoader.promise.then(function () {
                _JThreeContext2.default.getContextComponent(_ContextComponents2.default.LoopManager).begin();
            });
        }
    }]);

    return JThreeInit;
}();

exports.default = JThreeInit;

},{"./ContextComponents":8,"./Core/Canvas/CanvasManager":11,"./Core/Geometries/Base/PrimitiveRegistory":25,"./Core/LoopManager":34,"./Core/Materials/MaterialManager":59,"./Core/Renderers/RenderStageRegistory":85,"./Core/ResourceLoader":110,"./Core/ResourceManager":111,"./Core/SceneManager":138,"./Core/Timer":152,"./Debug/Debugger":155,"./Goml/GomlLoader":178,"./Goml/GomlTreeNodeBase":183,"./Goml/NodeManager":184,"./Interface/J3Object":250,"./Interface/J3ObjectMixins":252,"./JThreeContext":267,"./Math/Quaternion":275,"./Math/Vector2":277,"./Math/Vector3":278,"./Math/Vector4":279,"./Module/ModuleManager":284,"lodash.isarray":331}],229:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3ObjectBase2 = require("../J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

var _SceneUtilities = require("../Static/SceneUtilities");

var _SceneUtilities2 = _interopRequireDefault(_SceneUtilities);

var _lodash = require("lodash.isundefined");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Basic = function (_J3ObjectBase) {
    _inherits(Basic, _J3ObjectBase);

    function Basic() {
        _classCallCheck(this, Basic);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Basic).apply(this, arguments));
    }

    _createClass(Basic, [{
        key: "show",
        value: function show(argu0, argu1, argu2) {
            // const option = EffectUtilities.toOption(argu0, argu1, argu2);
            if ((0, _lodash2.default)(argu0)) {
                _SceneUtilities2.default.filterSceneObjectNode(this.__getArray()).forEach(function (node) {
                    if (node.target) {
                        node.target.isVisible = true;
                    }
                });
            } else {
                throw new Error("Not implemented yet");
            }
        }
    }, {
        key: "hide",
        value: function hide(argu0, argu1, argu2) {
            // const option = EffectUtilities.toOption(argu0, argu1, argu2);
            if ((0, _lodash2.default)(argu0)) {
                _SceneUtilities2.default.filterSceneObjectNode(this.__getArray()).forEach(function (node) {
                    if (node.target) {
                        node.target.isVisible = false;
                    }
                });
            } else {
                throw new Error("Not implemented yet");
            }
        }
    }]);

    return Basic;
}(_J3ObjectBase3.default);

exports.default = Basic;

},{"../J3ObjectBase":251,"../Static/SceneUtilities":262,"lodash.isundefined":336}],230:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3ObjectBase2 = require("../J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

var _EffectUtilities = require("./EffectUtilities");

var _EffectUtilities2 = _interopRequireDefault(_EffectUtilities);

var _lodash = require("lodash.isplainobject");

var _lodash2 = _interopRequireDefault(_lodash);

var _EffectExecutor = require("./EffectExecutor");

var _EffectExecutor2 = _interopRequireDefault(_EffectExecutor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Custom = function (_J3ObjectBase) {
    _inherits(Custom, _J3ObjectBase);

    function Custom() {
        _classCallCheck(this, Custom);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Custom).apply(this, arguments));
    }

    _createClass(Custom, [{
        key: "animate",
        value: function animate(properties, argu0, argu1, argu2) {
            var option = _EffectUtilities2.default.toOption(argu0, argu1, argu2);
            if ((0, _lodash2.default)(properties)) {
                // const moduleManager = JThreeContext.getContextComponent<ModuleManager>(ContextComponents.ModuleManager);
                // const Module: new () => IModule = <any>EffectModule;
                this.__getArray().forEach(function (node) {
                    // const moduleRegistry = moduleManager.addModule(Module);
                    // const moduleInstance = moduleRegistry.apply(node, properties, option);
                    // moduleInstance.enabled = true;
                    var effectExecutor = node.props.getProp("ee");
                    if (!effectExecutor) {
                        effectExecutor = new _EffectExecutor2.default(node);
                        node.props.setProp("ee", effectExecutor);
                    }
                    effectExecutor.add(properties, option);
                });
            } else {
                throw new Error("Argument type is not correct");
            }
            return this;
        }
    }]);

    return Custom;
}(_J3ObjectBase3.default);

exports.default = Custom;

},{"../J3ObjectBase":251,"./EffectExecutor":235,"./EffectUtilities":237,"lodash.isplainobject":334}],231:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject2 = require("../../../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EasingFunctionBase = function (_JThreeObject) {
    _inherits(EasingFunctionBase, _JThreeObject);

    function EasingFunctionBase() {
        _classCallCheck(this, EasingFunctionBase);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(EasingFunctionBase).apply(this, arguments));
    }

    _createClass(EasingFunctionBase, [{
        key: "ease",
        value: function ease(begin, end, progress) {
            return null;
        }
    }]);

    return EasingFunctionBase;
}(_JThreeObject3.default);

exports.default = EasingFunctionBase;

},{"../../../Base/JThreeObject":3}],232:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _LinearEasingFunction = require("./LinearEasingFunction");

var _LinearEasingFunction2 = _interopRequireDefault(_LinearEasingFunction);

var _SwingEasingFunction = require("./SwingEasingFunction");

var _SwingEasingFunction2 = _interopRequireDefault(_SwingEasingFunction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Easing function classes constructors is listed below.
 * If you extend this hash, the user can use new easing functions.
 * Each easing function class must extends EasingFunctionBase class.
 */

var easingFunction = {
  "linear": _LinearEasingFunction2.default,
  "swing": _SwingEasingFunction2.default
};
exports.default = easingFunction;

},{"./LinearEasingFunction":233,"./SwingEasingFunction":234}],233:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EasingFunctionBase2 = require("./EasingFunctionBase");

var _EasingFunctionBase3 = _interopRequireDefault(_EasingFunctionBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LinearEasingFunction = function (_EasingFunctionBase) {
    _inherits(LinearEasingFunction, _EasingFunctionBase);

    function LinearEasingFunction() {
        _classCallCheck(this, LinearEasingFunction);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(LinearEasingFunction).apply(this, arguments));
    }

    _createClass(LinearEasingFunction, [{
        key: "ease",
        value: function ease(begin, end, progress) {
            return begin + (end - begin) * progress;
        }
    }]);

    return LinearEasingFunction;
}(_EasingFunctionBase3.default);

exports.default = LinearEasingFunction;

},{"./EasingFunctionBase":231}],234:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EasingFunctionBase2 = require("./EasingFunctionBase");

var _EasingFunctionBase3 = _interopRequireDefault(_EasingFunctionBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SwingEasingFunction = function (_EasingFunctionBase) {
    _inherits(SwingEasingFunction, _EasingFunctionBase);

    function SwingEasingFunction() {
        _classCallCheck(this, SwingEasingFunction);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SwingEasingFunction).apply(this, arguments));
    }

    _createClass(SwingEasingFunction, [{
        key: "ease",
        value: function ease(begin, end, progress) {
            return begin + (end - begin) * (0.5 - Math.cos(progress * Math.PI) / 2);
        }
    }]);

    return SwingEasingFunction;
}(_EasingFunctionBase3.default);

exports.default = SwingEasingFunction;

},{"./EasingFunctionBase":231}],235:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EffectModule = require("./EffectModule");

var _EffectModule2 = _interopRequireDefault(_EffectModule);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EffectExecutor = function () {
    function EffectExecutor(node) {
        _classCallCheck(this, EffectExecutor);

        this._queue = [];
        /**
         * Now executing modules. This array will be sorted by priority of appearance.
         * @type {EffectModule[]}
         */
        this._executing = [];
        this._moduleManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ModuleManager);
        this._node = node;
    }

    _createClass(EffectExecutor, [{
        key: "add",
        value: function add(properties, option) {
            var _this = this;

            var moduleFactories = Object.keys(properties).map(function (property, i) {
                var moduleFactory = function moduleFactory() {
                    var moduleRegistry = _this._moduleManager.addModule(_EffectModule2.default);
                    var moduleInstance = moduleRegistry.apply(_this._node, property, properties[property], option);
                    moduleInstance.afterDetach = function () {
                        // _executingから削除
                        var index = _this._executing.indexOf(moduleInstance);
                        if (index === -1) {
                            throw new Error("executing module is not found");
                        }
                        _this._executing.splice(index, 1);
                        // 非表示になっていた同一propertyの実行中のmoduleの中で一番古いものを表示
                        for (var j = 0; j <= _this._executing.length - 1; j++) {
                            if (_this._executing[j].property === moduleInstance.property) {
                                _this._executing[j].appeared = true;
                                break;
                            }
                        }
                        if (i === Object.keys(properties).length - 1) {
                            // 最後にcampleteを呼ぶ
                            option.complete.call(_this._node, _this._node);
                            // queue経由の場合は一番古いmoduleを実行
                            if (moduleInstance.option.queue && _this._queue.length !== 0) {
                                var nextModules = _this._queue.shift();
                                nextModules.forEach(function (mf) {
                                    return _this._exec(mf());
                                });
                            }
                        }
                    };
                    return moduleInstance;
                };
                return moduleFactory;
            });
            if (option.queue) {
                if (this._queue.length === 0 && this._executing.every(function (m) {
                    return !m.option.queue;
                })) {
                    // queueに一つも無い、かつすべての実行中のmoduleがqueue経由ではない場合には即時実行
                    moduleFactories.forEach(function (mf) {
                        return _this._exec(mf());
                    });
                } else {
                    // それ以外の場合はqueueへ
                    this._queue.push(moduleFactories);
                }
            } else {
                // queue経由では無い場合は即時実行
                moduleFactories.forEach(function (mf) {
                    return _this._exec(mf());
                });
            }
        }
    }, {
        key: "_exec",
        value: function _exec(module) {
            // console.log("exec", new Date, module.property, module);
            // 既に実行中のmoduleが同一propertyの場合、すべて非表示に
            this._executing.filter(function (m) {
                return m.property === module.property;
            }).forEach(function (m) {
                m.appeared = false;
            });
            // 新しいmoduleを実行開始
            this._executing.unshift(module);
            module.enabled = true;
        }
    }]);

    return EffectExecutor;
}();

exports.default = EffectExecutor;

},{"../../ContextComponents":8,"../../JThreeContext":267,"./EffectModule":236}],236:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EffecterList = require("./Effecter/EffecterList");

var _EffecterList2 = _interopRequireDefault(_EffecterList);

var _EasingFunctionList = require("./Easing/EasingFunctionList");

var _EasingFunctionList2 = _interopRequireDefault(_EasingFunctionList);

var _Module2 = require("../../Module/Module");

var _Module3 = _interopRequireDefault(_Module2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EffectModule = function (_Module) {
    _inherits(EffectModule, _Module);

    function EffectModule(node, property, value, option, afterDetach) {
        _classCallCheck(this, EffectModule);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EffectModule).call(this));

        _this.enabled = false;
        _this._node = node;
        _this.property = property;
        _this.option = option;
        _this.afterDetach = afterDetach;
        var attr = node.attributes.getAttribute(property);
        _this._value = attr.Converter.toObjectAttr(value);
        var easing = new _EasingFunctionList2.default[option.easing]();
        function attrUpdater(val) {
            attr.Value = val;
        }
        _this._effecter = new _EffecterList2.default[attr.Converter.name](null, option.duration, attr.Value, _this._value, easing, attrUpdater, _this._complete.bind(_this));
        return _this;
    }

    _createClass(EffectModule, [{
        key: "start",
        value: function start(node) {
            this._beginTime = +new Date();
            this._effecter.beginTime = this._beginTime;
        }
    }, {
        key: "update",
        value: function update(node) {
            this._effecter.update(+new Date());
        }
    }, {
        key: "_complete",
        value: function _complete() {
            this.detach();
            this.afterDetach();
        }
    }, {
        key: "appeared",
        get: function get() {
            return this._effecter.appeared;
        },
        set: function set(b) {
            this._effecter.appeared = b;
        }
    }]);

    return EffectModule;
}(_Module3.default);

exports.default = EffectModule;

},{"../../Module/Module":282,"./Easing/EasingFunctionList":232,"./Effecter/EffecterList":241}],237:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require("lodash.isundefined");

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require("lodash.isnumber");

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require("lodash.isstring");

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require("lodash.isfunction");

var _lodash8 = _interopRequireDefault(_lodash7);

var _lodash9 = require("lodash.isplainobject");

var _lodash10 = _interopRequireDefault(_lodash9);

var _objectAssign = require("object-assign");

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EffectUtilities = function () {
    function EffectUtilities() {
        _classCallCheck(this, EffectUtilities);
    }

    _createClass(EffectUtilities, null, [{
        key: "toOption",
        value: function toOption(argu0, argu1, argu2) {
            var optionUser = {};
            switch (true) {
                case (0, _lodash2.default)(argu0):
                    break;
                case (0, _lodash10.default)(argu0) && (0, _lodash2.default)(argu1):
                    optionUser = argu0;
                    break;
                case (0, _lodash8.default)(argu0) && (0, _lodash2.default)(argu1):
                    optionUser.complete = argu0;
                    break;
                case (0, _lodash4.default)(argu0) || (0, _lodash6.default)(argu0):
                    optionUser.duration = argu0;
                    switch (true) {
                        case (0, _lodash2.default)(argu1):
                            // duration: number | string
                            break;
                        case (0, _lodash8.default)(argu1) && (0, _lodash2.default)(argu2):
                            // duration: number | string, complete: () => void
                            optionUser.complete = argu1;
                            break;
                        case (0, _lodash6.default)(argu1):
                            optionUser.easing = argu1;
                            switch (true) {
                                case (0, _lodash2.default)(argu2):
                                    // duration: number | string, easing: string
                                    break;
                                case (0, _lodash8.default)(argu2):
                                    // duration: number | string, easing: string, complete: () => void
                                    optionUser.complete = argu2;
                                    break;
                                default:
                                    throw new Error("Argument type is not correct");
                            }
                            break;
                        default:
                            throw new Error("Argument type is not correct");
                    }
                    break;
                default:
                    throw new Error("Argument type is not correct");
            }
            var option = {
                duration: 400,
                easing: "swing",
                queue: true,
                queueName: "fx",
                step: function step(now, tween) {
                    return;
                },
                progress: function progress(animation, _progress, remainingMs) {
                    return;
                },
                complete: function complete(node) {
                    return;
                },
                start: function start(animation) {
                    return;
                },
                done: function done(animation, jumpedToEnd) {
                    return;
                },
                fail: function fail(animation, jumpedToEnd) {
                    return;
                },
                always: function always(animation, jumpToEnd) {
                    return;
                }
            };
            // check .duration type
            if ((0, _lodash6.default)(optionUser.duration)) {
                var speed = {
                    slow: 600,
                    fast: 200,
                    _default: 400
                };
                if (speed[optionUser.duration]) {
                    option.duration = speed[optionUser.duration];
                } else {
                    option.duration = speed["default"];
                }
                delete optionUser.duration;
            }
            // check .queue type
            if ((0, _lodash6.default)(optionUser.queue)) {
                option.queue = true;
                option.queueName = optionUser.queue;
            } else if (optionUser.queue === true || optionUser.queue === false) {
                option.queue = optionUser.queue;
                option.queueName = optionUser.queue ? "fx" : null;
            }
            delete optionUser.queue;
            // assign
            (0, _objectAssign2.default)(option, optionUser);
            return option;
        }
    }]);

    return EffectUtilities;
}();

exports.default = EffectUtilities;

},{"lodash.isfunction":332,"lodash.isnumber":333,"lodash.isplainobject":334,"lodash.isstring":335,"lodash.isundefined":336,"object-assign":337}],238:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EffecterBase2 = require("./EffecterBase");

var _EffecterBase3 = _interopRequireDefault(_EffecterBase2);

var _Color = require("../../../Math/Color3");

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Color3Effecter = function (_EffecterBase) {
    _inherits(Color3Effecter, _EffecterBase);

    function Color3Effecter() {
        _classCallCheck(this, Color3Effecter);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Color3Effecter).apply(this, arguments));
    }

    _createClass(Color3Effecter, [{
        key: "__updateEffect",
        value: function __updateEffect(progress) {
            var b = this.__beginValue;
            var e = this.__endValue;
            var ef = this.__easingFunction.ease;
            this.Value = new _Color2.default(ef(b.R, e.R, progress), ef(b.G, e.G, progress), ef(b.B, e.B, progress));
        }
    }]);

    return Color3Effecter;
}(_EffecterBase3.default);

exports.default = Color3Effecter;

},{"../../../Math/Color3":269,"./EffecterBase":240}],239:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EffecterBase2 = require("./EffecterBase");

var _EffecterBase3 = _interopRequireDefault(_EffecterBase2);

var _Color = require("../../../Math/Color4");

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Color4Effecter = function (_EffecterBase) {
    _inherits(Color4Effecter, _EffecterBase);

    function Color4Effecter() {
        _classCallCheck(this, Color4Effecter);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Color4Effecter).apply(this, arguments));
    }

    _createClass(Color4Effecter, [{
        key: "__updateEffect",
        value: function __updateEffect(progress) {
            var b = this.__beginValue;
            var e = this.__endValue;
            var ef = this.__easingFunction.ease;
            this.Value = new _Color2.default(ef(b.R, e.R, progress), ef(b.G, e.G, progress), ef(b.B, e.B, progress), ef(b.A, b.A, progress));
        }
    }]);

    return Color4Effecter;
}(_EffecterBase3.default);

exports.default = Color4Effecter;

},{"../../../Math/Color4":270,"./EffecterBase":240}],240:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObjectWithID2 = require("../../../Base/JThreeObjectWithID");

var _JThreeObjectWithID3 = _interopRequireDefault(_JThreeObjectWithID2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EffecterBase = function (_JThreeObjectWithID) {
    _inherits(EffecterBase, _JThreeObjectWithID);

    function EffecterBase(begintime, duration, beginValue, endValue, easing, onUpdate, onComplete) {
        _classCallCheck(this, EffecterBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EffecterBase).call(this));

        _this.appeared = true;
        _this.__beginTime = begintime;
        _this.__duration = duration;
        _this.__easingFunction = easing;
        _this.__beginValue = beginValue;
        _this.__endValue = endValue;
        _this._value = beginValue;
        _this._onUpdate = onUpdate;
        _this._onComplete = onComplete;
        return _this;
    }

    _createClass(EffecterBase, [{
        key: "update",

        /**
        * Upate
        */
        value: function update(time) {
            var progress = (time - this.__beginTime) / this.__duration;
            var isFinish = progress >= 1;
            progress = Math.min(Math.max(progress, 0), 1); // clamp [0,1]
            this.__updateEffect(progress);
            if (isFinish && typeof this._onComplete === "function") {
                this._onComplete();
            }
            return isFinish;
        }
    }, {
        key: "Value",
        set: function set(value) {
            this._value = value;
            if (this.appeared) {
                this._onUpdate(value);
            }
        },
        get: function get() {
            return this._value;
        }
    }, {
        key: "beginTime",
        set: function set(time) {
            this.__beginTime = time;
        }
    }, {
        key: "onUpdate",
        set: function set(callbackfn) {
            this._onUpdate = callbackfn;
        }
    }]);

    return EffecterBase;
}(_JThreeObjectWithID3.default);

exports.default = EffecterBase;

},{"../../../Base/JThreeObjectWithID":6}],241:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Color3Effecter = require("./Color3Effecter");

var _Color3Effecter2 = _interopRequireDefault(_Color3Effecter);

var _Color4Effecter = require("./Color4Effecter");

var _Color4Effecter2 = _interopRequireDefault(_Color4Effecter);

var _IntegerEffecter = require("./IntegerEffecter");

var _IntegerEffecter2 = _interopRequireDefault(_IntegerEffecter);

var _NumberEffecter = require("./NumberEffecter");

var _NumberEffecter2 = _interopRequireDefault(_NumberEffecter);

var _RotationEffecter = require("./RotationEffecter");

var _RotationEffecter2 = _interopRequireDefault(_RotationEffecter);

var _Vector3Effecter = require("./Vector3Effecter");

var _Vector3Effecter2 = _interopRequireDefault(_Vector3Effecter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var effecter = {
    // "angle": AngleEffecter,
    "float": _NumberEffecter2.default,
    "int": _IntegerEffecter2.default,
    "vec3": _Vector3Effecter2.default,
    "rotation": _RotationEffecter2.default,
    "color4": _Color4Effecter2.default,
    "color3": _Color3Effecter2.default
};
exports.default = effecter;

},{"./Color3Effecter":238,"./Color4Effecter":239,"./IntegerEffecter":242,"./NumberEffecter":243,"./RotationEffecter":244,"./Vector3Effecter":245}],242:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EffecterBase2 = require("./EffecterBase");

var _EffecterBase3 = _interopRequireDefault(_EffecterBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IntegerEffecter = function (_EffecterBase) {
    _inherits(IntegerEffecter, _EffecterBase);

    function IntegerEffecter() {
        _classCallCheck(this, IntegerEffecter);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(IntegerEffecter).apply(this, arguments));
    }

    _createClass(IntegerEffecter, [{
        key: "__updateEffect",
        value: function __updateEffect(progress) {
            var b = this.__beginValue;
            var e = this.__endValue;
            var ef = this.__easingFunction.ease;
            var val = Math.floor(ef(b, e, progress));
            if (this.Value !== val) {
                this.Value = val;
            }
        }
    }]);

    return IntegerEffecter;
}(_EffecterBase3.default);

exports.default = IntegerEffecter;

},{"./EffecterBase":240}],243:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EffecterBase2 = require("./EffecterBase");

var _EffecterBase3 = _interopRequireDefault(_EffecterBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NumberEffecter = function (_EffecterBase) {
    _inherits(NumberEffecter, _EffecterBase);

    function NumberEffecter() {
        _classCallCheck(this, NumberEffecter);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(NumberEffecter).apply(this, arguments));
    }

    _createClass(NumberEffecter, [{
        key: "__updateEffect",
        value: function __updateEffect(progress) {
            this.Value = this.__easingFunction.ease(this.__beginValue, this.__endValue, progress);
        }
    }]);

    return NumberEffecter;
}(_EffecterBase3.default);

exports.default = NumberEffecter;

},{"./EffecterBase":240}],244:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EffecterBase2 = require("./EffecterBase");

var _EffecterBase3 = _interopRequireDefault(_EffecterBase2);

var _Quaternion = require("../../../Math/Quaternion");

var _Quaternion2 = _interopRequireDefault(_Quaternion);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RotationEffecter = function (_EffecterBase) {
    _inherits(RotationEffecter, _EffecterBase);

    function RotationEffecter() {
        _classCallCheck(this, RotationEffecter);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(RotationEffecter).apply(this, arguments));
    }

    _createClass(RotationEffecter, [{
        key: "__updateEffect",
        value: function __updateEffect(progress) {
            var b = this.__beginValue;
            var e = this.__endValue;
            var ef = this.__easingFunction.ease;
            this.Value = _Quaternion2.default.slerp(b, e, ef(0, 1, progress));
        }
    }]);

    return RotationEffecter;
}(_EffecterBase3.default);

exports.default = RotationEffecter;

},{"../../../Math/Quaternion":275,"./EffecterBase":240}],245:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EffecterBase2 = require("./EffecterBase");

var _EffecterBase3 = _interopRequireDefault(_EffecterBase2);

var _Vector = require("../../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Vector3Effecter = function (_EffecterBase) {
    _inherits(Vector3Effecter, _EffecterBase);

    function Vector3Effecter() {
        _classCallCheck(this, Vector3Effecter);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Vector3Effecter).apply(this, arguments));
    }

    _createClass(Vector3Effecter, [{
        key: "__updateEffect",
        value: function __updateEffect(progress) {
            var b = this.__beginValue;
            var e = this.__endValue;
            var ef = this.__easingFunction.ease;
            this.Value = new _Vector2.default(ef(b.X, e.X, progress), ef(b.Y, e.Y, progress), ef(b.Z, e.Z, progress));
            // console.log(this.targetAttribute.Value.Z);
        }
    }]);

    return Vector3Effecter;
}(_EffecterBase3.default);

exports.default = Vector3Effecter;

},{"../../../Math/Vector3":278,"./EffecterBase":240}],246:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _HitAreaRenderStage = require("../../Core/Renderers/RenderStages/HitAreaRenderStage");

var _HitAreaRenderStage2 = _interopRequireDefault(_HitAreaRenderStage);

var _J3Event = require("./J3Event");

var _J3Event2 = _interopRequireDefault(_J3Event);

var _objectAssign = require("object-assign");

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventBroadcaster = function () {
    function EventBroadcaster() {
        _classCallCheck(this, EventBroadcaster);

        this._eventListeners = {};
        this._isMouseDown = false;
        this._eventListeners["mouse-move"] = this._mouseMoveEvent.bind(this);
        this._eventListeners["mouse-leave"] = this._mouseLeaveEvent.bind(this);
        this._eventListeners["mouse-enter"] = this._mouseEnterEvent.bind(this);
        this._eventListeners["mouse-down"] = this._mouseDownEvent.bind(this);
        this._eventListeners["mouse-up"] = this._mouseUpEvent.bind(this);
    }

    _createClass(EventBroadcaster, [{
        key: "attachEvents",
        value: function attachEvents(eventTap) {
            var _this = this;

            this._eventTap = eventTap;
            Object.keys(this._eventListeners).forEach(function (k) {
                _this._eventTap.on(k, _this._eventListeners[k]);
            });
            var renderPath = this._eventTap.renderPath.path;
            for (var i = renderPath.length - 1; i >= 0; i--) {
                if (renderPath[i].stage instanceof _HitAreaRenderStage2.default) {
                    this._hitAreaRenderStage = renderPath[i].stage;
                    break;
                }
            }
        }
    }, {
        key: "detachEvents",
        value: function detachEvents() {
            var _this2 = this;

            if (this._eventTap) {
                Object.keys(this._eventListeners).forEach(function (k) {
                    _this2._eventTap.removeListener(k, _this2._eventListeners[k]);
                });
                this._eventTap = null;
            }
        }
    }, {
        key: "_mouseMoveEvent",
        value: function _mouseMoveEvent(eObj) {
            var _this3 = this;

            this._getTargetNode(eObj.mouseX, eObj.mouseY, function (node) {
                if (_this3._currentMouseMove !== node) {
                    _this3._broadcast(node, "mouseenter", (0, _objectAssign2.default)({}, eObj, {
                        relatedTarget: _this3._currentMouseMove
                    }));
                    _this3._broadcast(_this3._currentMouseMove, "mouseout", (0, _objectAssign2.default)({}, eObj, {
                        relatedTarget: node
                    }));
                }
                _this3._broadcast(node, "mousemove", eObj);
                _this3._currentMouseMove = node;
            });
        }
    }, {
        key: "_mouseLeaveEvent",
        value: function _mouseLeaveEvent(eObj) {
            this._isMouseDown = false;
            this._currentMouseMove = null;
        }
    }, {
        key: "_mouseEnterEvent",
        value: function _mouseEnterEvent(eObj) {
            var _this4 = this;

            this._getTargetNode(eObj.mouseX, eObj.mouseY, function (node) {
                _this4._currentMouseMove = node;
            });
        }
    }, {
        key: "_mouseDownEvent",
        value: function _mouseDownEvent(eObj) {
            var _this5 = this;

            this._isMouseDown = true;
            // mousedown
            this._getTargetNode(eObj.mouseX, eObj.mouseY, function (node) {
                _this5._broadcast(node, "mousedown", eObj);
            });
        }
    }, {
        key: "_mouseUpEvent",
        value: function _mouseUpEvent(eObj) {
            var _this6 = this;

            var isClick = this._isMouseDown;
            this._getTargetNode(eObj.mouseX, eObj.mouseY, function (node) {
                if (isClick) {
                    // click
                    _this6._broadcast(node, "click", eObj);
                }
                // mouseup
                _this6._broadcast(node, "mouseup", eObj);
            });
            this._isMouseDown = false;
        }
    }, {
        key: "_broadcast",
        value: function _broadcast(node, eventType, eObj) {
            var eventOrganizer = node.props.getProp("event");
            if (eventOrganizer) {
                var e = this._eventFormatter(eObj);
                e.type = eventType;
                e.target = node;
                eventOrganizer.bubble(eventType, e);
            }
        }
    }, {
        key: "_eventFormatter",
        value: function _eventFormatter(eObj) {
            var e = new _J3Event2.default(eObj);
            e.which = e.eventSource.which;
            e.timeStamp = new Date().getTime();
            return e;
        }
    }, {
        key: "_getTargetNode",
        value: function _getTargetNode(x, y, callbackfn) {
            this._hitAreaRenderStage.queryHitTest(x, y).then(function (sceneObject) {
                callbackfn(sceneObject.relatedNode);
            });
        }
    }]);

    return EventBroadcaster;
}();

exports.default = EventBroadcaster;

},{"../../Core/Renderers/RenderStages/HitAreaRenderStage":99,"./J3Event":249,"object-assign":337}],247:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3ObjectBase2 = require("../J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

var _lodash = require("lodash.isplainobject");

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require("lodash.isstring");

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require("lodash.isfunction");

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require("lodash.isarray");

var _lodash8 = _interopRequireDefault(_lodash7);

var _lodash9 = require("lodash.isundefined");

var _lodash10 = _interopRequireDefault(_lodash9);

var _EventOrgnizer = require("./EventOrgnizer");

var _EventOrgnizer2 = _interopRequireDefault(_EventOrgnizer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventHandlerAttachment = function (_J3ObjectBase) {
    _inherits(EventHandlerAttachment, _J3ObjectBase);

    function EventHandlerAttachment() {
        _classCallCheck(this, EventHandlerAttachment);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(EventHandlerAttachment).apply(this, arguments));
    }

    _createClass(EventHandlerAttachment, [{
        key: "on",
        value: function on(argu0, argu1, argu2, argu3) {
            var _this2 = this;

            var eventData = {
                events: {},
                data: null,
                selector: null
            };
            var isEvents = false;
            var falseHandler = function falseHandler(e) {
                e.preventDefault();
                e.stopPropagation();
            };
            switch (true) {
                case (0, _lodash4.default)(argu0):
                    eventData.events[argu0] = null;
                    break;
                case (0, _lodash2.default)(argu0):
                    isEvents = true;
                    eventData.events = argu0;
                    break;
                default:
                    throw new Error("Argument type is not correct");
            }
            switch (true) {
                case (0, _lodash10.default)(argu1) && isEvents:
                    break;
                case (0, _lodash6.default)(argu1) && !isEvents:
                    eventData.events[argu0] = argu1;
                    break;
                case argu1 === false:
                    eventData.events[argu1] = falseHandler;
                    break;
                case (0, _lodash4.default)(argu1):
                    eventData.selector = argu1;
                    switch (true) {
                        case (0, _lodash10.default)(argu2) && isEvents:
                            break;
                        case (0, _lodash6.default)(argu2) && !isEvents:
                            eventData.events[argu0] = argu2;
                            break;
                        case argu2 === false:
                            eventData.events[argu2] = falseHandler;
                            break;
                        case (0, _lodash8.default)(argu2) || (0, _lodash2.default)(argu2):
                            eventData.data = argu2;
                            switch (true) {
                                case (0, _lodash10.default)(argu3) && isEvents:
                                    break;
                                case (0, _lodash6.default)(argu3) && !isEvents:
                                    eventData.events[argu0] = argu3;
                                    break;
                                case argu3 === false:
                                    eventData.events[argu3] = falseHandler;
                                    break;
                                default:
                                    throw new Error("Argument type is not correct");
                            }
                            break;
                        default:
                            throw new Error("Argument type is not correct");
                    }
                    break;
                case (0, _lodash8.default)(argu1) || (0, _lodash2.default)(argu1):
                    eventData.data = argu1;
                    switch (true) {
                        case (0, _lodash10.default)(argu2) && isEvents:
                            break;
                        case (0, _lodash6.default)(argu2) && !isEvents:
                            eventData.events[argu0] = argu2;
                            break;
                        case argu2 === false:
                            eventData.events[argu2] = falseHandler;
                            break;
                        default:
                            throw new Error("Argument type is not correct");
                    }
                    break;
                default:
                    throw new Error("Argument type is not correct");
            }
            Object.keys(eventData.events).forEach(function (eventTypeString) {
                _this2.__getArray().forEach(function (node) {
                    var eventOrganizer = node.props.getProp("event");
                    if (!eventOrganizer) {
                        eventOrganizer = new _EventOrgnizer2.default(node);
                        node.props.setProp("event", eventOrganizer);
                    }
                    eventOrganizer.capture(eventTypeString, eventData.events[eventTypeString], eventData.data);
                });
            });
            return this;
        }
    }]);

    return EventHandlerAttachment;
}(_J3ObjectBase3.default);

exports.default = EventHandlerAttachment;

},{"../J3ObjectBase":251,"./EventOrgnizer":248,"lodash.isarray":331,"lodash.isfunction":332,"lodash.isplainobject":334,"lodash.isstring":335,"lodash.isundefined":336}],248:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require("events");

var _lodash = require("lodash.isarray");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventOrganizer = function (_EventEmitter) {
    _inherits(EventOrganizer, _EventEmitter);

    function EventOrganizer(node) {
        _classCallCheck(this, EventOrganizer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EventOrganizer).call(this));

        _this._node = node;
        return _this;
    }

    _createClass(EventOrganizer, [{
        key: "capture",
        value: function capture(eventTypeString, handler, data) {
            var _this2 = this;

            var boundArgu = [];
            if (!(0, _lodash2.default)(data)) {
                boundArgu = [data];
            } else {
                boundArgu = data;
            }
            // TODO: pnly event namespace
            return eventTypeString.split(" ").map(function (eventType) {
                var boundHandler = function boundHandler(e) {
                    e.data = data;
                    boundArgu.unshift(e);
                    handler.apply(_this2._node, boundArgu);
                };
                _this2.on(eventType, boundHandler);
                return boundHandler;
            });
        }
    }, {
        key: "release",
        value: function release(eventTypeString, boundHandler) {
            var _this3 = this;

            var boundHandlers = boundHandler;
            if (!(0, _lodash2.default)(boundHandler)) {
                boundHandlers = [boundHandler];
            }
            eventTypeString.split(" ").forEach(function (eventType) {
                boundHandlers.forEach(function (bh) {
                    _this3.removeListener(eventType, bh);
                });
            });
        }
    }, {
        key: "bubble",
        value: function bubble(eventType, e) {
            e.currentTarget = this._node;
            this.emit(eventType, e);
            if (e.isPropagationStopped()) {
                this._propagateTo(this._node.parent, eventType, e);
            }
        }
    }, {
        key: "_propagateTo",
        value: function _propagateTo(node, eventType, e) {
            var parentEventOrganizer = node.props.getProp("event");
            if (parentEventOrganizer) {
                e.currentTarget = node;
                parentEventOrganizer.bubble(eventType, e);
            } else {
                if (node.parent) {
                    this._propagateTo(node.parent, eventType, e);
                } // else, propagate to scene root.
            }
        }
    }]);

    return EventOrganizer;
}(_events.EventEmitter);

exports.default = EventOrganizer;

},{"events":318,"lodash.isarray":331}],249:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var J3Event = function () {
    function J3Event(obj) {
        var _this = this;

        _classCallCheck(this, J3Event);

        this.eventSource = null;
        this.currentTarget = null;
        this.data = null;
        this.delegateTarget = null;
        this.namespace = null;
        this.relatedTarget = null;
        // not supported;
        // public result: any = null;
        this.target = null;
        this.timeStamp = null;
        this.type = null;
        this.which = null;
        // jThree original
        this.mouseX = null;
        this.mouseY = null;
        this.mouseDiffX = null;
        this.mouseDiffY = null;
        this.region = null;
        this._propagationStopped = false;
        Object.keys(obj).forEach(function (k) {
            if (typeof _this[k] !== "undefined") {
                _this[k] = obj[k];
            }
        });
    }

    _createClass(J3Event, [{
        key: "preventDefault",
        value: function preventDefault() {
            this.eventSource.preventDefault();
        }
    }, {
        key: "isDefaultPrevented",
        value: function isDefaultPrevented() {
            return this.eventSource.defaultPrevented;
        }
    }, {
        key: "stopPropagation",
        value: function stopPropagation() {
            this._propagationStopped = false;
        }
    }, {
        key: "stopImmediatePropagation",
        value: function stopImmediatePropagation() {
            throw new Error("Not supported \"e.stopImmediatePropagation()\"");
        }
    }, {
        key: "isPropagationStopped",
        value: function isPropagationStopped() {
            return this._propagationStopped;
        }
    }, {
        key: "isImmediatePropagationStopped",
        value: function isImmediatePropagationStopped() {
            throw new Error("Not supported \"e.isImmediatePropagationStopped()\"");
        }
    }]);

    return J3Event;
}();

exports.default = J3Event;

},{}],250:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _GomlTreeNodeBase = require("../Goml/GomlTreeNodeBase");

var _GomlTreeNodeBase2 = _interopRequireDefault(_GomlTreeNodeBase);

var _J3ObjectBase2 = require("./J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

var _lodash = require("lodash.isarray");

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require("lodash.isstring");

var _lodash4 = _interopRequireDefault(_lodash3);

var _XMLParser = require("../Goml/XMLParser");

var _XMLParser2 = _interopRequireDefault(_XMLParser);

var _GomlParser = require("../Goml/GomlParser");

var _GomlParser2 = _interopRequireDefault(_GomlParser);

var _JThreeContext = require("../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides jQuery like API for jThree.
 */

var J3Object = function (_J3ObjectBase) {
    _inherits(J3Object, _J3ObjectBase);

    /**
     * Construct J3Object from Nodes or selector query.
     * @param {GomlTreeNodeBase[]} nodes [description]
     */

    function J3Object(argu) {
        _classCallCheck(this, J3Object);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(J3Object).call(this));

        var nodes = undefined;
        var query = undefined;
        switch (true) {
            case (0, _lodash4.default)(argu):
                if (argu.charAt(0) === "<") {
                    (function () {
                        var parseObj = new _XMLParser2.default(argu);
                        var nodeManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.NodeManager);
                        nodes = parseObj.elements.map(function (elem) {
                            return _GomlParser2.default.parse(elem, nodeManager.configurator);
                        });
                    })();
                } else {
                    query = argu;
                }
                break;
            case argu instanceof _GomlTreeNodeBase2.default:
                nodes = [argu];
                break;
            case (0, _lodash2.default)(argu) && argu.every(function (v) {
                return v instanceof _GomlTreeNodeBase2.default;
            }):
                nodes = argu;
                break;
            default:
                throw new Error("Argument type is not correct");
        }
        if (nodes) {
            _this.__setArray(nodes);
        } else if (query) {
            _this.__setArray(J3Object.find(query));
        }
        return _this;
    }

    return J3Object;
}(_J3ObjectBase3.default);

exports.default = J3Object;

},{"../ContextComponents":8,"../Goml/GomlParser":182,"../Goml/GomlTreeNodeBase":183,"../Goml/XMLParser":227,"../JThreeContext":267,"./J3ObjectBase":251,"lodash.isarray":331,"lodash.isstring":335}],251:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var J3ObjectBase = function () {
    function J3ObjectBase() {
        _classCallCheck(this, J3ObjectBase);

        this.length = 0;
    }

    _createClass(J3ObjectBase, [{
        key: "__setArray",
        value: function __setArray(arr) {
            Array.prototype.splice.call(this, 0, this.length);
            Array.prototype.push.apply(this, arr);
        }
    }, {
        key: "__getArray",
        value: function __getArray() {
            return Array.prototype.map.call(this, function (v) {
                return v;
            });
        }
    }]);

    return J3ObjectBase;
}();

exports.default = J3ObjectBase;

},{}],252:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _J3Object = require("./J3Object");

var _J3Object2 = _interopRequireDefault(_J3Object);

var _GomlNodeMethods = require("./Miscellaneous/GomlNodeMethods");

var _GomlNodeMethods2 = _interopRequireDefault(_GomlNodeMethods);

var _TreeTraversal = require("./Traversing/TreeTraversal");

var _TreeTraversal2 = _interopRequireDefault(_TreeTraversal);

var _Filtering = require("./Traversing/Filtering");

var _Filtering2 = _interopRequireDefault(_Filtering);

var _GeneralAttributes = require("./Manipulation/GeneralAttributes");

var _GeneralAttributes2 = _interopRequireDefault(_GeneralAttributes);

var _CollectionManipulation = require("./Manipulation/CollectionManipulation");

var _CollectionManipulation2 = _interopRequireDefault(_CollectionManipulation);

var _NodeInsertionInside = require("./Manipulation/NodeInsertionInside");

var _NodeInsertionInside2 = _interopRequireDefault(_NodeInsertionInside);

var _NodeRemoval = require("./Manipulation/NodeRemoval");

var _NodeRemoval2 = _interopRequireDefault(_NodeRemoval);

var _Basic = require("./Effects/Basic");

var _Basic2 = _interopRequireDefault(_Basic);

var _Module = require("./Modules/Module");

var _Module2 = _interopRequireDefault(_Module);

var _Custom = require("./Effects/Custom");

var _Custom2 = _interopRequireDefault(_Custom);

var _EventHandlerAttachment = require("./Events/EventHandlerAttachment");

var _EventHandlerAttachment2 = _interopRequireDefault(_EventHandlerAttachment);

var _Utilities = require("./Static/Utilities");

var _Utilities2 = _interopRequireDefault(_Utilities);

var _Find = require("./Static/Find");

var _Find2 = _interopRequireDefault(_Find);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function J3ObjectMixins() {
    var mixins = [_GomlNodeMethods2.default, _TreeTraversal2.default, _Filtering2.default, _GeneralAttributes2.default, _CollectionManipulation2.default, _NodeInsertionInside2.default, _NodeRemoval2.default, _Basic2.default, _Module2.default, _Custom2.default, _EventHandlerAttachment2.default];
    var staticMixins = [_Utilities2.default, _Find2.default];
    function applyMixins(derivedCtor, baseCtors) {
        baseCtors.forEach(function (baseCtor) {
            Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
                if (name !== "constructor") {
                    var descriptor = {
                        value: baseCtor.prototype[name],
                        enumerable: false,
                        configurable: true,
                        writable: true
                    };
                    Object.defineProperty(derivedCtor.prototype, name, descriptor);
                }
            });
        });
    }
    function applyStaticMixins(derivedCtor, baseCtors) {
        baseCtors.forEach(function (baseCtor) {
            Object.getOwnPropertyNames(baseCtor).forEach(function (name) {
                if (name !== "prototype" && name !== "name" && name !== "length" && name !== "arguments" && name !== "caller") {
                    var descriptor = {
                        value: baseCtor[name],
                        enumerable: false,
                        configurable: true,
                        writable: true
                    };
                    Object.defineProperty(derivedCtor, name, descriptor);
                }
            });
        });
    }
    applyMixins(_J3Object2.default, mixins);
    applyStaticMixins(_J3Object2.default, staticMixins);
}
exports.default = J3ObjectMixins;

},{"./Effects/Basic":229,"./Effects/Custom":230,"./Events/EventHandlerAttachment":247,"./J3Object":250,"./Manipulation/CollectionManipulation":253,"./Manipulation/GeneralAttributes":254,"./Manipulation/NodeInsertionInside":255,"./Manipulation/NodeRemoval":256,"./Miscellaneous/GomlNodeMethods":257,"./Modules/Module":258,"./Static/Find":260,"./Static/Utilities":264,"./Traversing/Filtering":265,"./Traversing/TreeTraversal":266}],253:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3ObjectBase2 = require("../J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BreakException = {};

var CollectionManipulation = function (_J3ObjectBase) {
    _inherits(CollectionManipulation, _J3ObjectBase);

    function CollectionManipulation() {
        _classCallCheck(this, CollectionManipulation);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(CollectionManipulation).apply(this, arguments));
    }

    _createClass(CollectionManipulation, [{
        key: "each",
        value: function each(func) {
            try {
                Array.prototype.forEach.call(this, function (node, index) {
                    var ret = func.bind(node)(index, node);
                    if (ret === false) {
                        throw BreakException;
                    }
                });
            } catch (e) {
                if (e !== BreakException) {
                    throw e;
                }
            }
            return this;
        }
    }]);

    return CollectionManipulation;
}(_J3ObjectBase3.default);

exports.default = CollectionManipulation;

},{"../J3ObjectBase":251}],254:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3ObjectBase2 = require("../J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

var _lodash = require("lodash.isstring");

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require("lodash.isundefined");

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require("lodash.isplainobject");

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require("lodash.isfunction");

var _lodash8 = _interopRequireDefault(_lodash7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GeneralAttribute = function (_J3ObjectBase) {
    _inherits(GeneralAttribute, _J3ObjectBase);

    function GeneralAttribute() {
        _classCallCheck(this, GeneralAttribute);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(GeneralAttribute).apply(this, arguments));
    }

    _createClass(GeneralAttribute, [{
        key: "attr",
        value: function attr(argu0, argu1) {
            var _this2 = this;

            if (this.length === 0) {
                throw new Error("No target");
            }
            if ((0, _lodash2.default)(argu0)) {
                switch (true) {
                    case (0, _lodash4.default)(argu1):
                        return this[0].attributes.getValueStr(argu0);
                    case (0, _lodash8.default)(argu1):
                        throw new Error("Not implemented yet");
                    default:
                        this.__getArray().forEach(function (node) {
                            GeneralAttribute._setAttr(node, argu0, argu1);
                        });
                        return this;
                }
            } else if ((0, _lodash6.default)(argu0)) {
                Object.keys(argu0).forEach(function (attributeName) {
                    GeneralAttribute._setAttr(_this2[0], attributeName, argu0[attributeName]);
                });
                return this;
            } else {
                throw new Error("Argument type is not correct");
            }
        }
    }, {
        key: "attrObj",
        value: function attrObj(argu0, argu1) {
            var _this3 = this;

            if (this.length === 0) {
                throw new Error("No target");
            }
            if ((0, _lodash2.default)(argu0)) {
                switch (true) {
                    case (0, _lodash4.default)(argu1):
                        return this[0].attributes.getValue(argu0);
                    default:
                        this.__getArray().forEach(function (node) {
                            GeneralAttribute._setAttr(node, argu0, argu1);
                        });
                        return this;
                }
            } else if ((0, _lodash6.default)(argu0)) {
                Object.keys(argu0).forEach(function (attributeName) {
                    GeneralAttribute._setAttr(_this3[0], attributeName, argu0[attributeName]);
                });
                return this;
            } else {
                throw new Error("Argument type is not correct");
            }
        }
    }], [{
        key: "_setAttr",
        value: function _setAttr(node, attributeName, value) {
            if (node.attributes.isDefined(attributeName)) {
                node.attributes.setValue(attributeName, value);
            } else {
                var gomlAttribute = node.attributes.reserveAttribute(attributeName, value);
                gomlAttribute.on("changed", function (ga) {
                    node.props.getProp("elem").setAttribute(attributeName, ga.Value);
                });
                gomlAttribute.notifyValueChanged();
            }
        }
    }]);

    return GeneralAttribute;
}(_J3ObjectBase3.default);

exports.default = GeneralAttribute;

},{"../J3ObjectBase":251,"lodash.isfunction":332,"lodash.isplainobject":334,"lodash.isstring":335,"lodash.isundefined":336}],255:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3ObjectBase2 = require("../J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

var _SomeToNodes = require("../Static/SomeToNodes");

var _SomeToNodes2 = _interopRequireDefault(_SomeToNodes);

var _NodeOperation = require("../Static/NodeOperation");

var _NodeOperation2 = _interopRequireDefault(_NodeOperation);

var _lodash = require("lodash.isfunction");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NodeInsertionInside = function (_J3ObjectBase) {
    _inherits(NodeInsertionInside, _J3ObjectBase);

    function NodeInsertionInside() {
        _classCallCheck(this, NodeInsertionInside);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(NodeInsertionInside).apply(this, arguments));
    }

    _createClass(NodeInsertionInside, [{
        key: "append",
        value: function append() {
            var _this2 = this;

            for (var _len = arguments.length, argu = Array(_len), _key = 0; _key < _len; _key++) {
                argu[_key] = arguments[_key];
            }

            argu.forEach(function (argu_, i) {
                if (i === 0 && (0, _lodash2.default)(argu_)) {
                    throw new Error("Not implemented yet");
                } else {
                    var targets = _this2.__getArray();
                    var contents = _SomeToNodes2.default.convert(argu_, ["xmlstring", "node", "node[]", "j3obj", "j3obj[]"]);
                    if (!contents) {
                        throw new Error("Argument type is not correct");
                    }
                    _NodeOperation2.default.insert(targets, contents);
                }
            });
            return this;
        }
    }, {
        key: "appendTo",
        value: function appendTo(argu) {
            var targets = _SomeToNodes2.default.convert(argu, ["selector", "xmlstring", "node", "node[]", "j3obj", "j3obj[]"]);
            var contents = this.__getArray();
            if (!targets) {
                throw new Error("Argument type is not correct");
            }
            _NodeOperation2.default.insert(targets, contents);
            return this;
        }
    }]);

    return NodeInsertionInside;
}(_J3ObjectBase3.default);

exports.default = NodeInsertionInside;

},{"../J3ObjectBase":251,"../Static/NodeOperation":261,"../Static/SomeToNodes":263,"lodash.isfunction":332}],256:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3ObjectBase2 = require("../J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

var _Filter = require("../Static/Filter");

var _Filter2 = _interopRequireDefault(_Filter);

var _NodeOperation = require("../Static/NodeOperation");

var _NodeOperation2 = _interopRequireDefault(_NodeOperation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NodeRemoval = function (_J3ObjectBase) {
    _inherits(NodeRemoval, _J3ObjectBase);

    function NodeRemoval() {
        _classCallCheck(this, NodeRemoval);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(NodeRemoval).apply(this, arguments));
    }

    _createClass(NodeRemoval, [{
        key: "remove",
        value: function remove(argu) {
            var target = _Filter2.default.filter(this.__getArray(), argu, ["selector"]);
            console.log(target);
            _NodeOperation2.default.remove(target);
            return this;
        }
    }]);

    return NodeRemoval;
}(_J3ObjectBase3.default);

exports.default = NodeRemoval;

},{"../J3ObjectBase":251,"../Static/Filter":259,"../Static/NodeOperation":261}],257:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3Object = require("../J3Object");

var _J3Object2 = _interopRequireDefault(_J3Object);

var _J3ObjectBase2 = require("../J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

var _GomlTreeNodeBase = require("../../Goml/GomlTreeNodeBase");

var _GomlTreeNodeBase2 = _interopRequireDefault(_GomlTreeNodeBase);

var _CoreRelatedNodeBase = require("../../Goml/CoreRelatedNodeBase");

var _CoreRelatedNodeBase2 = _interopRequireDefault(_CoreRelatedNodeBase);

var _lodash = require("lodash.isnumber");

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require("lodash.isundefined");

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require("lodash.isstring");

var _lodash6 = _interopRequireDefault(_lodash5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GomlNodeMethods = function (_J3ObjectBase) {
    _inherits(GomlNodeMethods, _J3ObjectBase);

    function GomlNodeMethods() {
        _classCallCheck(this, GomlNodeMethods);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(GomlNodeMethods).apply(this, arguments));
    }

    _createClass(GomlNodeMethods, [{
        key: "get",
        value: function get(argu) {
            switch (true) {
                case (0, _lodash2.default)(argu):
                    return this[argu];
                case (0, _lodash4.default)(argu):
                    return this.__getArray();
                default:
                    throw new Error("Argument type is not correct");
            }
        }
    }, {
        key: "getObj",
        value: function getObj(argu) {
            switch (true) {
                case (0, _lodash2.default)(argu):
                    var node = this[argu];
                    return node instanceof _CoreRelatedNodeBase2.default ? node.target : null;
                case (0, _lodash4.default)(argu):
                    return this.__getArray().map(function (node) {
                        return node instanceof _CoreRelatedNodeBase2.default ? node.target : null;
                    });
                default:
                    throw new Error("Argument type is not correct");
            }
        }
    }, {
        key: "index",
        value: function index(argu) {
            var index_ = -1;
            switch (true) {
                case (0, _lodash6.default)(argu):
                    var foundNodes = _J3Object2.default.find(argu);
                    _J3Object2.default.each(this, function (i, node) {
                        if (foundNodes.indexOf(node) !== -1) {
                            index_ = i;
                            return false;
                        }
                    });
                    break;
                case argu instanceof _GomlTreeNodeBase2.default:
                    index_ = this.__getArray().indexOf(argu);
                    break;
                case argu instanceof _J3Object2.default:
                    _J3Object2.default.each(this, function (i, node) {
                        if (argu.index(node) !== -1) {
                            index_ = i;
                            return false;
                        }
                    });
                    break;
                default:
                    throw new Error("Argument type is not correct");
            }
            return index_;
        }
    }]);

    return GomlNodeMethods;
}(_J3ObjectBase3.default);

exports.default = GomlNodeMethods;

},{"../../Goml/CoreRelatedNodeBase":174,"../../Goml/GomlTreeNodeBase":183,"../J3Object":250,"../J3ObjectBase":251,"lodash.isnumber":333,"lodash.isstring":335,"lodash.isundefined":336}],258:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3ObjectBase2 = require("../J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _lodash = require("lodash.isundefined");

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require("lodash.isplainobject");

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require("lodash.isfunction");

var _lodash6 = _interopRequireDefault(_lodash5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Module = function (_J3ObjectBase) {
    _inherits(Module, _J3ObjectBase);

    function Module() {
        _classCallCheck(this, Module);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Module).apply(this, arguments));
    }

    _createClass(Module, [{
        key: "module",
        value: function module(argu) {
            switch (true) {
                case (0, _lodash2.default)(argu):
                    return this.__getArray().map(function (node) {
                        node.props.getProp("module");
                    });
                case (0, _lodash4.default)(argu) || (0, _lodash6.default)(argu):
                    var moduleManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ModuleManager);
                    return this.__getArray().map(function (node) {
                        var moduleRegistry = moduleManager.addModule(argu);
                        var moduleInstance = moduleRegistry.apply(node);
                        moduleInstance.enabled = true;
                        return moduleInstance;
                    });
                default:
                    throw new Error("Argument type is not correct");
            }
        }
    }]);

    return Module;
}(_J3ObjectBase3.default);

exports.default = Module;

},{"../../ContextComponents":8,"../../JThreeContext":267,"../J3ObjectBase":251,"lodash.isfunction":332,"lodash.isplainobject":334,"lodash.isundefined":336}],259:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SomeToNodes = require("./SomeToNodes");

var _SomeToNodes2 = _interopRequireDefault(_SomeToNodes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Filter = function () {
    function Filter() {
        _classCallCheck(this, Filter);
    }

    _createClass(Filter, null, [{
        key: "filter",
        value: function filter(target, _filter, filterType) {
            var filterNodes = _SomeToNodes2.default.convert(_filter, filterType);
            filterNodes = filterNodes === null ? [] : filterNodes;
            return target.filter(function (t) {
                return filterNodes.indexOf(t) !== -1;
            });
        }
    }]);

    return Filter;
}();

exports.default = Filter;

},{"./SomeToNodes":263}],260:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Find = function () {
    function Find() {
        _classCallCheck(this, Find);
    }

    _createClass(Find, null, [{
        key: "find",

        /**
         * Search Node from selector query.
         * @param  {string}             selector selector query string.
         * @param  {GomlTreeNodeBase}   context  target for searching.
         * @return {GomlTreeNodeBase[]}          found Nodes.
         */
        value: function find(selector, context) {
            return _JThreeContext2.default.getContextComponent(_ContextComponents2.default.NodeManager).getNodeByQuery(selector, context);
        }
    }]);

    return Find;
}();

exports.default = Find;

},{"../../ContextComponents":8,"../../JThreeContext":267}],261:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NodeOperation = function () {
    function NodeOperation() {
        _classCallCheck(this, NodeOperation);
    }

    _createClass(NodeOperation, null, [{
        key: "insert",
        value: function insert(targets, contents, index) {
            var nodeManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.NodeManager);
            targets.forEach(function (target, i) {
                var nodeOpMethod = nodeManager.insertNode;
                if (i === targets.length) {
                    nodeOpMethod = nodeManager.moveNode;
                }
                contents.forEach(function (content, j) {
                    nodeOpMethod(content, target, typeof index === "undefined" ? void 0 : index + j);
                });
            });
        }
    }, {
        key: "remove",
        value: function remove(targets) {
            var nodeManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.NodeManager);
            targets.forEach(function (target, i) {
                nodeManager.removeNode(target);
            });
        }
    }]);

    return NodeOperation;
}();

exports.default = NodeOperation;

},{"../../ContextComponents":8,"../../JThreeContext":267}],262:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SceneObjectNodeBase = require("../../Goml/Nodes/SceneObjects/SceneObjectNodeBase");

var _SceneObjectNodeBase2 = _interopRequireDefault(_SceneObjectNodeBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SceneUtilities = function () {
    function SceneUtilities() {
        _classCallCheck(this, SceneUtilities);
    }

    _createClass(SceneUtilities, null, [{
        key: "filterSceneObjectNode",
        value: function filterSceneObjectNode(targetNodes) {
            return targetNodes.filter(function (node) {
                return node instanceof _SceneObjectNodeBase2.default;
            });
        }
    }]);

    return SceneUtilities;
}();

exports.default = SceneUtilities;

},{"../../Goml/Nodes/SceneObjects/SceneObjectNodeBase":213}],263:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3Object = require("../J3Object");

var _J3Object2 = _interopRequireDefault(_J3Object);

var _GomlTreeNodeBase = require("../../Goml/GomlTreeNodeBase");

var _GomlTreeNodeBase2 = _interopRequireDefault(_GomlTreeNodeBase);

var _XMLParser = require("../../Goml/XMLParser");

var _XMLParser2 = _interopRequireDefault(_XMLParser);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _GomlParser = require("../../Goml/GomlParser");

var _GomlParser2 = _interopRequireDefault(_GomlParser);

var _lodash = require("lodash.isstring");

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require("lodash.isarray");

var _lodash4 = _interopRequireDefault(_lodash3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SomeToNode = function () {
    function SomeToNode() {
        _classCallCheck(this, SomeToNode);
    }

    _createClass(SomeToNode, null, [{
        key: "convert",
        value: function convert(target, filterType) {
            var nodeManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.NodeManager);
            var targets = [];
            var isArrayFlag = false;
            if ((0, _lodash4.default)(target)) {
                isArrayFlag = true;
                if (filterType.map(function (v) {
                    return v.substr(-2, 2) === "[]";
                }).some(function (v) {
                    return v;
                })) {
                    targets = target;
                } else {
                    return null;
                }
            } else {
                targets = [target];
            }
            var converted_nested = targets.map(function (t) {
                var ret = null;
                switch (true) {
                    case (0, _lodash2.default)(t):
                        var isXml = false;
                        if (isArrayFlag ? filterType.indexOf("xmlstring[]") !== -1 : filterType.indexOf("xmlstring") !== -1) {
                            isXml = t.charAt(0) === "<";
                        }
                        if (isXml) {
                            // t is xml
                            var parseObj = new _XMLParser2.default(t);
                            ret = parseObj.elements.map(function (elem, i) {
                                return _GomlParser2.default.parse(elem, nodeManager.configurator);
                            });
                        } else if (isArrayFlag ? filterType.indexOf("selector[]") !== -1 : filterType.indexOf("selector") !== -1) {
                            // t is selector
                            ret = _J3Object2.default.find(t);
                        } else {
                            ret = null;
                        }
                        break;
                    case t instanceof _GomlTreeNodeBase2.default && (isArrayFlag ? filterType.indexOf("node[]") !== -1 : filterType.indexOf("node") !== -1):
                        ret = [t];
                        break;
                    case t instanceof _J3Object2.default && (isArrayFlag ? filterType.indexOf("j3obj[]") !== -1 : filterType.indexOf("j3obj") !== -1):
                        ret = [];
                        _J3Object2.default.each(t, function (i, node) {
                            ret.push(node);
                        });
                        break;
                    default:
                        ret = null;
                }
                return ret;
            });
            var converted = Array.prototype.concat.apply([], converted_nested);
            if (converted.some(function (v) {
                return v === null;
            })) {
                return null;
            } else {
                return converted;
            }
        }
    }]);

    return SomeToNode;
}();

exports.default = SomeToNode;

},{"../../ContextComponents":8,"../../Goml/GomlParser":182,"../../Goml/GomlTreeNodeBase":183,"../../Goml/XMLParser":227,"../../JThreeContext":267,"../J3Object":250,"lodash.isarray":331,"lodash.isstring":335}],264:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require("lodash.isarray");

var _lodash2 = _interopRequireDefault(_lodash);

var _J3Object = require("../J3Object");

var _J3Object2 = _interopRequireDefault(_J3Object);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BreakException = {};

var Utilities = function () {
    function Utilities() {
        _classCallCheck(this, Utilities);
    }

    _createClass(Utilities, null, [{
        key: "each",
        value: function each(argu0, callback) {
            try {
                if ((0, _lodash2.default)(argu0) || argu0 instanceof _J3Object2.default) {
                    Array.prototype.forEach.call(argu0, function (value, indexInArray) {
                        var ret = callback.bind(value)(indexInArray, value);
                        if (ret === false) {
                            throw BreakException;
                        }
                    });
                } else {
                    Object.keys(argu0).forEach(function (propertyName, index) {
                        var valueOfProperty = argu0[propertyName];
                        var ret = callback.bind(valueOfProperty)(propertyName, valueOfProperty);
                        if (ret === false) {
                            throw BreakException;
                        }
                    });
                }
            } catch (e) {
                if (e !== BreakException) {
                    throw e;
                }
            }
            return argu0;
        }
    }]);

    return Utilities;
}();

exports.default = Utilities;

},{"../J3Object":250,"lodash.isarray":331}],265:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3Object = require("../J3Object");

var _J3Object2 = _interopRequireDefault(_J3Object);

var _J3ObjectBase2 = require("../J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

var _GomlTreeNodeBase = require("../../Goml/GomlTreeNodeBase");

var _GomlTreeNodeBase2 = _interopRequireDefault(_GomlTreeNodeBase);

var _Filter = require("../Static/Filter");

var _Filter2 = _interopRequireDefault(_Filter);

var _lodash = require("lodash.isstring");

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require("lodash.isarray");

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require("lodash.isfunction");

var _lodash6 = _interopRequireDefault(_lodash5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Filtering = function (_J3ObjectBase) {
    _inherits(Filtering, _J3ObjectBase);

    function Filtering() {
        _classCallCheck(this, Filtering);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Filtering).apply(this, arguments));
    }

    _createClass(Filtering, [{
        key: "filter",
        value: function filter(argu) {
            var thisNodes = this.__getArray();
            var nodes = [];
            switch (true) {
                case (0, _lodash2.default)(argu) || (0, _lodash4.default)(argu) && argu.every(function (v) {
                    return v instanceof _GomlTreeNodeBase2.default;
                }) || argu instanceof _GomlTreeNodeBase2.default || argu instanceof _J3Object2.default:
                    nodes = _Filter2.default.filter(thisNodes, argu, ["selector", "node", "node[]", "j3obj"]);
                    break;
                case (0, _lodash6.default)(argu):
                    nodes = thisNodes.filter(function (node, index) {
                        return argu(index, node);
                    });
                    break;
                default:
                    throw new Error("Argument type is not correct");
            }
            return new _J3Object2.default(nodes);
        }
    }]);

    return Filtering;
}(_J3ObjectBase3.default);

exports.default = Filtering;

},{"../../Goml/GomlTreeNodeBase":183,"../J3Object":250,"../J3ObjectBase":251,"../Static/Filter":259,"lodash.isarray":331,"lodash.isfunction":332,"lodash.isstring":335}],266:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _J3Object = require("../J3Object");

var _J3Object2 = _interopRequireDefault(_J3Object);

var _J3ObjectBase2 = require("../J3ObjectBase");

var _J3ObjectBase3 = _interopRequireDefault(_J3ObjectBase2);

var _GomlTreeNodeBase = require("../../Goml/GomlTreeNodeBase");

var _GomlTreeNodeBase2 = _interopRequireDefault(_GomlTreeNodeBase);

var _lodash = require("lodash.isstring");

var _lodash2 = _interopRequireDefault(_lodash);

var _Filter = require("../Static/Filter");

var _Filter2 = _interopRequireDefault(_Filter);

var _lodash3 = require("lodash.isundefined");

var _lodash4 = _interopRequireDefault(_lodash3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TreeTraversal = function (_J3ObjectBase) {
    _inherits(TreeTraversal, _J3ObjectBase);

    function TreeTraversal() {
        _classCallCheck(this, TreeTraversal);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(TreeTraversal).apply(this, arguments));
    }

    _createClass(TreeTraversal, [{
        key: "find",
        value: function find(argu) {
            switch (true) {
                case (0, _lodash2.default)(argu):
                    var ret_node = [];
                    this.__getArray().forEach(function (node) {
                        ret_node = ret_node.concat(_J3Object2.default.find(argu, node));
                    });
                    return new _J3Object2.default(ret_node);
                case argu instanceof _GomlTreeNodeBase2.default:
                    throw new Error("Not implemented yet");
                case argu instanceof _J3Object2.default:
                    throw new Error("Not implemented yet");
                default:
                    throw new Error("Argument type is not correct");
            }
        }
    }, {
        key: "children",
        value: function children(argu) {
            switch (true) {
                case (0, _lodash4.default)(argu):
                    return new _J3Object2.default(Array.prototype.concat.apply([], this.__getArray().map(function (node) {
                        return node.children;
                    })));
                case (0, _lodash2.default)(argu):
                    return new _J3Object2.default(_Filter2.default.filter(Array.prototype.concat.apply([], this.__getArray().map(function (node) {
                        return node.children;
                    })), argu, ["selector"]));
                default:
                    throw new Error("Argument type is not correct");
            }
        }
    }]);

    return TreeTraversal;
}(_J3ObjectBase3.default);

exports.default = TreeTraversal;

},{"../../Goml/GomlTreeNodeBase":183,"../J3Object":250,"../J3ObjectBase":251,"../Static/Filter":259,"lodash.isstring":335,"lodash.isundefined":336}],267:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Most top level api container for jThree.
 * @type {[type]}
 */

var JThreeContext = function () {
    function JThreeContext() {
        _classCallCheck(this, JThreeContext);

        /**
         * Registered context component references
         */
        this._contextComponents = {};
    }
    /**
     * Initialize jThreeContext to be used.
     */


    _createClass(JThreeContext, null, [{
        key: "init",
        value: function init() {
            if (!window.j3.context) {
                window.j3.context = new JThreeContext();
            }
        }
        /**
         * Register context component
         * @param  {IContextComponent} contextComponent context component you want to register
         */

    }, {
        key: "registerContextComponent",
        value: function registerContextComponent(contextComponent) {
            if (JThreeContext.context._contextComponents[contextComponent.getContextComponentIndex()]) {
                console.warn("Reregisteration of context component");
            }
            JThreeContext.context._contextComponents[contextComponent.getContextComponentIndex()] = contextComponent;
        }
        /**
         * Get registered context component
         * @param  {number}            index context component index of a context component you want to obtain.
         * @return {IContextComponent}      context component related to the argument
         */

    }, {
        key: "getContextComponent",
        value: function getContextComponent(index) {
            return JThreeContext.context._contextComponents[index];
        }
    }, {
        key: "context",
        get: function get() {
            return window.j3.context;
        }
    }]);

    return JThreeContext;
}();

exports.default = JThreeContext;

},{}],268:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = require("./Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Axis-Aligned Bounding Box implementation
 */

var AABB = function () {
    function AABB() {
        _classCallCheck(this, AABB);
    }

    _createClass(AABB, [{
        key: "expandAABB",

        /**
         * Calculate new bounding box with considering the new point is included.
         * @param  {Vector3} newPoint the point that will be considered that it should be in this bounding box.
         */
        value: function expandAABB(newPoint) {
            if (this.pointLBF == null) {
                // assume this is first time to be used this AABB instance
                this.pointLBF = _Vector2.default.copy(newPoint);
                this.pointRTN = _Vector2.default.copy(newPoint);
            }
            this.pointLBF = _Vector2.default.min(newPoint, this.pointLBF);
            this.pointRTN = _Vector2.default.max(newPoint, this.pointRTN);
        }
        /**
         * Clean up this AABB with initial value.
         */

    }, {
        key: "clear",
        value: function clear() {
            this.pointLBF = null;
            this.pointRTN = null;
        }
    }, {
        key: "toMathematicaCuboid",
        value: function toMathematicaCuboid() {
            return "Cuboid[" + this.pointLBF.toMathematicaString() + "," + this.pointRTN.toMathematicaString() + "]";
        }
    }, {
        key: "Width",

        /**
         * Width of this AABB
         */
        get: function get() {
            return Math.abs(this.pointLBF.X - this.pointRTN.X);
        }
        /**
         * Height of this AABB
         */

    }, {
        key: "Height",
        get: function get() {
            return Math.abs(this.pointLBF.Y - this.pointRTN.Y);
        }
        /**
         * Distance of this AABB
         */

    }, {
        key: "Distance",
        get: function get() {
            return Math.abs(this.pointLBF.Z - this.pointRTN.Z);
        }
    }]);

    return AABB;
}();

exports.default = AABB;

},{"./Vector3":278}],269:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _VectorBase2 = require("../Math/VectorBase");

var _VectorBase3 = _interopRequireDefault(_VectorBase2);

var _Vector = require("./Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _Color = require("./Color4");

var _Color2 = _interopRequireDefault(_Color);

var _Vector3 = require("./Vector4");

var _Vector4 = _interopRequireDefault(_Vector3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Color3 = function (_VectorBase) {
    _inherits(Color3, _VectorBase);

    function Color3(r, g, b) {
        _classCallCheck(this, Color3);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Color3).call(this));

        _this.rawElements = [r, g, b];
        return _this;
    }

    _createClass(Color3, [{
        key: "toVector",
        value: function toVector() {
            return new _Vector2.default(this.R, this.G, this.B);
        }
    }, {
        key: "toVector4",
        value: function toVector4(a) {
            if (typeof a === "undefined") {
                a = 0;
            }
            return new _Vector4.default(this.R, this.G, this.B, a);
        }
    }, {
        key: "equalWith",
        value: function equalWith(col) {
            return Color3.equals(col, this);
        }
    }, {
        key: "toString",
        value: function toString() {
            return "rgb(" + Math.round(this.R * 255) + ", " + Math.round(this.G * 255) + ", " + Math.round(this.B * 255) + ")";
        }
    }, {
        key: "toDisplayString",
        value: function toDisplayString() {
            var st = "#";
            st += Math.round(this.R * 0xff).toString(16).toUpperCase();
            st += Math.round(this.G * 0xff).toString(16).toUpperCase();
            st += Math.round(this.B * 0xff).toString(16).toUpperCase();
            return "Color3(" + this.R + ", " + this.G + ", " + this.B + ", " + st + ")";
        }
    }, {
        key: "R",
        get: function get() {
            return this.rawElements[0];
        }
    }, {
        key: "G",
        get: function get() {
            return this.rawElements[1];
        }
    }, {
        key: "B",
        get: function get() {
            return this.rawElements[2];
        }
    }, {
        key: "ElementCount",
        get: function get() {
            return 3;
        }
    }], [{
        key: "fromColor4",
        value: function fromColor4(col) {
            return new Color3(col.R, col.G, col.B);
        }
    }, {
        key: "parse",
        value: function parse(color, tryParse) {
            return Color3.internalParse(color, true, tryParse);
        }
        /// Color parser for css like syntax

    }, {
        key: "internalParse",
        value: function internalParse(color, isFirst, tryParse) {
            if (isFirst && _Color2.default.colorTable[color]) {
                var col = _Color2.default.internalParse(_Color2.default.colorTable[color], false, tryParse);
                return Color3.fromColor4(col);
            }
            var m = undefined;
            if (isFirst) {
                m = color.match(/^#([0-9a-f]{3})$/i);
                // #fff
                if (m) {
                    var s = m[1];
                    return new Color3(parseInt(s.charAt(0), 16) / 0xf, parseInt(s.charAt(1), 16) / 0xf, parseInt(s.charAt(2), 16) / 0xf);
                }
            }
            // #ffffff
            m = color.match(/^#([0-9a-f]{6})$/i);
            if (m) {
                var _s = m[1];
                return new Color3(parseInt(_s.substr(0, 2), 16) / 0xff, parseInt(_s.substr(2, 2), 16) / 0xff, parseInt(_s.substr(4, 2), 16) / 0xff);
            }
            var n = color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
            if (n && isFirst) {
                return new Color3(parseInt(n[1], 10) / 0xff, parseInt(n[2], 10) / 0xff, parseInt(n[3], 10) / 0xff);
            }
            if (tryParse) {
                return undefined;
            }
            throw new Error("Unexpected color string" + color);
        }
    }, {
        key: "equals",
        value: function equals(col1, col2) {
            return _VectorBase3.default.__elementEquals(col1, col2);
        }
    }]);

    return Color3;
}(_VectorBase3.default);

Color3.colorTable = require("../static/color.json");
exports.default = Color3;

},{"../Math/VectorBase":281,"../static/color.json":316,"./Color4":270,"./Vector3":278,"./Vector4":279}],270:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _VectorBase2 = require("./VectorBase");

var _VectorBase3 = _interopRequireDefault(_VectorBase2);

var _Vector = require("./Vector4");

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Color4 = function (_VectorBase) {
    _inherits(Color4, _VectorBase);

    function Color4(r, g, b, a) {
        _classCallCheck(this, Color4);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Color4).call(this));

        _this.rawElements = [r, g, b, a];
        return _this;
    }
    /// Color parser for css like syntax


    _createClass(Color4, [{
        key: "toVector",
        value: function toVector() {
            return new _Vector2.default(this.R, this.G, this.B, this.A);
        }
    }, {
        key: "equalWith",
        value: function equalWith(col) {
            return Color4.equals(col, this);
        }
    }, {
        key: "toString",
        value: function toString() {
            return "rgba(" + Math.round(this.R * 255) + ", " + Math.round(this.G * 255) + ", " + Math.round(this.B * 255) + ", " + Math.round(this.A * 255) + ")";
        }
    }, {
        key: "toDisplayString",
        value: function toDisplayString() {
            var st = "#";
            st += Math.round(this.R * 0xff).toString(16).toUpperCase();
            st += Math.round(this.G * 0xff).toString(16).toUpperCase();
            st += Math.round(this.B * 0xff).toString(16).toUpperCase();
            st += Math.round(this.A * 0xff).toString(16).toUpperCase();
            return "Color4(" + this.R + ", " + this.G + ", " + this.B + ", " + this.A + ", " + st + ")";
        }
    }, {
        key: "R",
        get: function get() {
            return this.rawElements[0];
        }
    }, {
        key: "G",
        get: function get() {
            return this.rawElements[1];
        }
    }, {
        key: "B",
        get: function get() {
            return this.rawElements[2];
        }
    }, {
        key: "A",
        get: function get() {
            return this.rawElements[3];
        }
    }, {
        key: "ElementCount",
        get: function get() {
            return 4;
        }
    }], [{
        key: "internalParse",
        value: function internalParse(color, isFirst, tryParse) {
            if (isFirst && Color4.colorTable[color]) {
                return Color4.internalParse(Color4.colorTable[color], false);
            }
            var m = undefined;
            if (isFirst) {
                m = color.match(/^#([0-9a-f]{3})$/i);
                // #fff
                if (m) {
                    var s = m[1];
                    return new Color4(parseInt(s.charAt(0), 16) / 0xf, parseInt(s.charAt(1), 16) / 0xf, parseInt(s.charAt(2), 16) / 0xf, 1);
                }
            }
            if (isFirst) {
                m = color.match(/^#([0-9a-f]{4})$/i);
                // #ffff
                if (m) {
                    var _s = m[1];
                    return new Color4(parseInt(_s.charAt(0), 16) / 0xf, parseInt(_s.charAt(1), 16) / 0xf, parseInt(_s.charAt(2), 16) / 0xf, parseInt(_s.charAt(3), 16) / 0xf);
                }
            }
            // #ffffff
            m = color.match(/^#([0-9a-f]{6})$/i);
            if (m) {
                var _s2 = m[1];
                return new Color4(parseInt(_s2.substr(0, 2), 16) / 0xff, parseInt(_s2.substr(2, 2), 16) / 0xff, parseInt(_s2.substr(4, 2), 16) / 0xff, 1);
            }
            // #ffffffff
            if (isFirst) {
                m = color.match(/^#([0-9a-f]{8})$/i);
                if (m) {
                    var _s3 = m[1];
                    return new Color4(parseInt(_s3.substr(0, 2), 16) / 0xff, parseInt(_s3.substr(2, 2), 16) / 0xff, parseInt(_s3.substr(4, 2), 16) / 0xff, parseInt(_s3.substr(6, 2), 16) / 0xff);
                }
            }
            var n = color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
            if (n && isFirst) {
                return new Color4(parseInt(n[1], 10) / 0xff, parseInt(n[2], 10) / 0xff, parseInt(n[3], 10) / 0xff, 1);
            }
            n = color.match(/^rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\,\s*(\d+)\s*\)$/i);
            if (n && isFirst) {
                var d = parseInt(n[4], 10);
                d = d <= 1 ? d : d / 0xff;
                return new Color4(parseInt(n[1], 10) / 0xff, parseInt(n[2], 10) / 0xff, parseInt(n[3], 10) / 0xff, parseInt(n[4], 10));
            }
            if (tryParse) {
                return undefined;
            }
            throw new Error("Unexpected color string" + color);
        }
    }, {
        key: "parse",
        value: function parse(color, tryParse) {
            return Color4.internalParse(color, true, tryParse);
        }
    }, {
        key: "equals",
        value: function equals(col1, col2) {
            return _VectorBase3.default.__elementEquals(col1, col2);
        }
    }]);

    return Color4;
}(_VectorBase3.default);

Color4.colorTable = require("../static/color.json");
exports.default = Color4;

},{"../static/color.json":316,"./Vector4":279,"./VectorBase":281}],271:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MatrixBase2 = require("./MatrixBase");

var _MatrixBase3 = _interopRequireDefault(_MatrixBase2);

var _Vector = require("./Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _Vector3 = require("./Vector4");

var _Vector4 = _interopRequireDefault(_Vector3);

var _glMatrix = require("gl-matrix");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Matrix = function (_MatrixBase) {
    _inherits(Matrix, _MatrixBase);

    function Matrix(arr) {
        _classCallCheck(this, Matrix);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Matrix).call(this));

        if (arr) {
            _this.rawElements = arr;
        } else {
            _this.rawElements = _glMatrix.mat4.create();
        }
        return _this;
    }

    _createClass(Matrix, [{
        key: "getAt",
        value: function getAt(row, colmun) {
            return this.rawElements[colmun * 4 + row];
        }
    }, {
        key: "setAt",
        value: function setAt(row, colmun, val) {
            this.rawElements[colmun * 4 + row] = val;
        }
    }, {
        key: "getBySingleIndex",
        value: function getBySingleIndex(index) {
            return this.rawElements[index];
        }
    }, {
        key: "getColmun",
        value: function getColmun(col) {
            return new _Vector4.default(this.rawElements[col * 4], this.rawElements[col * 4 + 1], this.rawElements[col * 4 + 2], this.rawElements[col * 4 + 3]);
        }
        /**
        * Get row
        * @params row [0-3]
        */

    }, {
        key: "getRow",
        value: function getRow(row) {
            return new _Vector4.default(this.rawElements[row], this.rawElements[row + 4], this.rawElements[row + 8], this.rawElements[row + 12]);
        }
    }, {
        key: "multiplyWith",
        value: function multiplyWith(m) {
            return Matrix.multiply(this, m);
        }
    }, {
        key: "equalWith",
        value: function equalWith(m) {
            return Matrix.equals(m, this);
        }
    }, {
        key: "toString",
        value: function toString() {
            return "|" + this.getBySingleIndex(0) + " " + this.getBySingleIndex(4) + " " + this.getBySingleIndex(8) + " " + this.getBySingleIndex(12) + "|\n\n                 |" + this.getBySingleIndex(1) + " " + this.getBySingleIndex(5) + " " + this.getBySingleIndex(9) + " " + this.getBySingleIndex(13) + "|\n\n                 |" + this.getBySingleIndex(2) + " " + this.getBySingleIndex(6) + " " + this.getBySingleIndex(10) + " " + this.getBySingleIndex(14) + "|\n\n                 |" + this.getBySingleIndex(3) + " " + this.getBySingleIndex(7) + " " + this.getBySingleIndex(11) + " " + this.getBySingleIndex(15) + "|";
        }
    }, {
        key: "toMathematicaString",
        value: function toMathematicaString() {
            return "{{" + this.getBySingleIndex(0) + "," + this.getBySingleIndex(4) + "," + this.getBySingleIndex(8) + "," + this.getBySingleIndex(12) + "},\n                  {" + this.getBySingleIndex(1) + "," + this.getBySingleIndex(5) + "," + this.getBySingleIndex(9) + "," + this.getBySingleIndex(13) + "},\n                  {" + this.getBySingleIndex(2) + "," + this.getBySingleIndex(6) + "," + this.getBySingleIndex(10) + "," + this.getBySingleIndex(14) + "},\n                  {" + this.getBySingleIndex(3) + "," + this.getBySingleIndex(7) + "," + this.getBySingleIndex(11) + "," + this.getBySingleIndex(15) + "}}";
        }
    }, {
        key: "ElementCount",
        get: function get() {
            return 16;
        }
    }, {
        key: "RowCount",
        get: function get() {
            return 4;
        }
    }, {
        key: "ColmunCount",
        get: function get() {
            return 4;
        }
    }], [{
        key: "zero",
        value: function zero() {
            return new Matrix([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        }
    }, {
        key: "identity",
        value: function identity() {
            return new Matrix(_glMatrix.mat4.create());
        }
    }, {
        key: "fromElements",
        value: function fromElements(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
            return new Matrix([m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33]);
        }
    }, {
        key: "fromFunc",
        value: function fromFunc(f) {
            return new Matrix([f(0, 0), f(1, 0), f(2, 0), f(3, 0), f(0, 1), f(1, 1), f(2, 1), f(3, 1), f(0, 2), f(1, 2), f(2, 2), f(3, 2), f(0, 3), f(1, 3), f(2, 3), f(3, 3)]);
        }
    }, {
        key: "equals",
        value: function equals(m1, m2) {
            return Matrix.__elementEquals(m1, m2);
        }
    }, {
        key: "add",
        value: function add(m1, m2) {
            var mat = _glMatrix.mat4.create();
            for (var i = 0; i < 16; i++) {
                mat[i] = m1.rawElements[i] + m2.rawElements[i];
            }
            return new Matrix(mat);
        }
    }, {
        key: "subtract",
        value: function subtract(m1, m2) {
            return Matrix.add(m1, Matrix.negate(m2));
        }
    }, {
        key: "scalarMultiply",
        value: function scalarMultiply(s, m) {
            var newMat = _glMatrix.mat4.create();
            _glMatrix.mat4.multiply(newMat, [s, 0, 0, 0, 0, s, 0, 0, 0, 0, s, 0, 0, 0, 0, s], m.rawElements);
            return new Matrix(newMat);
        }
    }, {
        key: "multiply",
        value: function multiply(m1, m2) {
            var newMat = _glMatrix.mat4.create();
            return new Matrix(_glMatrix.mat4.mul(newMat, m1.rawElements, m2.rawElements));
        }
    }, {
        key: "trs",
        value: function trs(t, rot, s) {
            var newMat = _glMatrix.mat4.create();
            var cacheMat = _glMatrix.mat4.create();
            _glMatrix.mat4.mul(newMat, _glMatrix.mat4.translate(newMat, _glMatrix.mat4.create(), t.rawElements), _glMatrix.mat4.fromQuat(cacheMat, rot.rawElements));
            _glMatrix.mat4.scale(newMat, newMat, s.rawElements);
            return new Matrix(newMat);
        }
    }, {
        key: "negate",
        value: function negate(m) {
            return this.scalarMultiply(-1, m);
        }
    }, {
        key: "transpose",
        value: function transpose(m) {
            var newMat = _glMatrix.mat4.create();
            return new Matrix(_glMatrix.mat4.transpose(newMat, m.rawElements));
        }
    }, {
        key: "transformPoint",
        value: function transformPoint(m, t) {
            var newVec = _glMatrix.vec3.create();
            _glMatrix.vec3.transformMat4(newVec, t.rawElements, m.rawElements);
            return new _Vector2.default(newVec);
        }
    }, {
        key: "transformNormal",
        value: function transformNormal(m, t) {
            var newVec = _glMatrix.vec4.create();
            var trans = _glMatrix.vec4.create();
            trans[0] = t.X;
            trans[1] = t.Y;
            trans[2] = t.Z;
            trans[3] = 0;
            _glMatrix.vec4.transformMat4(newVec, trans, m.rawElements);
            return new _Vector2.default(newVec[0], newVec[1], newVec[2]);
        }
    }, {
        key: "transform",
        value: function transform(m, t) {
            var newVec = _glMatrix.vec4.create();
            var trans = _glMatrix.vec4.create();
            trans[0] = t.X;
            trans[1] = t.Y;
            trans[2] = t.Z;
            trans[3] = t.W;
            _glMatrix.vec4.transformMat4(newVec, trans, m.rawElements);
            return new _Vector4.default(newVec[0], newVec[1], newVec[2], newVec[3]);
        }
        /**
         * Retrieve determinant of passed matrix
         */

    }, {
        key: "determinant",
        value: function determinant(m) {
            return _glMatrix.mat4.determinant(m.rawElements);
        }
        /**
         * Compute inverted passed matrix.
         */

    }, {
        key: "inverse",
        value: function inverse(m) {
            var newMat = _glMatrix.mat4.create();
            return new Matrix(_glMatrix.mat4.invert(newMat, m.rawElements));
        }
        /**
         * Generate linear translation transform matrix.
         */

    }, {
        key: "translate",
        value: function translate(v) {
            var newMat = _glMatrix.mat4.create();
            _glMatrix.mat4.translate(newMat, newMat, v.rawElements);
            return new Matrix(newMat);
        }
        /**
         * Generate linear scaling transform matrix.
         */

    }, {
        key: "scale",
        value: function scale(v) {
            var newMat = _glMatrix.mat4.create();
            _glMatrix.mat4.scale(newMat, newMat, v.rawElements);
            return new Matrix(newMat);
        }
    }, {
        key: "rotateX",
        value: function rotateX(angle) {
            var newMat = _glMatrix.mat4.create();
            _glMatrix.mat4.rotateX(newMat, newMat, angle);
            return new Matrix(newMat);
        }
    }, {
        key: "rotateY",
        value: function rotateY(angle) {
            var newMat = _glMatrix.mat4.create();
            _glMatrix.mat4.rotateY(newMat, newMat, angle);
            return new Matrix(newMat);
        }
    }, {
        key: "rotateZ",
        value: function rotateZ(angle) {
            var newMat = _glMatrix.mat4.create();
            _glMatrix.mat4.rotateZ(newMat, newMat, angle);
            return new Matrix(newMat);
        }
    }, {
        key: "rotationQuaternion",
        value: function rotationQuaternion(quat_) {
            var quaternion = _glMatrix.quat.create();
            var newMat = _glMatrix.mat4.create();
            _glMatrix.quat.normalize(quaternion, quat_.rawElements);
            _glMatrix.mat4.fromQuat(newMat, quaternion);
            return new Matrix(newMat);
        }
    }, {
        key: "frustum",
        value: function frustum(left, right, bottom, top, near, far) {
            var newMat = _glMatrix.mat4.create();
            _glMatrix.mat4.frustum(newMat, left, right, bottom, top, near, far);
            return new Matrix(newMat);
        }
    }, {
        key: "ortho",
        value: function ortho(left, right, bottom, top, near, far) {
            var newMat = _glMatrix.mat4.create();
            _glMatrix.mat4.ortho(newMat, left, right, bottom, top, near, far);
            return new Matrix(newMat);
        }
    }, {
        key: "perspective",
        value: function perspective(fovy, aspect, near, far) {
            var newMat = _glMatrix.mat4.create();
            _glMatrix.mat4.perspective(newMat, fovy, aspect, near, far);
            return new Matrix(newMat);
        }
    }, {
        key: "lookAt",
        value: function lookAt(eye, _lookAt, up) {
            var newMat = _glMatrix.mat4.create();
            _glMatrix.mat4.lookAt(newMat, eye.rawElements, _lookAt.rawElements, up.rawElements);
            return new Matrix(newMat);
        }
    }]);

    return Matrix;
}(_MatrixBase3.default);

exports.default = Matrix;

},{"./MatrixBase":273,"./Vector3":278,"./Vector4":279,"gl-matrix":320}],272:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Matrix = require("./Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MatrixArray = function () {
    function MatrixArray(length) {
        _classCallCheck(this, MatrixArray);

        this.rawElements = new Float32Array(length * 16);
    }

    _createClass(MatrixArray, [{
        key: "getAt",
        value: function getAt(index) {
            var firstIndex = index * 16;
            return new _Matrix2.default(this.rawElements.slice(firstIndex, firstIndex + 16));
        }
    }, {
        key: "setAt",
        value: function setAt(index, matrix) {
            for (var i = 0; i < 16; i++) {
                this.rawElements[16 * index + i] = matrix.rawElements[i];
            }
        }
    }], [{
        key: "getIdentityMatrixArray",
        value: function getIdentityMatrixArray(length) {
            var matArray = new MatrixArray(length);
            for (var i = 0; i < length; i++) {
                for (var c = 0; c < 4; c++) {
                    for (var r = 0; r < 4; r++) {
                        matArray.rawElements[i * 16 + 4 * c + r] = c === r ? 1 : 0;
                    }
                }
            }
            return matArray;
        }
    }]);

    return MatrixArray;
}();

exports.default = MatrixArray;

},{"./Matrix":271}],273:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MatrixBase = function () {
    function MatrixBase() {
        _classCallCheck(this, MatrixBase);
    }

    _createClass(MatrixBase, [{
        key: "getAt",
        value: function getAt(row, colmun) {
            throw new Error("Not implemented");
        }
    }, {
        key: "getBySingleIndex",
        value: function getBySingleIndex(index) {
            throw new Error("Not implemented");
        }
    }, {
        key: "RowCount",
        get: function get() {
            return 0;
        }
    }, {
        key: "ColmunCount",
        get: function get() {
            return 0;
        }
    }], [{
        key: "__elementEquals",
        value: function __elementEquals(m1, m2) {
            if (m1.RowCount !== m2.RowCount || m1.ColmunCount !== m2.ColmunCount) {
                return false;
            }
            var count = m1.RowCount * m2.ColmunCount;
            for (var i = 0; i < count; i++) {
                if (m1.getBySingleIndex(i) !== m2.getBySingleIndex(i)) {
                    return false;
                }
            }
            return true;
        }
    }]);

    return MatrixBase;
}();

exports.default = MatrixBase;

},{}],274:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = require("./Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _glMatrix = require("gl-matrix");

var _JThreeLogger = require("../Base/JThreeLogger");

var _JThreeLogger2 = _interopRequireDefault(_JThreeLogger);

var _AABB = require("./AABB");

var _AABB2 = _interopRequireDefault(_AABB);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PointList = function () {
    function PointList(pointList) {
        _classCallCheck(this, PointList);

        if (pointList) {
            this.points = new Array(pointList.points.length);
            for (var i = 0; i < pointList.points.length; i++) {
                this.points[i] = _Vector2.default.copy(pointList.points[i]);
            }
        } else {
            this.points = [];
        }
    }

    _createClass(PointList, [{
        key: "addPoint",
        value: function addPoint(point) {
            this.points.push(point);
        }
    }, {
        key: "transform",
        value: function transform(transformMatrix) {
            for (var i = 0; i < this.points.length; i++) {
                _glMatrix.vec3.transformMat4(this.points[i].rawElements, this.points[i].rawElements, transformMatrix.rawElements);
            }
            return;
        }
    }, {
        key: "clear",
        value: function clear() {
            this.points.length = 0;
            return;
        }
    }, {
        key: "debugShow",
        value: function debugShow() {
            var log = "";
            for (var i = 0; i < this.points.length; i++) {
                log += this.points[i] + "\n";
            }
            _JThreeLogger2.default.sectionLongLog("Pointlist", log);
            return;
        }
    }, {
        key: "getBoundingBox",
        value: function getBoundingBox() {
            var aabb = new _AABB2.default();
            for (var i = 0; i < this.points.length; i++) {
                aabb.expandAABB(this.points[i]);
            }
            return aabb;
        }
    }, {
        key: "toMathematicaPoints",
        value: function toMathematicaPoints() {
            var points = "";
            for (var i = 0; i < this.points.length; i++) {
                if (i !== 0) {
                    points += ",";
                }
                points += this.points[i].toMathematicaString();
            }
            return "Point[{" + points + "}]";
        }
    }], [{
        key: "initializeWithCube",
        value: function initializeWithCube(list) {
            list.clear();
            list.addPoint(new _Vector2.default(-1.0, +1.0, -1.0));
            list.addPoint(new _Vector2.default(-1.0, -1.0, -1.0));
            list.addPoint(new _Vector2.default(+1.0, -1.0, -1.0));
            list.addPoint(new _Vector2.default(+1.0, +1.0, -1.0));
            list.addPoint(new _Vector2.default(-1.0, +1.0, +1.0));
            list.addPoint(new _Vector2.default(-1.0, -1.0, +1.0));
            list.addPoint(new _Vector2.default(+1.0, -1.0, +1.0));
            list.addPoint(new _Vector2.default(+1.0, +1.0, +1.0));
            return list;
        }
    }]);

    return PointList;
}();

exports.default = PointList;

},{"../Base/JThreeLogger":2,"./AABB":268,"./Vector3":278,"gl-matrix":320}],275:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject2 = require("../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

var _Vector = require("./Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _glMatrix = require("gl-matrix");

var _Matrix = require("./Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* The class to maniplate quaternion.
* Basically,you don't need to operate raw element.
* You consider to use some of useful methods without editing raw element forcelly.
* Each element will be represented as (w;x,y,z)
* (1,i,j,k) is base axis for quaternion. (i,j,k is pure imaginary number)
* (w;x,y,z) means w*1+x*i+y*j+z*k
*
*/

var Quaternion = function (_JThreeObject) {
    _inherits(Quaternion, _JThreeObject);

    /**
    * Constructor by specifing each elements.
    */

    function Quaternion(rawElements) {
        _classCallCheck(this, Quaternion);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Quaternion).call(this));

        _this.rawElements = rawElements;
        return _this;
    }

    _createClass(Quaternion, [{
        key: "equalWith",
        value: function equalWith(q) {
            return Quaternion.equals(this, q);
        }
        /**
        * Get normalized quaternion
        */

    }, {
        key: "normalize",
        value: function normalize() {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.normalize(newQuat, this.rawElements));
        }
    }, {
        key: "inverse",
        value: function inverse() {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.invert(newQuat, this.rawElements));
        }
    }, {
        key: "toAngleAxisString",
        value: function toAngleAxisString() {
            var angle = 2 * Math.acos(this.W);
            var imm = Math.sqrt(1 - this.W * this.W);
            if (angle !== 180 && angle !== 0) {
                return "axis(" + angle + "," + this.X / imm + "," + this.Y / imm + "," + this.Z / imm + ")";
            } else if (angle === 0) {
                return "axis(" + angle + ",0,1,0)";
            } else {
                return "axis(180d," + this.X + "," + this.Y + "," + this.Z + ")";
            }
        }
    }, {
        key: "toString",
        value: function toString() {
            return this.toAngleAxisString();
        }
    }, {
        key: "factoringQuaternionZXY",
        value: function factoringQuaternionZXY() {
            var result = { x: 0, y: 0, z: 0 };
            var mat = _Matrix2.default.rotationQuaternion(this);
            var sx = mat.rawElements[6];
            if (Math.abs(sx) < 1 - 1.0E-4) {
                result.x = Math.asin(sx);
                result.z = Math.atan2(-mat.rawElements[4], mat.rawElements[5]);
                result.y = Math.atan2(-mat.rawElements[2], mat.rawElements[10]);
            } else {
                result.y = 0;
                result.x = Math.PI / 2 * sx;
                result.z = Math.atan2(mat.rawElements[1], mat.rawElements[0]);
            }
            return result;
        }
    }, {
        key: "factoringQuaternionXYZ",
        value: function factoringQuaternionXYZ() {
            var result = { x: 0, y: 0, z: 0 };
            var mat = _Matrix2.default.rotationQuaternion(this);
            var sy = -mat.rawElements[2];
            if (Math.abs(sy) < 1 - 1.0E-4) {
                result.x = Math.atan2(mat.rawElements[6], mat.rawElements[10]);
                result.y = Math.asin(sy);
                result.z = Math.atan2(mat.rawElements[1], mat.rawElements[0]);
            } else {
                result.x = 0;
                result.y = Math.PI / 2 * sy;
                result.z = Math.atan2(-mat.rawElements[4], mat.rawElements[5]);
            }
            return result;
        }
    }, {
        key: "eularAngles",
        get: function get() {
            var eular = this.factoringQuaternionZXY();
            return new _Vector2.default(eular.x, eular.y, eular.z);
        },
        set: function set(v) {
            this.rawElements = Quaternion.euler(v.X, v.Y, v.Z).rawElements;
        }
        /**
        * Getter for X.
        */

    }, {
        key: "X",
        get: function get() {
            return this.rawElements[0];
        }
        /**
        * Getter for Y.
        */

    }, {
        key: "Y",
        get: function get() {
            return this.rawElements[1];
        }
        /**
        * Getter for Z.
        */

    }, {
        key: "Z",
        get: function get() {
            return this.rawElements[2];
        }
        /**
        * Getter for W.
        */

    }, {
        key: "W",
        get: function get() {
            return this.rawElements[3];
        }
        /**
        * Getter for imaginary part vector.
        * It returns the vector (x,y,z)
        */

    }, {
        key: "ImaginaryPart",
        get: function get() {
            return new _Vector2.default(this.X, this.Y, this.Z);
        }
        /**
        * Get the conjugate of this quaternion
        */

    }, {
        key: "Conjugate",
        get: function get() {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.conjugate(newQuat, this.rawElements));
        }
        /**
        * Get the length
        */

    }, {
        key: "Length",
        get: function get() {
            return _glMatrix.quat.len(this.rawElements);
        }
    }], [{
        key: "equals",
        value: function equals(q1, q2) {
            for (var i = 0; i < 4; i++) {
                if (q1.rawElements[i] !== q2.rawElements[i]) {
                    return false;
                }
            }
            return true;
        }
        /**
        * Calculate add result of two quaternion
        */

    }, {
        key: "add",
        value: function add(q1, q2) {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.add(newQuat, q1.rawElements, q2.rawElements));
        }
        /**
        * Calculate multiply result of two quaternion
        */

    }, {
        key: "multiply",
        value: function multiply(q1, q2) {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.mul(newQuat, q1.rawElements, q2.rawElements));
        }
        /**
        * Calculate the rotation quaternion represented as pair of angle and axis.
        */

    }, {
        key: "angleAxis",
        value: function angleAxis(angle, axis) {
            var axisVec = _glMatrix.vec3.create();
            axisVec[0] = axis.X;
            axisVec[1] = axis.Y;
            axisVec[2] = axis.Z;
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.setAxisAngle(newQuat, axisVec, +angle));
        }
    }, {
        key: "euler",
        value: function euler(x, y, z) {
            return Quaternion.multiply(Quaternion.angleAxis(z, _Vector2.default.ZUnit), Quaternion.multiply(Quaternion.angleAxis(x, _Vector2.default.XUnit), Quaternion.angleAxis(y, _Vector2.default.YUnit)));
        }
    }, {
        key: "eulerXYZ",
        value: function eulerXYZ(x, y, z) {
            return Quaternion.multiply(Quaternion.angleAxis(z, _Vector2.default.ZUnit), Quaternion.multiply(Quaternion.angleAxis(y, _Vector2.default.YUnit), Quaternion.angleAxis(x, _Vector2.default.XUnit)));
        }
    }, {
        key: "slerp",
        value: function slerp(q1, q2, t) {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.slerp(newQuat, q1.rawElements, q2.rawElements, +t));
        }
        /**
         * Returns the angle in degrees between two rotations q1 and q2.
         * @param q1 the quaternion represents begin angle.
         * @param q2 the quaternion represents end angle.
         * @returns {number} angle represented in radians.
         */

    }, {
        key: "angle",
        value: function angle(q1, q2) {
            var delta = Quaternion.multiply(q2, q1.inverse());
            delta = delta.normalize();
            return 2 * Math.acos(delta.W);
        }
    }, {
        key: "fromToRotation",
        value: function fromToRotation(from, to) {
            var crossed = _Vector2.default.cross(from.normalized, to.normalized);
            var angle = _Vector2.default.dot(from.normalized, to.normalized);
            return Quaternion.angleAxis(angle, crossed);
        }
    }, {
        key: "lookRotation",
        value: function lookRotation(forward, upVec) {
            upVec = upVec || _Vector2.default.YUnit;
            var normalizedForward = forward.normalized;
            var upForwardCross = _Vector2.default.cross(upVec, normalizedForward).normalized;
            var thirdAxis = _Vector2.default.cross(normalizedForward, upForwardCross);
            var m00 = upForwardCross.X;
            var m01 = upForwardCross.Y;
            var m02 = upForwardCross.Z;
            var m10 = thirdAxis.X;
            var m11 = thirdAxis.Y;
            var m12 = thirdAxis.Z;
            var m20 = normalizedForward.X;
            var m21 = normalizedForward.Y;
            var m22 = normalizedForward.Z;
            var num8 = m00 + m11 + m22;
            if (num8 > 0) {
                var num = Math.sqrt(1 + num8);
                return new Quaternion([(m12 - m21) * 0.5 / num, (m20 - m02) * 0.5 / num, (m01 - m10) * 0.5 / num, num / 2]);
            }
            if (m00 >= m11 && m00 >= m22) {
                var num7 = Math.sqrt(1 + m00 - m11 - m22);
                return new Quaternion([(m01 + m10) * 0.5 / num7, (m02 + m20) * 0.5 / num7, (m12 - m21) * 0.5 / num7, num7 / 2]);
            }
            if (m11 > m22) {
                var num6 = Math.sqrt(1 + m11 - m00 - m22);
                return new Quaternion([(m10 + m01) * 0, 5 / num6, 0.5 * num6, (m21 + m12) * 0.5 / num6, (m20 - m02) * 0.5 / num6]);
            }
            var num5 = Math.sqrt(1 + m22 - m00 - m11);
            return new Quaternion([(m20 + m02) * 0.5 / num5, (m21 + m12) * 0.5 / num5, 0.5 * num5, (m01 - m10) * 0.5 / num5]);
        }
    }, {
        key: "Identity",
        get: function get() {
            return new Quaternion(_glMatrix.quat.create());
        }
    }]);

    return Quaternion;
}(_JThreeObject3.default);

exports.default = Quaternion;

},{"../Base/JThreeObject":3,"./Matrix":271,"./Vector3":278,"gl-matrix":320}],276:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = require("./Vector2");

var _Vector2 = _interopRequireDefault(_Vector);

var _JThreeObject = require("../Base/JThreeObject");

var _JThreeObject2 = _interopRequireDefault(_JThreeObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Rectangle = function (_jThreeObject) {
    _inherits(Rectangle, _jThreeObject);

    function Rectangle(left, top, width, height) {
        _classCallCheck(this, Rectangle);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Rectangle).call(this));

        _this._left = left;
        _this._top = top;
        _this._width = width;
        _this._height = height;
        return _this;
    }

    _createClass(Rectangle, [{
        key: "contains",
        value: function contains(xOrPoint, y) {
            var x = undefined;
            if (xOrPoint instanceof _Vector2.default) {
                x = xOrPoint.X;
                y = xOrPoint.Y;
            } else {
                x = xOrPoint;
            }
            return this.Left <= x && this.Right >= x && this.Top <= y && this.Bottom >= y;
        }
    }, {
        key: "toLocal",
        value: function toLocal(xOrPoint, y) {
            var x = undefined;
            if (xOrPoint instanceof _Vector2.default) {
                x = xOrPoint.X;
                y = xOrPoint.Y;
            } else {
                x = xOrPoint;
            }
            x -= this.Left;
            y -= this.Top;
            return xOrPoint instanceof _Vector2.default ? new _Vector2.default(x, y) : [x, y];
        }
    }, {
        key: "toString",
        value: function toString() {
            return "Rectangle(" + this.Left + "," + this.Top + "-" + this.Right + "," + this.Bottom + ")";
        }
    }, {
        key: "Left",
        get: function get() {
            return this._left;
        }
    }, {
        key: "Right",
        get: function get() {
            return this.Left + this.Width;
        }
    }, {
        key: "Top",
        get: function get() {
            return this._top;
        }
    }, {
        key: "Bottom",
        get: function get() {
            return this._top + this._height;
        }
    }, {
        key: "Width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "Height",
        get: function get() {
            return this._height;
        }
    }], [{
        key: "equals",
        value: function equals(r1, r2) {
            return r1.Left === r2.Left && r1.Right === r2.Right && r1.Top === r2.Top && r1.Bottom === r2.Bottom;
        }
    }, {
        key: "edgeSizeEquals",
        value: function edgeSizeEquals(r1, r2) {
            return r1.Width === r2.Width && r1.Height === r2.Height;
        }
    }]);

    return Rectangle;
}(_JThreeObject2.default);

exports.default = Rectangle;

},{"../Base/JThreeObject":3,"./Vector2":277}],277:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _VectorBase2 = require("./VectorBase");

var _VectorBase3 = _interopRequireDefault(_VectorBase2);

var _glMatrix = require("gl-matrix");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Vector2 = function (_VectorBase) {
    _inherits(Vector2, _VectorBase);

    function Vector2(x, y) {
        _classCallCheck(this, Vector2);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Vector2).call(this));

        if (typeof y === "undefined") {
            _this.rawElements = x;
            return _possibleConstructorReturn(_this);
        }
        _this.rawElements = [x, y];
        return _this;
    }

    _createClass(Vector2, [{
        key: "dotWith",
        value: function dotWith(v) {
            return Vector2.dot(this, v);
        }
    }, {
        key: "addWith",
        value: function addWith(v) {
            return Vector2.add(this, v);
        }
    }, {
        key: "subtractWith",
        value: function subtractWith(v) {
            return Vector2.subtract(v, this);
        }
    }, {
        key: "multiplyWith",
        value: function multiplyWith(s) {
            return Vector2.multiply(s, this);
        }
    }, {
        key: "negateThis",
        value: function negateThis() {
            return Vector2.negate(this);
        }
    }, {
        key: "equalWith",
        value: function equalWith(v) {
            return Vector2.equals(this, v);
        }
    }, {
        key: "nearlyEqualWith",
        value: function nearlyEqualWith(v) {
            return Vector2.nearlyEquals(this, v);
        }
    }, {
        key: "normalizeThis",
        value: function normalizeThis() {
            return Vector2.normalize(this);
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(" + this.X + ", " + this.Y + ")";
        }
    }, {
        key: "toDisplayString",
        value: function toDisplayString() {
            return "Vector2" + this.toString();
        }
    }, {
        key: "toMathematicaString",
        value: function toMathematicaString() {
            return "{" + this.X + ", " + this.Y + "}";
        }
    }, {
        key: "normalized",
        get: function get() {
            return this.multiplyWith(1 / this.magnitude);
        }
    }, {
        key: "X",
        get: function get() {
            return this.rawElements[0];
        },
        set: function set(x) {
            this.rawElements[0] = +x;
        }
    }, {
        key: "Y",
        get: function get() {
            return this.rawElements[1];
        },
        set: function set(y) {
            this.rawElements[1] = +y;
        }
    }, {
        key: "ElementCount",
        get: function get() {
            return 2;
        }
    }], [{
        key: "copy",
        value: function copy(vec) {
            return new Vector2(vec.X, vec.Y);
        }
    }, {
        key: "parse",
        value: function parse(str) {
            var parseResult = _VectorBase3.default.__parse(str);
            var elements = parseResult.elements;
            if (elements.length !== 1 && elements.length !== 2) {
                return undefined;
            }
            var result = undefined;
            if (elements.length === 1) {
                result = new Vector2(elements[0], elements[0]);
            } else {
                result = new Vector2(elements[0], elements[1]);
            }
            if (parseResult.needNormalize) {
                result = result.normalizeThis();
            }
            if (parseResult.coefficient) {
                result = result.multiplyWith(parseResult.coefficient);
            }
            if (parseResult.needNegate) {
                result = result.negateThis();
            }
            return result;
        }
    }, {
        key: "dot",
        value: function dot(v1, v2) {
            return _glMatrix.vec2.dot(v1.rawElements, v2.rawElements);
        }
    }, {
        key: "add",
        value: function add(v1, v2) {
            var newVec = _glMatrix.vec2.create();
            return new Vector2(_glMatrix.vec2.add(newVec, v1.rawElements, v2.rawElements));
        }
    }, {
        key: "subtract",
        value: function subtract(v1, v2) {
            var newVec = _glMatrix.vec2.create();
            return new Vector2(_glMatrix.vec2.sub(newVec, v1.rawElements, v2.rawElements));
        }
    }, {
        key: "multiply",
        value: function multiply(s, v) {
            var newVec = _glMatrix.vec2.create();
            return new Vector2(_glMatrix.vec2.scale(newVec, v.rawElements, s));
        }
    }, {
        key: "negate",
        value: function negate(v1) {
            return Vector2.multiply(-1, v1);
        }
    }, {
        key: "equals",
        value: function equals(v1, v2) {
            return _VectorBase3.default.__elementEquals(v1, v2);
        }
    }, {
        key: "nearlyEquals",
        value: function nearlyEquals(v1, v2) {
            return _VectorBase3.default.__nearlyElementEquals(v1, v2);
        }
    }, {
        key: "normalize",
        value: function normalize(v1) {
            var newVec = _glMatrix.vec2.create();
            return new Vector2(_glMatrix.vec2.normalize(newVec, v1.rawElements));
        }
    }, {
        key: "min",
        value: function min(v1, v2) {
            return new Vector2(_VectorBase3.default.__fromGenerationFunction(v1, v2, function (i, v1_, v2_) {
                return Math.min(v1_.rawElements[i], v2_.rawElements[i]);
            }));
        }
    }, {
        key: "max",
        value: function max(v1, v2) {
            return new Vector2(_VectorBase3.default.__fromGenerationFunction(v1, v2, function (i, v1_, v2_) {
                return Math.max(v1_.rawElements[i], v2_.rawElements[i]);
            }));
        }
    }, {
        key: "angle",
        value: function angle(v1, v2) {
            return Math.acos(Vector2.dot(v1.normalized, v2.normalized));
        }
    }, {
        key: "XUnit",
        get: function get() {
            return new Vector2(1, 0);
        }
    }, {
        key: "YUnit",
        get: function get() {
            return new Vector2(0, 1);
        }
    }, {
        key: "One",
        get: function get() {
            return new Vector2(1, 1);
        }
    }, {
        key: "Zero",
        get: function get() {
            return new Vector2(0, 0);
        }
    }]);

    return Vector2;
}(_VectorBase3.default);

exports.default = Vector2;

},{"./VectorBase":281,"gl-matrix":320}],278:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _VectorBase2 = require("./VectorBase");

var _VectorBase3 = _interopRequireDefault(_VectorBase2);

var _glMatrix = require("gl-matrix");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Vector3 = function (_VectorBase) {
    _inherits(Vector3, _VectorBase);

    function Vector3(x, y, z) {
        _classCallCheck(this, Vector3);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Vector3).call(this));

        if (typeof y === "undefined") {
            _this.rawElements = x;
            return _possibleConstructorReturn(_this);
        }
        _this.rawElements = [x, y, z];
        return _this;
    }

    _createClass(Vector3, [{
        key: "toMathematicaString",
        value: function toMathematicaString() {
            return "{" + this.X + "," + this.Y + "," + this.Z + "}";
        }
    }, {
        key: "normalizeThis",
        value: function normalizeThis() {
            return Vector3.normalize(this);
        }
    }, {
        key: "dotWith",
        value: function dotWith(v) {
            return Vector3.dot(this, v);
        }
    }, {
        key: "addWith",
        value: function addWith(v) {
            return Vector3.add(this, v);
        }
    }, {
        key: "subtractWith",
        value: function subtractWith(v) {
            return Vector3.subtract(this, v);
        }
    }, {
        key: "multiplyWith",
        value: function multiplyWith(s) {
            return Vector3.multiply(s, this);
        }
    }, {
        key: "negateThis",
        value: function negateThis() {
            return Vector3.negate(this);
        }
    }, {
        key: "equalWith",
        value: function equalWith(v) {
            return Vector3.equals(this, v);
        }
    }, {
        key: "nearlyEqualWith",
        value: function nearlyEqualWith(v) {
            return Vector3.nearlyEquals(this, v);
        }
    }, {
        key: "crossWith",
        value: function crossWith(v) {
            return Vector3.cross(this, v);
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(" + this.X + ", " + this.Y + ", " + this.Z + ")";
        }
    }, {
        key: "toDisplayString",
        value: function toDisplayString() {
            return "Vector3" + this.toString();
        }
    }, {
        key: "normalized",
        get: function get() {
            return this.multiplyWith(1 / this.magnitude);
        }
    }, {
        key: "X",
        get: function get() {
            return this.rawElements[0];
        },
        set: function set(x) {
            this.rawElements[0] = +x;
        }
    }, {
        key: "Y",
        get: function get() {
            return this.rawElements[1];
        },
        set: function set(y) {
            this.rawElements[1] = +y;
        }
    }, {
        key: "Z",
        get: function get() {
            return this.rawElements[2];
        },
        set: function set(z) {
            this.rawElements[2] = +z;
        }
    }, {
        key: "ElementCount",
        get: function get() {
            return 3;
        }
    }], [{
        key: "copy",
        value: function copy(source) {
            return new Vector3(source.X, source.Y, source.Z);
        }
    }, {
        key: "dot",
        value: function dot(v1, v2) {
            return _glMatrix.vec3.dot(v1.rawElements, v2.rawElements);
        }
    }, {
        key: "add",
        value: function add(v1, v2) {
            var newVec = _glMatrix.vec3.create();
            return new Vector3(_glMatrix.vec3.add(newVec, v1.rawElements, v2.rawElements));
        }
    }, {
        key: "subtract",
        value: function subtract(v1, v2) {
            var newVec = _glMatrix.vec3.create();
            return new Vector3(_glMatrix.vec3.sub(newVec, v1.rawElements, v2.rawElements));
        }
    }, {
        key: "multiply",
        value: function multiply(s, v) {
            var newVec = _glMatrix.vec3.create();
            return new Vector3(_glMatrix.vec3.scale(newVec, v.rawElements, s));
        }
    }, {
        key: "negate",
        value: function negate(v1) {
            return Vector3.multiply(-1, v1);
        }
    }, {
        key: "equals",
        value: function equals(v1, v2) {
            return _VectorBase3.default.__elementEquals(v1, v2);
        }
    }, {
        key: "nearlyEquals",
        value: function nearlyEquals(v1, v2) {
            return _VectorBase3.default.__nearlyElementEquals(v1, v2);
        }
    }, {
        key: "normalize",
        value: function normalize(v1) {
            var newVec = _glMatrix.vec3.create();
            return new Vector3(_glMatrix.vec3.normalize(newVec, v1.rawElements));
        }
    }, {
        key: "cross",
        value: function cross(v1, v2) {
            var newVec = _glMatrix.vec3.create();
            return new Vector3(_glMatrix.vec3.cross(newVec, v1.rawElements, v2.rawElements));
        }
    }, {
        key: "min",
        value: function min(v1, v2) {
            return new Vector3(_VectorBase3.default.__fromGenerationFunction(v1, v2, function (i, _v1, _v2) {
                return Math.min(_v1.rawElements[i], _v2.rawElements[i]);
            }));
        }
    }, {
        key: "max",
        value: function max(v1, v2) {
            return new Vector3(_VectorBase3.default.__fromGenerationFunction(v1, v2, function (i, _v1, _v2) {
                return Math.max(_v1.rawElements[i], _v2.rawElements[i]);
            }));
        }
    }, {
        key: "angle",
        value: function angle(v1, v2) {
            return Math.acos(Vector3.dot(v1.normalized, v2.normalized));
        }
    }, {
        key: "parse",
        value: function parse(str) {
            var parseResult = _VectorBase3.default.__parse(str);
            var elements = parseResult.elements;
            if (!elements || elements.length !== 1 && elements.length !== 3) {
                return undefined;
            }
            var result = undefined;
            if (elements.length === 1) {
                result = new Vector3(elements[0], elements[0], elements[0]);
            } else {
                result = new Vector3(elements[0], elements[1], elements[2]);
            }
            if (parseResult.needNormalize) {
                result = result.normalizeThis();
            }
            if (parseResult.coefficient) {
                result = result.multiplyWith(parseResult.coefficient);
            }
            if (parseResult.needNegate) {
                result = result.negateThis();
            }
            return result;
        }
    }, {
        key: "XUnit",
        get: function get() {
            return new Vector3(1, 0, 0);
        }
    }, {
        key: "YUnit",
        get: function get() {
            return new Vector3(0, 1, 0);
        }
    }, {
        key: "ZUnit",
        get: function get() {
            return new Vector3(0, 0, 1);
        }
    }, {
        key: "Zero",
        get: function get() {
            return new Vector3(0, 0, 0);
        }
    }, {
        key: "One",
        get: function get() {
            return new Vector3(1, 1, 1);
        }
    }]);

    return Vector3;
}(_VectorBase3.default);

exports.default = Vector3;

},{"./VectorBase":281,"gl-matrix":320}],279:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _VectorBase2 = require("./VectorBase");

var _VectorBase3 = _interopRequireDefault(_VectorBase2);

var _glMatrix = require("gl-matrix");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Vector4 = function (_VectorBase) {
    _inherits(Vector4, _VectorBase);

    function Vector4(x, y, z, w) {
        _classCallCheck(this, Vector4);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Vector4).call(this));

        if (typeof y === "undefined") {
            _this.rawElements = x;
            return _possibleConstructorReturn(_this);
        }
        _this.rawElements = [x, y, z, w];
        return _this;
    }

    _createClass(Vector4, [{
        key: "normalizeThis",
        value: function normalizeThis() {
            return Vector4.normalize(this);
        }
    }, {
        key: "dotWith",
        value: function dotWith(v) {
            return Vector4.dot(this, v);
        }
    }, {
        key: "addWith",
        value: function addWith(v) {
            return Vector4.add(this, v);
        }
    }, {
        key: "subtractWith",
        value: function subtractWith(v) {
            return Vector4.subtract(this, v);
        }
    }, {
        key: "multiplyWith",
        value: function multiplyWith(s) {
            return Vector4.multiply(s, this);
        }
    }, {
        key: "negateThis",
        value: function negateThis() {
            return Vector4.negate(this);
        }
    }, {
        key: "equalWith",
        value: function equalWith(v) {
            return Vector4.equals(this, v);
        }
    }, {
        key: "nearlyEqualWith",
        value: function nearlyEqualWith(v) {
            return Vector4.nearlyEquals(this, v);
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(" + this.X + ", " + this.Y + ", " + this.Z + ", " + this.W + ")";
        }
    }, {
        key: "toDisplayString",
        value: function toDisplayString() {
            return "Vector4" + this.toString();
        }
    }, {
        key: "toMathematicaString",
        value: function toMathematicaString() {
            return "{" + this.X + "," + this.Y + "," + this.Z + "," + this.W + "}";
        }
    }, {
        key: "normalized",
        get: function get() {
            return this.multiplyWith(1 / this.magnitude);
        }
    }, {
        key: "X",
        get: function get() {
            return this.rawElements[0];
        },
        set: function set(x) {
            this.rawElements[0] = +x;
        }
    }, {
        key: "Y",
        get: function get() {
            return this.rawElements[1];
        },
        set: function set(y) {
            this.rawElements[1] = +y;
        }
    }, {
        key: "Z",
        get: function get() {
            return this.rawElements[2];
        },
        set: function set(z) {
            this.rawElements[2] = +z;
        }
    }, {
        key: "W",
        get: function get() {
            return this.rawElements[3];
        },
        set: function set(w) {
            this.rawElements[3] = +w;
        }
    }, {
        key: "ElementCount",
        get: function get() {
            return 4;
        }
    }], [{
        key: "copy",
        value: function copy(vec) {
            return new Vector4(vec.X, vec.Y, vec.Z, vec.W);
        }
    }, {
        key: "dot",
        value: function dot(v1, v2) {
            return _glMatrix.vec4.dot(v1.rawElements, v2.rawElements);
        }
    }, {
        key: "add",
        value: function add(v1, v2) {
            var newVec = _glMatrix.vec4.create();
            return new Vector4(_glMatrix.vec4.add(newVec, v1.rawElements, v2.rawElements));
        }
    }, {
        key: "subtract",
        value: function subtract(v1, v2) {
            var newVec = _glMatrix.vec4.create();
            return new Vector4(_glMatrix.vec4.sub(newVec, v1.rawElements, v2.rawElements));
        }
    }, {
        key: "multiply",
        value: function multiply(s, v) {
            var newVec = _glMatrix.vec4.create();
            return new Vector4(_glMatrix.vec4.scale(newVec, v.rawElements, s));
        }
    }, {
        key: "negate",
        value: function negate(v1) {
            return Vector4.multiply(-1, v1);
        }
    }, {
        key: "equals",
        value: function equals(v1, v2) {
            return _VectorBase3.default.__elementEquals(v1, v2);
        }
    }, {
        key: "nearlyEquals",
        value: function nearlyEquals(v1, v2) {
            return _VectorBase3.default.__nearlyElementEquals(v1, v2);
        }
    }, {
        key: "normalize",
        value: function normalize(v1) {
            var newVec = _glMatrix.vec4.create();
            return new Vector4(_glMatrix.vec4.normalize(newVec, v1.rawElements));
        }
    }, {
        key: "min",
        value: function min(v1, v2) {
            return new Vector4(_VectorBase3.default.__fromGenerationFunction(v1, v2, function (i, _v1, _v2) {
                return Math.min(_v1.rawElements[i], _v2.rawElements[i]);
            }));
        }
    }, {
        key: "max",
        value: function max(v1, v2) {
            return new Vector4(_VectorBase3.default.__fromGenerationFunction(v1, v2, function (i, _v1, _v2) {
                return Math.max(_v1.rawElements[i], _v2.rawElements[i]);
            }));
        }
    }, {
        key: "angle",
        value: function angle(v1, v2) {
            return Math.acos(Vector4.dot(v1.normalized, v2.normalized));
        }
    }, {
        key: "parse",
        value: function parse(str) {
            var parseResult = _VectorBase3.default.__parse(str);
            var elements = parseResult.elements;
            if (!elements || elements.length !== 1 && elements.length !== 4) {
                return undefined;
            }
            var result = undefined;
            if (elements.length === 1) {
                result = new Vector4(elements[0], elements[0], elements[0], elements[0]);
            } else {
                result = new Vector4(elements[0], elements[1], elements[2], elements[3]);
            }
            if (parseResult.needNormalize) {
                result = result.normalizeThis();
            }
            if (parseResult.coefficient) {
                result = result.multiplyWith(parseResult.coefficient);
            }
            if (parseResult.needNegate) {
                result = result.negateThis();
            }
            return result;
        }
    }, {
        key: "XUnit",
        get: function get() {
            return new Vector4(1, 0, 0, 0);
        }
    }, {
        key: "YUnit",
        get: function get() {
            return new Vector4(0, 1, 0, 0);
        }
    }, {
        key: "ZUnit",
        get: function get() {
            return new Vector4(0, 0, 1, 0);
        }
    }, {
        key: "WUnit",
        get: function get() {
            return new Vector4(0, 0, 0, 1);
        }
    }, {
        key: "One",
        get: function get() {
            return new Vector4(1, 1, 1, 1);
        }
    }, {
        key: "Zero",
        get: function get() {
            return new Vector4(0, 0, 0, 0);
        }
    }]);

    return Vector4;
}(_VectorBase3.default);

exports.default = Vector4;

},{"./VectorBase":281,"gl-matrix":320}],280:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = require("./Vector4");

var _Vector2 = _interopRequireDefault(_Vector);

var _Vector3 = require("./Vector3");

var _Vector4 = _interopRequireDefault(_Vector3);

var _Vector5 = require("./Vector2");

var _Vector6 = _interopRequireDefault(_Vector5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  The array object for managing vectors having specific dimension.
 */

var VectorArray = function () {
    function VectorArray(length) {
        _classCallCheck(this, VectorArray);

        if (length) {
            this.rawElements = new Array(length);
        } else {
            this.rawElements = [];
        }
    }
    /**
     * Generate vector array filled with zero vectors.
     * @param  {number}      dimension [description]
     * @param  {number}      length   [description]
     * @return {VectorArray}          [description]
     */


    _createClass(VectorArray, [{
        key: "equalWith",
        value: function equalWith(v1) {
            return VectorArray.equals(this, v1);
        }
    }, {
        key: "appendVector",
        value: function appendVector(vector) {
            this._verifyDimension(vector);
            this.rawElements.push(vector.rawElements);
        }
    }, {
        key: "setVector",
        value: function setVector(index, vector) {
            this._verifyDimension(vector);
            for (var elemIndex = 0; elemIndex < vector.ElementCount; elemIndex++) {
                this.rawElements[index * this._dimension + elemIndex] = vector.rawElements[elemIndex];
            }
            return;
        }
    }, {
        key: "setRawArray",
        value: function setRawArray(index, rawArray) {
            for (var elemIndex = 0; elemIndex < this._dimension; elemIndex++) {
                this.rawElements[index * this._dimension + elemIndex] = rawArray[elemIndex] ? rawArray[elemIndex] : 0;
            }
            return;
        }
    }, {
        key: "getVector",
        value: function getVector(index) {
            switch (this._dimension) {
                case 2:
                    return new _Vector6.default(this.rawElements[index * this._dimension + 0], this.rawElements[index * this._dimension + 1]);
                case 3:
                    return new _Vector4.default(this.rawElements[index * this._dimension + 0], this.rawElements[index * this._dimension + 1], this.rawElements[index * this._dimension + 2]);
                case 4:
                    return new _Vector2.default(this.rawElements[index * this._dimension + 0], this.rawElements[index * this._dimension + 1], this.rawElements[index * this._dimension + 2], this.rawElements[index * this._dimension + 3]);
                default:
                    return null;
            }
        }
    }, {
        key: "setVectorArray",
        value: function setVectorArray(vectors) {
            var _this = this;

            var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

            if (vectors.length === 0) {
                return;
            }
            this._verifyDimension(vectors[0]);
            vectors.forEach(function (e, i) {
                if (_this._dimension !== e.ElementCount) {
                    throw new Error("Unmatch unit size of vector element! at:" + i);
                }
                for (var elemIndex = 0; elemIndex < _this._dimension; elemIndex++) {
                    _this.rawElements[offset + _this._dimension * i + elemIndex] = e.rawElements[elemIndex];
                }
            });
            return;
        }
    }, {
        key: "getVectorArray",
        value: function getVectorArray() {
            if (this.rawElements.length === 0) {
                return [];
            }
            var result = new Array(this.rawElements.length / this._dimension);
            for (var i = 0; i < result.length; i++) {
                result[i] = this.getVector(i);
            }
            return result;
        }
    }, {
        key: "_verifyDimension",
        value: function _verifyDimension(vector) {
            if (typeof this._dimension !== "undefined" && this._dimension !== vector.ElementCount) {
                throw new Error("Unmatch unit size of vectors!");
            } else if (typeof this._dimension === "undefined") {
                this._dimension = vector.ElementCount;
            }
        }
    }, {
        key: "dimension",
        get: function get() {
            return this._dimension;
        }
    }], [{
        key: "zeroVectorArray",
        value: function zeroVectorArray(dimension, length) {
            var array = new VectorArray(dimension * length);
            for (var i = 0; i < dimension * length; i++) {
                array.rawElements[i] = 0;
            }
            array._dimension = dimension;
            return array;
        }
    }, {
        key: "fromArray",
        value: function fromArray(dimension, source) {
            var array = new VectorArray(source.length);
            array._dimension = dimension;
            for (var i = 0; i < source.length; i++) {
                array.rawElements[i] = source[i];
            }
            return array;
        }
    }, {
        key: "equals",
        value: function equals(v1, v2) {
            if (v1.rawElements.length !== v2.rawElements.length || v1._dimension !== v2._dimension) {
                return false;
            }
            for (var i = 0; i < v1.rawElements.length; i++) {
                if (v1.rawElements[i] !== v2.rawElements[i]) {
                    return false;
                }
            }
            return true;
        }
    }]);

    return VectorArray;
}();

exports.default = VectorArray;

},{"./Vector2":277,"./Vector3":278,"./Vector4":279}],281:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Exceptions = require("../Exceptions");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VectorBase = function () {
    function VectorBase() {
        _classCallCheck(this, VectorBase);

        this._magnitudeSquaredCache = -1;
        this._magnitudeCache = -1;
    }

    _createClass(VectorBase, [{
        key: "magnitude",
        get: function get() {
            if (this._magnitudeCache < 0) {
                this._magnitudeCache = Math.sqrt(this.sqrMagnitude);
            }
            return this._magnitudeCache;
        }
    }, {
        key: "ElementCount",
        get: function get() {
            return 0;
        }
    }, {
        key: "sqrMagnitude",
        get: function get() {
            if (this._magnitudeSquaredCache < 0) {
                var sum = 0;
                var r = this.rawElements;
                for (var i = 0; i < this.ElementCount; i++) {
                    sum += r[i] * r[i];
                }
                this._magnitudeSquaredCache = sum;
            }
            return this._magnitudeSquaredCache;
        }
    }], [{
        key: "__elementEquals",
        value: function __elementEquals(v1, v2) {
            if (v1.ElementCount !== v2.ElementCount) {
                return false;
            }
            for (var i = 0; i < v1.ElementCount; i++) {
                if (v1.rawElements[i] !== v2.rawElements[i]) {
                    return false;
                }
            }
            return true;
        }
    }, {
        key: "__nearlyElementEquals",
        value: function __nearlyElementEquals(v1, v2) {
            if (v1.ElementCount !== v2.ElementCount) {
                return false;
            }
            var error = 0.01;
            for (var i = 0; i < v1.ElementCount; i++) {
                if (Math.abs(v1.rawElements[i] - v2.rawElements[i]) > error) {
                    return false;
                }
            }
            return true;
        }
    }, {
        key: "__fromGenerationFunction",
        value: function __fromGenerationFunction(v1, v2, gen) {
            var f = new Float32Array(v1.ElementCount);
            for (var i = 0; i < f.length; i++) {
                f[i] = gen(i, v1, v2);
            }
            return f;
        }
    }, {
        key: "__parse",
        value: function __parse(str) {
            var checkRegex = /(-?)([\d,E\+\-\.]+)?(n)?\(([-\d,E\+\.\s]+)\)/g;
            var matches = checkRegex.exec(str);
            if (matches) {
                if (!matches[4]) {
                    throw new _Exceptions.InvalidStringException("The specified string '" + str + "' is not containing braced vector.");
                }
                return {
                    needNormalize: matches[3] === "n",
                    needNegate: matches[1] === "-",
                    coefficient: parseFloat(matches[2]),
                    elements: VectorBase._parseRawVector(matches[4])
                };
            } else {
                // Assume this is simplified format.
                return {
                    needNormalize: false,
                    needNegate: false,
                    elements: VectorBase._parseRawVector(str),
                    coefficient: undefined
                };
            }
        }
    }, {
        key: "_parseRawVector",
        value: function _parseRawVector(str) {
            var splitted = str.split(",");
            var result = new Array(splitted.length);
            for (var i = 0; i < splitted.length; i++) {
                result[i] = parseFloat(splitted[i]);
                if (isNaN(result[i])) {
                    throw new Error("Unexpected vector string " + str);
                }
            }
            return result;
        }
    }]);

    return VectorBase;
}();

exports.default = VectorBase;

},{"../Exceptions":159}],282:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Module = function () {
    function Module() {
        _classCallCheck(this, Module);

        this.enabled = false;
    }

    _createClass(Module, [{
        key: "update",
        value: function update(node) {
            return;
        }
    }, {
        key: "start",
        value: function start(node) {
            return;
        }
    }, {
        key: "terminate",
        value: function terminate(node) {
            return;
        }
    }, {
        key: "initialize",
        value: function initialize() {
            return;
        }
        /* tslint:disable:public-method-name private-method-name */

    }, {
        key: "__init__",
        value: function __init__(registry) {
            return;
        }
    }]);

    return Module;
}();

exports.default = Module;

},{}],283:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require("lodash.isplainobject");

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require("lodash.isfunction");

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require("lodash.isundefined");

var _lodash6 = _interopRequireDefault(_lodash5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* tslint:disable:public-method-name private-method-name */

var ModuleBuiltinMixin = function () {
    function ModuleBuiltinMixin() {
        _classCallCheck(this, ModuleBuiltinMixin);
    }

    _createClass(ModuleBuiltinMixin, [{
        key: "__init__",
        value: function __init__(registry) {
            this.__registry__ = registry;
        }
    }, {
        key: "detach",
        value: function detach() {
            this.__registry__.detach();
        }
    }]);

    return ModuleBuiltinMixin;
}();
/* tslint:enable:public-method-name */


var ModuleInstanceRegistry = function () {
    function ModuleInstanceRegistry(module) {
        _classCallCheck(this, ModuleInstanceRegistry);

        this._enabled = false;
        var AnonymousModule = module;
        if ((0, _lodash2.default)(module)) {
            (function () {
                AnonymousModule = function AnonymousModule() {
                    this.initialize.apply(this, arguments);
                };
                var props = [];
                Object.keys(module).forEach(function (k) {
                    if ((0, _lodash4.default)(module[k]) && k !== "initialize") {
                        AnonymousModule.prototype[k] = module[k];
                    } else {
                        props.push(k);
                    }
                });
                AnonymousModule.prototype.initialize = function () {
                    var _this = this;

                    props.forEach(function (k) {
                        _this[k] = module[k];
                    });
                    if (module.initialize) {
                        module.initialize.apply(this, arguments);
                    }
                };
            })();
        }
        applyMixins(AnonymousModule, [ModuleBuiltinMixin]);
        this._module = AnonymousModule;
    }

    _createClass(ModuleInstanceRegistry, [{
        key: "apply",
        value: function apply(node) {
            this.detach();

            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }

            this._instance = new (Function.prototype.bind.apply(this._module, [null].concat([node], args)))();
            this._instance.__init__(this);
            this._node = node;
            var modules = node.props.getProp("module");
            if ((0, _lodash6.default)(modules)) {
                modules = [];
            }
            modules.push(this._instance);
            node.props.setProp("module", modules);
            // console.log(this._instance);
            return this._instance;
        }
    }, {
        key: "detach",
        value: function detach() {
            if (this._instance) {
                if (this._enabled) {
                    if (this._instance.terminate) {
                        this._instance.terminate(this._node);
                    }
                }
                var modules = this._node.props.getProp("module");
                var index = modules.indexOf(this._instance);
                if (index === -1) {
                    throw new Error("detach target module is not found.");
                }
                modules.splice(index, 1);
                this._node.props.setProp("module", modules);
                this._instance = null;
                this._node = null;
                this._enabled = false;
            }
        }
    }, {
        key: "update",
        value: function update() {
            if (!this._instance) {
                return;
            }
            try {
                if (this._instance.enabled && this._node.Mounted) {
                    if (!this._enabled) {
                        if (this._instance.start) {
                            this._instance.start(this._node);
                        }
                        this._enabled = true;
                    }
                    if (this._instance.update) {
                        this._instance.update(this._node);
                    }
                } else {
                    if (this._enabled) {
                        if (this._instance.terminate) {
                            this._instance.terminate(this._node);
                        }
                        this._enabled = false;
                    }
                }
            } catch (e) {
                console.error(e);
            }
        }
    }]);

    return ModuleInstanceRegistry;
}();

function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(function (baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
            if (name !== "constructor") {
                var descriptor = {
                    value: baseCtor.prototype[name],
                    enumerable: false,
                    configurable: true,
                    writable: true
                };
                Object.defineProperty(derivedCtor.prototype, name, descriptor);
            }
        });
    });
}
exports.default = ModuleInstanceRegistry;

},{"lodash.isfunction":332,"lodash.isplainobject":334,"lodash.isundefined":336}],284:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeObject2 = require("../Base/JThreeObject");

var _JThreeObject3 = _interopRequireDefault(_JThreeObject2);

var _ContextComponents = require("../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ModuleInstanceRegistry = require("./ModuleInstanceRegistry");

var _ModuleInstanceRegistry2 = _interopRequireDefault(_ModuleInstanceRegistry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModuleManager = function (_JThreeObject) {
    _inherits(ModuleManager, _JThreeObject);

    function ModuleManager() {
        _classCallCheck(this, ModuleManager);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ModuleManager).call(this));

        _this.ready = false;
        _this._modules = [];
        var loopManager = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.LoopManager);
        loopManager.addAction(2000, function () {
            return _this.update();
        });
        return _this;
    }

    _createClass(ModuleManager, [{
        key: "getContextComponentIndex",
        value: function getContextComponentIndex() {
            return _ContextComponents2.default.ModuleManager;
        }
    }, {
        key: "update",
        value: function update() {
            if (!this.ready) {
                return;
            }
            this._modules.forEach(function (moduleRegistry) {
                moduleRegistry.update();
            });
        }
    }, {
        key: "addModule",
        value: function addModule(module) {
            var moduleRegistry = new _ModuleInstanceRegistry2.default(module);
            this._modules.push(moduleRegistry);
            return moduleRegistry;
        }
    }, {
        key: "removeModule",
        value: function removeModule(moduleRegistry) {
            var index = this._modules.indexOf(moduleRegistry);
            if (index === -1) {
                throw new Error("target module instance is not found");
            } else {
                this._modules.splice(index, 1);
            }
        }
    }]);

    return ModuleManager;
}(_JThreeObject3.default);

exports.default = ModuleManager;

},{"../Base/JThreeObject":3,"../ContextComponents":8,"../JThreeContext":267,"./ModuleInstanceRegistry":283}],285:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BasicMaterial2 = require("../../../Core/Materials/BasicMaterial");

var _BasicMaterial3 = _interopRequireDefault(_BasicMaterial2);

var _Vector = require("../../../Math/Vector4");

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * the materials for PMX.
 */

var PMXHitAreaMaterial = function (_BasicMaterial) {
    _inherits(PMXHitAreaMaterial, _BasicMaterial);

    function PMXHitAreaMaterial(material) {
        _classCallCheck(this, PMXHitAreaMaterial);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PMXHitAreaMaterial).call(this, require("../../Materials/HitAreaTest.xmml"), "pmx.hitarea"));

        _this.__associatedMaterial = material;
        return _this;
    }
    /**
     * Count of verticies
     */


    _createClass(PMXHitAreaMaterial, [{
        key: "apply",
        value: function apply(matArg) {
            var r = 0xFF00 & matArg.renderStage.objectIndex;
            var g = 0x00FF & matArg.renderStage.objectIndex;
            var b = 0xFF & this.__associatedMaterial.materialIndex;
            var skeleton = this.__associatedMaterial.ParentModel.skeleton;
            this.shaderVariables = {
                boneCount: skeleton.BoneCount,
                boneMatriciesTexture: skeleton.MatrixTexture,
                indexColor: new _Vector2.default(r / 0xFF, g / 0xFF, b / 0xFF, 1)
            };
            _get(Object.getPrototypeOf(PMXHitAreaMaterial.prototype), "apply", this).call(this, matArg);
        }
    }, {
        key: "getDrawGeometryLength",
        value: function getDrawGeometryLength(geo) {
            return this.__associatedMaterial.Diffuse.A > 0 ? this.VerticiesCount : 0;
        }
    }, {
        key: "getDrawGeometryOffset",
        value: function getDrawGeometryOffset(geo) {
            return this.VerticiesOffset * 4;
        }
    }, {
        key: "VerticiesCount",
        get: function get() {
            return this.__associatedMaterial.VerticiesCount;
        }
        /**
         * Offset of verticies in index buffer
         */

    }, {
        key: "VerticiesOffset",
        get: function get() {
            return this.__associatedMaterial.VerticiesOffset;
        }
    }]);

    return PMXHitAreaMaterial;
}(_BasicMaterial3.default);

exports.default = PMXHitAreaMaterial;

},{"../../../Core/Materials/BasicMaterial":36,"../../../Math/Vector4":279,"../../Materials/HitAreaTest.xmml":300}],286:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BasicMaterial = require("../../../Core/Materials/BasicMaterial");

var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);

var _Material2 = require("../../../Core/Materials/Material");

var _Material3 = _interopRequireDefault(_Material2);

var _Vector = require("../../../Math/Vector4");

var _Vector2 = _interopRequireDefault(_Vector);

var _Color = require("../../../Math/Color4");

var _Color2 = _interopRequireDefault(_Color);

var _Color3 = require("../../../Math/Color3");

var _Color4 = _interopRequireDefault(_Color3);

var _PMXMaterialMorphParamContainer = require("./../PMXMaterialMorphParamContainer");

var _PMXMaterialMorphParamContainer2 = _interopRequireDefault(_PMXMaterialMorphParamContainer);

var _ContextComponents = require("../../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * the materials for PMX.
 */

var PMXMaterial = function (_Material) {
    _inherits(PMXMaterial, _Material);

    function PMXMaterial(pmx, index, offset) {
        _classCallCheck(this, PMXMaterial);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PMXMaterial).call(this));

        _this.edgeColor = null;
        _this._sphere = null;
        _this._texture = null;
        _this._toon = null;
        _this.addMorphParam = new _PMXMaterialMorphParamContainer2.default(1);
        _this.mulMorphParam = new _PMXMaterialMorphParamContainer2.default(0);
        _this._parentModel = pmx;
        _this._pmxData = pmx.ModelData;
        _this.materialIndex = index;
        var materialData = _this._pmxData.Materials[index];
        _this._verticiesCount = materialData.vertexCount;
        _this._verticiesOffset = offset;
        _this.name = materialData.materialName;
        _this.cullEnabled = !((materialData.drawFlag & 0x01) > 0); // each side draw flag
        _this._ambient = new _Color4.default(materialData.ambient[0], materialData.ambient[1], materialData.ambient[2]);
        _this._diffuse = new _Color2.default(materialData.diffuse[0], materialData.diffuse[1], materialData.diffuse[2], materialData.diffuse[3]);
        if ((materialData.drawFlag & 0x10) > 0) {
            _this.edgeColor = new _Color2.default(materialData.edgeColor[0], materialData.edgeColor[1], materialData.edgeColor[2], materialData.edgeColor[3]);
        }
        _this._specular = new _Vector2.default(materialData.specular);
        _this._edgeSize = materialData.edgeSize;
        _this._sphereMode = materialData.sphereMode;
        _this.__innerMaterial = new _BasicMaterial2.default(require("../../Materials/Forward.xmml"), "pmx.forward");
        var tm = _this._parentModel.pmxTextureManager;
        tm.loadTexture(materialData.sphereTextureIndex).then(function (texture) {
            _this._sphere = texture;
        });
        tm.loadTexture(materialData.textureIndex).then(function (texture) {
            _this._texture = texture;
        });
        if (materialData.sharedToonFlag === 0) {
            tm.loadTexture(materialData.targetToonIndex).then(function (texture) {
                _this._toon = texture;
            });
        } else {
            _this._toon = _this._loadSharedTexture(materialData.targetToonIndex);
        }
        _this.__innerMaterial.on("configure", function (v) {
            if (v.passIndex === 0) {
                v.configure.cullOrientation = _this.cullEnabled ? "BACK" : "NONE";
            }
        });
        _this.__innerMaterial.on("ready", function () {
            _this.__setLoaded();
        });
        return _this;
    }
    /**
     * Count of verticies
     */


    _createClass(PMXMaterial, [{
        key: "getPassCount",
        value: function getPassCount(techniqueIndex) {
            return this.edgeColor == null ? 1 : 2;
        }
    }, {
        key: "apply",
        value: function apply(matArg) {
            var skeleton = this._parentModel.skeleton;
            if (matArg.passIndex === 1) {
                this.__innerMaterial.shaderVariables = {
                    boneCount: skeleton.BoneCount,
                    boneMatriciesTexture: skeleton.MatrixTexture,
                    edgeSize: _PMXMaterialMorphParamContainer2.default.calcMorphedSingleValue(this._edgeSize, this.addMorphParam, this.mulMorphParam, function (t) {
                        return t.edgeSize;
                    }),
                    edgeColor: _PMXMaterialMorphParamContainer2.default.calcMorphedVectorValue(this.edgeColor.toVector(), this.addMorphParam, this.mulMorphParam, function (t) {
                        return t.edgeColor;
                    }, 4)
                };
            } else {
                this.__innerMaterial.shaderVariables = {
                    boneCount: skeleton.BoneCount,
                    boneMatriciesTexture: skeleton.MatrixTexture,
                    texture: this._texture,
                    toon: this._toon,
                    sphere: this._sphere,
                    diffuse: this._diffuse.toVector(),
                    specular: this._specular,
                    ambient: this._ambient.toVector(),
                    textureUsed: !this._texture ? 0 : 1,
                    sphereMode: !this._sphere ? 0 : this._sphereMode,
                    toonFlag: !this._toon ? 0 : 1,
                    addTexCoeff: new _Vector2.default(this.addMorphParam.textureCoeff),
                    mulTexCoeff: new _Vector2.default(this.mulMorphParam.textureCoeff),
                    addSphereCoeff: new _Vector2.default(this.addMorphParam.sphereCoeff),
                    mulSphereCoeff: new _Vector2.default(this.mulMorphParam.sphereCoeff),
                    addToonCoeff: new _Vector2.default(this.addMorphParam.toonCoeff),
                    mulToonCoeff: new _Vector2.default(this.mulMorphParam.toonCoeff),
                    ambientCoefficient: matArg.scene.sceneAmbient.toVector()
                };
            }
            this.__innerMaterial.apply(matArg);
        }
    }, {
        key: "getDrawGeometryLength",
        value: function getDrawGeometryLength(geo) {
            return this._diffuse.A > 0 ? this.VerticiesCount : 0;
        }
    }, {
        key: "getDrawGeometryOffset",
        value: function getDrawGeometryOffset(geo) {
            return this.VerticiesOffset * 4;
        }
    }, {
        key: "_loadSharedTexture",
        value: function _loadSharedTexture(index) {
            if (index < 0) {
                return null;
            }
            var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
            var resName = "jthree.pmx.sharedtoon." + index;
            if (rm.getTexture(resName)) {
                return rm.getTexture(resName);
            } else {
                var tex = rm.createTextureWithSource(resName, this._parentModel.pmxTextureManager.generateSharedToonImg(index));
                return tex;
            }
        }
    }, {
        key: "VerticiesCount",
        get: function get() {
            return this._verticiesCount;
        }
        /**
         * Offset of verticies in index buffer
         */

    }, {
        key: "VerticiesOffset",
        get: function get() {
            return this._verticiesOffset;
        }
    }, {
        key: "ParentModel",
        get: function get() {
            return this._parentModel;
        }
    }, {
        key: "Diffuse",
        get: function get() {
            return this._diffuse;
        }
    }, {
        key: "Texture",
        get: function get() {
            return this._texture;
        }
    }, {
        key: "Sphere",
        get: function get() {
            return this._sphere;
        }
    }, {
        key: "SphereMode",
        get: function get() {
            return this._sphereMode;
        }
    }, {
        key: "Specular",
        get: function get() {
            return this._specular;
        }
    }, {
        key: "SelfShadow",
        get: function get() {
            return (this._pmxData.Materials[this.materialIndex].drawFlag & 0x04) > 0;
        }
    }, {
        key: "Priorty",
        get: function get() {
            return 100 + this.materialIndex;
        }
    }]);

    return PMXMaterial;
}(_Material3.default);

exports.default = PMXMaterial;

},{"../../../ContextComponents":8,"../../../Core/Materials/BasicMaterial":36,"../../../Core/Materials/Material":57,"../../../JThreeContext":267,"../../../Math/Color3":269,"../../../Math/Color4":270,"../../../Math/Vector4":279,"../../Materials/Forward.xmml":299,"./../PMXMaterialMorphParamContainer":292}],287:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BasicMaterial2 = require("../../../Core/Materials/BasicMaterial");

var _BasicMaterial3 = _interopRequireDefault(_BasicMaterial2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PMXPrimaryBufferMaterial = function (_BasicMaterial) {
    _inherits(PMXPrimaryBufferMaterial, _BasicMaterial);

    function PMXPrimaryBufferMaterial(material) {
        _classCallCheck(this, PMXPrimaryBufferMaterial);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PMXPrimaryBufferMaterial).call(this, require("../../Materials/PrimaryBuffer.xmml"), "pmx.gbuffer.0"));

        _this._associatedMaterial = material;
        return _this;
    }

    _createClass(PMXPrimaryBufferMaterial, [{
        key: "apply",
        value: function apply(matArg) {
            if (this._associatedMaterial.Diffuse.A < 1.0E-3) {
                return;
            }
            var skeleton = this._associatedMaterial.ParentModel.skeleton;
            this.shaderVariables = {
                boneMatriciesTexture: skeleton.MatrixTexture,
                brightness: this._associatedMaterial.Specular.W,
                boneCount: skeleton.BoneCount
            };
            _get(Object.getPrototypeOf(PMXPrimaryBufferMaterial.prototype), "apply", this).call(this, matArg);
        }
        /**
         * Count of verticies
         */

    }, {
        key: "getDrawGeometryLength",
        value: function getDrawGeometryLength(geo) {
            return this._associatedMaterial.Diffuse.A > 0 ? this.VerticiesCount : 0;
        }
    }, {
        key: "getDrawGeometryOffset",
        value: function getDrawGeometryOffset(geo) {
            return this.VerticiesOffset * 4;
        }
    }, {
        key: "VerticiesCount",
        get: function get() {
            return this._associatedMaterial.VerticiesCount;
        }
        /**
         * Offset of verticies in index buffer
         */

    }, {
        key: "VerticiesOffset",
        get: function get() {
            return this._associatedMaterial.VerticiesOffset;
        }
    }]);

    return PMXPrimaryBufferMaterial;
}(_BasicMaterial3.default);

exports.default = PMXPrimaryBufferMaterial;

},{"../../../Core/Materials/BasicMaterial":36,"../../Materials/PrimaryBuffer.xmml":301}],288:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SceneObject2 = require("../../Core/SceneObjects/SceneObject");

var _SceneObject3 = _interopRequireDefault(_SceneObject2);

var _PMXBoneTransformer = require("./PMXBoneTransformer");

var _PMXBoneTransformer2 = _interopRequireDefault(_PMXBoneTransformer);

var _Vector = require("../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PMXBone = function (_SceneObject) {
    _inherits(PMXBone, _SceneObject);

    function PMXBone(model, skeleton, boneIndex) {
        _classCallCheck(this, PMXBone);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PMXBone).call(this));

        _this.__transformer = new _PMXBoneTransformer2.default(_this, model, boneIndex);
        _this._targetModel = model;
        _this._targetSkeleton = skeleton;
        _this.boneIndex = boneIndex;
        _this.name = _this.TargetBoneData.boneName;
        return _this;
    }

    _createClass(PMXBone, [{
        key: "boneDictionaryConstructed",

        /**
         * This method is intended to use by PMXSkeleton.
         * No need to call this method by user.
         */
        value: function boneDictionaryConstructed() {
            if (this.IsRootBone) {
                this._targetModel.addChild(this);
            } else {
                this._targetSkeleton.getBoneByIndex(this.TargetBoneData.parentBoneIndex).addChild(this);
            }
            this.Transformer.LocalOrigin = new _Vector2.default(this.TargetBoneData.position);
            var transformer = this.__transformer;
            if (transformer.IsIKBone) {
                for (var i = 0; i < this.TargetBoneData.ikLinkCount; i++) {
                    this._targetSkeleton.getBoneByIndex(this.TargetBoneData.ikLinks[i].ikLinkBoneIndex).__transformer.isIKLink = true;
                }
            }
        }
    }, {
        key: "updateBoneTransform",
        value: function updateBoneTransform() {
            var t = this.__transformer;
            t.updateTransformForPMX();
        }
    }, {
        key: "structureToString",
        value: function structureToString(layer) {
            var result = "";
            for (var i = 0; i < layer; i++) {
                result += "  ";
            }
            result += this.toString() + "\n";
            var arr = this.Children;
            for (var index = 0; index < arr.length; index++) {
                if (typeof arr[index] !== "undefined") {
                    result += arr[index].structureToString(layer + 1);
                }
            }
            return result;
        }
    }, {
        key: "toString",
        value: function toString() {
            return this.TargetBoneData.boneName + "(" + this.TargetBoneData.boneNameEn + ")";
        }
    }, {
        key: "applyMatrixToBuffer",
        value: function applyMatrixToBuffer(buffer) {
            // if (!(<PMXBoneTransformer>this.Transformer).transformUpdated) return;
            for (var i = 0; i < 16; i++) {
                buffer[16 * this.boneIndex + i] = this.Transformer.localToGlobal.rawElements[i];
            }
            // (<PMXBoneTransformer>this.Transformer).transformUpdated = false;
        }
    }, {
        key: "TargetBoneData",
        get: function get() {
            return this._targetModel.ModelData.Bones[this.boneIndex];
        }
    }, {
        key: "IsRootBone",
        get: function get() {
            return this.TargetBoneData.parentBoneIndex === -1;
        }
    }, {
        key: "OrderCriteria",
        get: function get() {
            var latex = this._targetModel.ModelData.Bones.length;
            return this.boneIndex + this.TargetBoneData.transformLayer * latex + (this.AfterPhysics ? latex * latex : 0);
        }
    }, {
        key: "AfterPhysics",
        get: function get() {
            return (this.TargetBoneData.boneFlag & 0x1000) > 0;
        }
    }]);

    return PMXBone;
}(_SceneObject3.default);

exports.default = PMXBone;

},{"../../Core/SceneObjects/SceneObject":151,"../../Math/Vector3":278,"./PMXBoneTransformer":289}],289:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Transformer2 = require("../../Core/Transform/Transformer");

var _Transformer3 = _interopRequireDefault(_Transformer2);

var _glMatrix = require("gl-matrix");

var _Quaternion = require("../../Math/Quaternion");

var _Quaternion2 = _interopRequireDefault(_Quaternion);

var _Vector = require("../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _Matrix = require("../../Math/Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Bone transformer for pmx
 */

var PMXBoneTransformer = function (_Transformer) {
    _inherits(PMXBoneTransformer, _Transformer);

    function PMXBoneTransformer(sceneObj, pmx, index) {
        _classCallCheck(this, PMXBoneTransformer);

        /**
         * Quaternion produced from manual operation,bone animation.(except bone morphs)
         * @type {Quaternion}
         */

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PMXBoneTransformer).call(this, sceneObj));

        _this.userRotation = _Quaternion2.default.Identity;
        _this.transformUpdated = false;
        /**
           * Translation vector produced from manual operation,bone animation.
           * @type {Vector3}
           */
        _this.userTranslation = _Vector2.default.Zero;
        /**
         * Whether this bone transformer is IKLink or not.
         * This variable will be assigned by PMXSkeleton after loading all bones.
         * @type {boolean}
         */
        _this.isIKLink = false;
        /**
         * Quaternion produced from bone morphs.
         * @type {Quaternion}
         */
        _this._morphRotation = _Quaternion2.default.Identity;
        /**
         * Translation vector produced from bone morphs.
         * @type {Vector3}
         */
        _this._morphTranslation = _Vector2.default.Zero;
        /**
         * Quaternion that will be used for calculating rotation providing for child bones.
         * @type {Quaternion}
         */
        _this._providingBoneRotation = _Quaternion2.default.Identity;
        /**
         * Translation vector that will be used for calculating translation providing for child bones.
         * @type {Vector3}
         */
        _this._providingBoneTranslation = _Vector2.default.Zero;
        /**
         * Quaternion produced from rotation of IK link.
         * @type {Quaternion}
         */
        _this._ikLinkRotation = _Quaternion2.default.Identity;
        _this._pmx = pmx;
        _this._boneIndex = index;
        return _this;
    }
    /**
     * Reference to static model data.
     */


    _createClass(PMXBoneTransformer, [{
        key: "updateTransformForPMX",
        value: function updateTransformForPMX() {
            if (this._pmx == null) {
                return;
            }
            this._updateLocalTranslation();
            if (this.IsIKBone && this._pmx.skeleton) {
                this._applyCCDIK();
            } else {
                this._updateLocalRotation();
                _get(Object.getPrototypeOf(PMXBoneTransformer.prototype), "updateTransform", this).call(this); // reconstruct transoform matrix
            }
        }
        /**
         * Calculate actual rotation quaternion.
         * This operation not affects any other bones.(Even if the bone was child bone)
         * @return {[type]} [description]
         */

    }, {
        key: "_updateLocalRotation",
        value: function _updateLocalRotation() {
            _glMatrix.quat.identity(this.Rotation.rawElements);
            if (this.IsRotationProvidingBone) {
                if (this.IsLocalProvidingBone) {
                    // TODO Do something when this bone is local providing bone
                    console.error("Local providing is not implemented yet!");
                }
                if (this.ProvidingBoneTransformer.isIKLink) {
                    // Interpolate ikLink rotation with providing rate
                    _glMatrix.quat.slerp(this.Rotation.rawElements, this.Rotation.rawElements, this.ProvidingBoneTransformer._ikLinkRotation.rawElements, this.BoneData.providingRate);
                }
            }
            // Multiply local rotations of this bone
            _glMatrix.quat.mul(this.Rotation.rawElements, this.Rotation.rawElements, this.userRotation.rawElements);
            _glMatrix.quat.mul(this.Rotation.rawElements, this.Rotation.rawElements, this._morphRotation.rawElements);
            if (this.IsRotationProvidingBone) {
                _glMatrix.quat.copy(this._providingBoneRotation.rawElements, this.Rotation.rawElements);
            }
            // Calculate IkLink rotation of this bone
            _glMatrix.quat.mul(this.Rotation.rawElements, this.Rotation.rawElements, this._ikLinkRotation.rawElements);
        }
        /**
         * Calculate actual translation vector.
         * This operation not affects any other bones.(Even if the bone was child bone)
         * @return {[type]} [description]
         */

    }, {
        key: "_updateLocalTranslation",
        value: function _updateLocalTranslation() {
            this.Position.rawElements[0] = 0;
            this.Position.rawElements[1] = 0;
            this.Position.rawElements[2] = 0;
            if (this.IsTranslationProvidingBone) {
                if (this.IsLocalProvidingBone) {
                    // Do something when this bone is local providing bone
                    console.error("Local providing is not implemented yet!");
                }
                _glMatrix.vec3.lerp(this.Position.rawElements, this.Position.rawElements, this.ProvidingBone.Transformer.Position.rawElements, this.BoneData.providingRate);
            }
            _glMatrix.vec3.add(this.Position.rawElements, this.Position.rawElements, this.userTranslation.rawElements);
            _glMatrix.vec3.add(this.Position.rawElements, this.Position.rawElements, this._morphTranslation.rawElements);
            if (this.IsTranslationProvidingBone) {
                _glMatrix.vec3.copy(this._providingBoneTranslation.rawElements, this.Position.rawElements);
            }
        }
    }, {
        key: "_applyCCDIK",
        value: function _applyCCDIK() {
            for (var i = 0; i < this.BoneData.ikLinkCount; i++) {
                var link = this._getIkLinkTransformerByIndex(i);
                link._ikLinkRotation = _Quaternion2.default.Identity;
                link.updateTransformForPMX();
            }
            for (var _i = 0; _i < this.BoneData.ikLoopCount; _i++) {
                this._cCDIKOperation(_i);
            }
        }
    }, {
        key: "_cCDIKOperation",
        value: function _cCDIKOperation(it) {
            var effectorTransformer = this._pmx.skeleton.getBoneByIndex(this.BoneData.ikTargetBoneIndex).Transformer;
            var TargetGlobalPos = _Matrix2.default.transformPoint(this.localToGlobal, this.LocalOrigin);
            // vec3.transformMat4(this._pmxCalcCacheVec, this.LocalOrigin.rawElements, this.localToGlobal.rawElements);
            for (var i = 0; i < this.BoneData.ikLinkCount; i++) {
                var ikLinkData = this.BoneData.ikLinks[i];
                var ikLinkTransform = this._getIkLinkTransformerByIndex(i);
                var link2Effector = this._getLink2Effector(ikLinkTransform, effectorTransformer);
                var link2Target = this._getLink2Target(ikLinkTransform, TargetGlobalPos);
                this._ikLinkCalc(ikLinkTransform, link2Effector, link2Target, this.BoneData.ikLimitedRotation, ikLinkData, it);
            }
        }
    }, {
        key: "_getLink2Effector",
        value: function _getLink2Effector(link, effector) {
            var ToLinkLocal = _Matrix2.default.inverse(link.localToGlobal);
            var ep = effector.LocalOrigin;
            var local2effectorLocal = _Matrix2.default.multiply(ToLinkLocal, effector.localToGlobal);
            var effectorPos = _Matrix2.default.transformPoint(local2effectorLocal, ep);
            return effectorPos.subtractWith(link.LocalOrigin).normalizeThis();
        }
    }, {
        key: "_getLink2Target",
        value: function _getLink2Target(link, tp) {
            var ToLinkLocal = _Matrix2.default.inverse(link.localToGlobal);
            var effectorPos = _Matrix2.default.transformPoint(ToLinkLocal, tp);
            return effectorPos.subtractWith(link.LocalOrigin).normalizeThis();
        }
    }, {
        key: "_ikLinkCalc",
        value: function _ikLinkCalc(link, effector, target, rotationLimit, ikLink, it) {
            // Calculate rotation angle
            var dot = _Vector2.default.dot(effector, target);
            if (dot > 1.0) {
                dot = 1.0; // adjust error (if dot was over 1.0, acos(dot) will be NaN. Then, it cause some of bug)
            }
            var rotationAngle = this._clampFloat(Math.acos(dot), rotationLimit);
            if (isNaN(rotationAngle)) {
                return;
            }
            if (rotationAngle <= 1.0e-3) {
                return;
            }
            // Calculate rotation axis of rotation
            var rotationAxis = _Vector2.default.cross(effector, target).normalizeThis();
            // Generate the rotation matrix rotating along the axis
            var rotation = _Quaternion2.default.angleAxis(rotationAngle, rotationAxis);
            // link.updateTransform();
            // Rotation = (_providingBoneRotation) * userRotation * _morphRotation * ikLinkRotation
            // RestrictedRotation = Rotation * ikLinkAdjust
            // ikLinkAdust = (Rotation) ^ -1 * RestrictedRotation
            var restrictedRotation = this._restrictRotation(ikLink, rotation);
            link._ikLinkRotation = _Quaternion2.default.multiply(link._ikLinkRotation, restrictedRotation);
            link.updateTransformForPMX();
            // link.updateTransformMatricies();
        }
    }, {
        key: "_getIkLinkTransformerByIndex",
        value: function _getIkLinkTransformerByIndex(index) {
            return this._pmx.skeleton.getBoneByIndex(this.BoneData.ikLinks[index].ikLinkBoneIndex).Transformer;
        }
    }, {
        key: "_restrictRotation",
        value: function _restrictRotation(link, rot) {
            if (!link.isLimitedRotation) {
                return rot; // If this link bone is not enabled with rotation limit,just return.
            }
            var decomposed = rot.factoringQuaternionXYZ();
            var xRotation = Math.max(link.limitedRotation[0], Math.min(link.limitedRotation[3], -decomposed.x));
            var yRotation = Math.max(link.limitedRotation[1], Math.min(link.limitedRotation[4], -decomposed.y));
            var zRotation = Math.max(link.limitedRotation[2], Math.min(link.limitedRotation[5], decomposed.z));
            var nRot = this._normalizeEuler(xRotation, yRotation, zRotation);
            return _Quaternion2.default.eulerXYZ(-nRot.x, -nRot.y, nRot.z);
        }
    }, {
        key: "_normalizeEuler",
        value: function _normalizeEuler(x, y, z) {
            if (!this._between(x, -Math.PI, Math.PI)) {
                if (x > 0) {
                    x -= Math.PI * 2;
                } else {
                    x += Math.PI * 2;
                }
            }
            if (!this._between(y, -Math.PI * 0.5, Math.PI * 0.5)) {
                if (y > 0) {
                    y -= Math.PI * 2;
                } else {
                    y += Math.PI * 2;
                }
            }
            if (!this._between(z, -Math.PI, Math.PI)) {
                if (z > 0) {
                    z -= Math.PI * 2;
                } else {
                    z += Math.PI * 2;
                }
            }
            return {
                x: x,
                y: y,
                z: z
            };
        }
    }, {
        key: "_between",
        value: function _between(val, min, max) {
            return val <= max && val >= min;
        }
    }, {
        key: "_clampFloat",
        value: function _clampFloat(f, limit) {
            return Math.max(Math.min(f, limit), -limit);
        }
    }, {
        key: "PMXModelData",
        get: function get() {
            return this._pmx.ModelData;
        }
    }, {
        key: "BoneData",
        get: function get() {
            return this.PMXModelData.Bones[this._boneIndex];
        }
    }, {
        key: "ProvidingBone",
        get: function get() {
            return this._pmx.skeleton.getBoneByIndex(this.BoneData.providingBoneIndex);
        }
    }, {
        key: "ProvidingBoneTransformer",
        get: function get() {
            return this.ProvidingBone.Transformer;
        }
    }, {
        key: "IsLocalProvidingBone",
        get: function get() {
            return (this.BoneData.boneFlag & 0x0080) > 0;
        }
    }, {
        key: "IsRotationProvidingBone",
        get: function get() {
            return (this.BoneData.boneFlag & 0x0100) > 0;
        }
    }, {
        key: "IsTranslationProvidingBone",
        get: function get() {
            return (this.BoneData.boneFlag & 0x0200) > 0;
        }
    }, {
        key: "IsIKBone",
        get: function get() {
            return (this.BoneData.boneFlag & 0x0020) > 0;
        }
    }]);

    return PMXBoneTransformer;
}(_Transformer3.default);

exports.default = PMXBoneTransformer;

},{"../../Core/Transform/Transformer":153,"../../Math/Matrix":271,"../../Math/Quaternion":275,"../../Math/Vector3":278,"gl-matrix":320}],290:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Provide initializing methods for PMX.
 * @type {[type]}
 */

var PMXCoreInitializer = function () {
    function PMXCoreInitializer() {
        _classCallCheck(this, PMXCoreInitializer);
    }

    _createClass(PMXCoreInitializer, null, [{
        key: "init",
        value: function init() {
            if (PMXCoreInitializer._initialized) {
                return;
            }
            PMXCoreInitializer._registerShaderChunk();
            PMXCoreInitializer._initialized = true;
        }
    }, {
        key: "_registerShaderChunk",
        value: function _registerShaderChunk() {
            var mm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.MaterialManager);
            mm.addShaderChunk("jthree.pmx.vertex", require("../ShaderChunk/_PMXVertexShader.glsl"));
        }
    }]);

    return PMXCoreInitializer;
}();

PMXCoreInitializer._initialized = false;
exports.default = PMXCoreInitializer;

},{"../../ContextComponents":8,"../../JThreeContext":267,"../ShaderChunk/_PMXVertexShader.glsl":303}],291:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BasicGeometry2 = require("../../Core/Geometries/Base/BasicGeometry");

var _BasicGeometry3 = _interopRequireDefault(_BasicGeometry2);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PMXGeometry = function (_BasicGeometry) {
    _inherits(PMXGeometry, _BasicGeometry);

    function PMXGeometry(pmx) {
        _classCallCheck(this, PMXGeometry);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PMXGeometry).call(this));

        var name = pmx.Header.modelName + "(" + pmx.Header.modelNameEn + ")";
        var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        _this.indexBuffer = rm.createBuffer(name + "-index", WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 1, WebGLRenderingContext.UNSIGNED_INT);
        _this.positionBuffer = rm.createBuffer(name + "-pos", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.normalBuffer = rm.createBuffer(name + "-nor", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.uvBuffer = rm.createBuffer(name + "-uv", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 2, WebGLRenderingContext.FLOAT);
        _this.edgeSizeBuffer = rm.createBuffer(name + "-edgeSize", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 1, WebGLRenderingContext.FLOAT);
        _this.boneIndexBuffer = rm.createBuffer(name + "-boneIndex", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 4, WebGLRenderingContext.FLOAT);
        _this.boneWeightBuffer = rm.createBuffer(name + "-boneWeight", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 4, WebGLRenderingContext.FLOAT);
        _this.__updateBuffers(pmx);
        return _this;
    }
    /**
     * apply pmx geometries to buffer.
     */


    _createClass(PMXGeometry, [{
        key: "__updateBuffers",
        value: function __updateBuffers(pmx) {
            var surfaceBuffer = new Uint32Array(pmx.Surfaces);
            var verticies = pmx.Verticies;
            this.positionBuferSource = new Float32Array(verticies.positions);
            this.uvBufferSource = new Float32Array(verticies.uvs);
            this.indexBuffer.update(surfaceBuffer, surfaceBuffer.length);
            this.normalBuffer.update(verticies.normals, verticies.normals.length);
            this.uvBuffer.update(this.uvBufferSource, this.uvBufferSource.length);
            this.positionBuffer.update(this.positionBuferSource, this.positionBuferSource.length);
            this.edgeSizeBuffer.update(verticies.edgeScaling, verticies.edgeScaling.length);
            this.boneIndexBuffer.update(verticies.boneIndicies, verticies.boneIndicies.length);
            this.boneWeightBuffer.update(verticies.boneWeights, verticies.boneWeights.length);
        }
    }, {
        key: "updatePositionBuffer",
        value: function updatePositionBuffer() {
            this.positionBuffer.update(this.positionBuferSource, this.positionBuferSource.length);
        }
    }, {
        key: "updateUVBuffer",
        value: function updateUVBuffer() {
            this.uvBuffer.update(this.uvBufferSource, this.uvBufferSource.length);
        }
    }, {
        key: "__applyAttributeVariables",
        value: function __applyAttributeVariables(pWrapper, attributes) {
            _get(Object.getPrototypeOf(PMXGeometry.prototype), "__applyAttributeVariables", this).call(this, pWrapper, attributes);
            this.__assignAttributeIfExists(pWrapper, attributes, "edgeScaling", this.edgeSizeBuffer);
            this.__assignAttributeIfExists(pWrapper, attributes, "boneIndicies", this.boneIndexBuffer);
            this.__assignAttributeIfExists(pWrapper, attributes, "boneWeights", this.boneWeightBuffer);
        }
    }]);

    return PMXGeometry;
}(_BasicGeometry3.default);

exports.default = PMXGeometry;

},{"../../ContextComponents":8,"../../Core/Geometries/Base/BasicGeometry":21,"../../JThreeContext":267}],292:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = require("../../Math/Vector4");

var _Vector2 = _interopRequireDefault(_Vector);

var _Vector3 = require("../../Math/Vector3");

var _Vector4 = _interopRequireDefault(_Vector3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PMXMaterialMorphParamContainer = function () {
    function PMXMaterialMorphParamContainer(calcFlag) {
        _classCallCheck(this, PMXMaterialMorphParamContainer);

        this._calcFlag = calcFlag;
        var def = 1 - calcFlag;
        this.diffuse = [def, def, def, def];
        this.specular = [def, def, def, def];
        this.ambient = [def, def, def];
        this.edgeColor = [def, def, def, def];
        this.edgeSize = def;
        this.textureCoeff = [def, def, def, def];
        this.sphereCoeff = [def, def, def, def];
        this.toonCoeff = [def, def, def, def];
    }

    _createClass(PMXMaterialMorphParamContainer, null, [{
        key: "calcMorphedSingleValue",
        value: function calcMorphedSingleValue(base, add, mul, target) {
            return base * target(mul) + target(add);
        }
    }, {
        key: "calcMorphedVectorValue",
        value: function calcMorphedVectorValue(base, add, mul, target, vecLength) {
            switch (vecLength) {
                case 3:
                    return new _Vector4.default(base.X * target(mul)[0] + target(add)[0], base.Y * target(mul)[1] + target(add)[1], base.Z * target(mul)[2] + target(add)[2]);
                case 4:
                    return new _Vector2.default(base.X * target(mul)[0] + target(add)[0], base.Y * target(mul)[1] + target(add)[1], base.Z * target(mul)[2] + target(add)[2], base.W * target(mul)[3] + target(add)[3]);
            }
        }
    }]);

    return PMXMaterialMorphParamContainer;
}();

exports.default = PMXMaterialMorphParamContainer;

},{"../../Math/Vector3":278,"../../Math/Vector4":279}],293:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ResourceResolver = require("../../Core/Resources/ResourceResolver");

var _ResourceResolver2 = _interopRequireDefault(_ResourceResolver);

var _PMXPrimaryBufferMaterial = require("./Materials/PMXPrimaryBufferMaterial");

var _PMXPrimaryBufferMaterial2 = _interopRequireDefault(_PMXPrimaryBufferMaterial);

var _PMXCoreInitializer = require("./PMXCoreInitializer");

var _PMXCoreInitializer2 = _interopRequireDefault(_PMXCoreInitializer);

var _PMXHitAreaMaterial = require("./Materials/PMXHitAreaMaterial");

var _PMXHitAreaMaterial2 = _interopRequireDefault(_PMXHitAreaMaterial);

var _SceneObject2 = require("../../Core/SceneObjects/SceneObject");

var _SceneObject3 = _interopRequireDefault(_SceneObject2);

var _PMXData = require("../PMXData");

var _PMXData2 = _interopRequireDefault(_PMXData);

var _PMXGeometry = require("./PMXGeometry");

var _PMXGeometry2 = _interopRequireDefault(_PMXGeometry);

var _PMXMaterial = require("./Materials/PMXMaterial");

var _PMXMaterial2 = _interopRequireDefault(_PMXMaterial);

var _PMXSkeleton = require("./PMXSkeleton");

var _PMXSkeleton2 = _interopRequireDefault(_PMXSkeleton);

var _PMXMorphManager = require("./PMXMorphManager");

var _PMXMorphManager2 = _interopRequireDefault(_PMXMorphManager);

var _PMXTextureManager = require("./PMXTextureManager");

var _PMXTextureManager2 = _interopRequireDefault(_PMXTextureManager);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PMXModel = function (_SceneObject) {
    _inherits(PMXModel, _SceneObject);

    function PMXModel(pmx, resourceDirectory) {
        _classCallCheck(this, PMXModel);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PMXModel).call(this));

        _this.loadingTextureCount = 0;
        _this.loadedTextureCount = 0;
        _this.loaded = false;
        _this._materialDictionary = {};
        _PMXCoreInitializer2.default.init();
        _this.on("load", function () {
            _this.loaded = true;
        });
        _this._modelData = pmx;
        _this.modelDirectory = resourceDirectory;
        _this.pmxTextureManager = new _PMXTextureManager2.default(_this);
        _this.__geometry = new _PMXGeometry2.default(pmx);
        _this.skeleton = new _PMXSkeleton2.default(_this);
        _this._pmxMaterials = new Array(pmx.Materials.length);
        _this.name = pmx.Header.modelName;
        var offset = 0;
        for (var materialCount = 0; materialCount < pmx.Materials.length; materialCount++) {
            var currentMat = pmx.Materials[materialCount];
            var mat = new _PMXMaterial2.default(_this, materialCount, offset);
            _this.addMaterial(mat);
            _this.addMaterial(new _PMXPrimaryBufferMaterial2.default(mat));
            // this.addMaterial(new PMXShadowMapMaterial(mat));
            _this.addMaterial(new _PMXHitAreaMaterial2.default(mat));
            _this._pmxMaterials[materialCount] = mat;
            _this._materialDictionary[currentMat.materialName] = mat;
            offset += currentMat.vertexCount;
        }
        _this._morphManager = new _PMXMorphManager2.default(_this);
        return _this;
    }

    _createClass(PMXModel, [{
        key: "getPMXMaterialByName",
        value: function getPMXMaterialByName(name) {
            return this._materialDictionary[name];
        }
    }, {
        key: "getPMXMaterialByIndex",
        value: function getPMXMaterialByIndex(index) {
            return this._pmxMaterials[index];
        }
    }, {
        key: "update",
        value: function update() {
            this._morphManager.applyMorph();
            this.skeleton.updateMatricies();
        }
    }, {
        key: "ModelData",
        get: function get() {
            return this._modelData;
        }
    }, {
        key: "Materials",
        get: function get() {
            return this._pmxMaterials;
        }
    }, {
        key: "MorphManager",
        get: function get() {
            return this._morphManager;
        }
    }], [{
        key: "loadFromUrl",
        value: function loadFromUrl(url) {
            var directory = url.substr(0, url.lastIndexOf("/") + 1);
            return PMXModel._loadDataFromUrl(url, directory).then(function (modelData) {
                var deferred = _q2.default.defer();
                var model = new PMXModel(modelData, directory);
                if (model.loaded) {
                    process.nextTick(function () {
                        deferred.resolve(model);
                    });
                } else {
                    model.on("load", function () {
                        deferred.resolve(model);
                    });
                }
                return deferred.promise;
            }, function (err) {
                return err;
            });
        }
        /**
         * Request model data to specified url.
         * @param  {string}                   url the url pmx model being placed.
         * @return {Q.IPromise<PMXModelData>}     the promise object for loading.
         */

    }, {
        key: "_loadDataFromUrl",
        value: function _loadDataFromUrl(url, directory) {
            return PMXModel._cacheResolver.fetch(url, function (path) {
                var deferred = _q2.default.defer();
                var xhr = new XMLHttpRequest();
                xhr.open("GET", path, true);
                xhr.setRequestHeader("Accept", "*/*");
                xhr.responseType = "arraybuffer";
                xhr.onload = function () {
                    var pmx = new _PMXData2.default(xhr.response, directory);
                    deferred.resolve(pmx);
                };
                xhr.onerror = function (err) {
                    deferred.reject(err);
                };
                xhr.send(null);
                return deferred.promise;
            });
        }
    }]);

    return PMXModel;
}(_SceneObject3.default);

PMXModel._cacheResolver = new _ResourceResolver2.default();
exports.default = PMXModel;

}).call(this,require('_process'))

},{"../../Core/Resources/ResourceResolver":125,"../../Core/SceneObjects/SceneObject":151,"../PMXData":302,"./Materials/PMXHitAreaMaterial":285,"./Materials/PMXMaterial":286,"./Materials/PMXPrimaryBufferMaterial":287,"./PMXCoreInitializer":290,"./PMXGeometry":291,"./PMXMorphManager":295,"./PMXSkeleton":296,"./PMXTextureManager":297,"_process":319,"q":338}],294:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PMXMorph = function () {
    function PMXMorph(pmxModel, index, morphManager) {
        _classCallCheck(this, PMXMorph);

        this._progress = 0;
        this._progressCurrentCache = 0;
        this.__model = pmxModel;
        this.__morphIndex = index;
        this.__morphManager = morphManager;
    }

    _createClass(PMXMorph, [{
        key: "update",
        value: function update() {
            if (this._progress !== this._progressCurrentCache) {
                this.__updateProgress(this._progressCurrentCache, this._progress);
                this._progress = this._progressCurrentCache;
                this.__morphManager.postProcessFlag[this.TargetMorphData.morphKind] = true;
            }
        }
    }, {
        key: "Progress",
        get: function get() {
            return this._progress;
        },
        set: function set(val) {
            if (this._progressCurrentCache !== val) {
                this._progressCurrentCache = val;
            }
        }
    }, {
        key: "MorphName",
        get: function get() {
            return this.TargetMorphData.morphName;
        }
    }, {
        key: "TargetMorphData",
        get: function get() {
            return this.__model.ModelData.Morphs[this.__morphIndex];
        }
    }], [{
        key: "createMorph",
        value: function createMorph(model, index, morphManager) {
            var morphData = model.ModelData.Morphs[index];
            switch (morphData.morphKind) {
                case 0:
                    return new PMXGroupMorph(model, index, morphManager);
                case 1:
                    return new PMXVertexMorph(model, index, morphManager);
                case 3:
                    return new PMXUVMorph(model, index, morphManager);
                case 8:
                    return new PMXMaterialMorph(model, index, morphManager);
                default:
                    return null;
            }
        }
    }, {
        key: "postProcess",
        value: function postProcess(model, morphType) {
            switch (morphType) {
                case 1:
                    PMXVertexMorph.postProcess(model);
                    return;
                case 2:
                    PMXUVMorph.postProcess(model);
                    return;
            }
        }
    }]);

    return PMXMorph;
}();

var PMXVertexMorph = function (_PMXMorph) {
    _inherits(PMXVertexMorph, _PMXMorph);

    function PMXVertexMorph() {
        _classCallCheck(this, PMXVertexMorph);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(PMXVertexMorph).apply(this, arguments));
    }

    _createClass(PMXVertexMorph, [{
        key: "__updateProgress",
        value: function __updateProgress(current, last) {
            var ratio = current - last;
            for (var i = 0; i < this.TargetMorphData.morphOffsetCount; ++i) {
                var vm = this.TargetMorphData.vertexMorph[i];
                this.__model.Geometry.positionBuferSource[3 * vm.vertexIndex + 0] += vm.vertexOffset[0] * ratio;
                this.__model.Geometry.positionBuferSource[3 * vm.vertexIndex + 1] += vm.vertexOffset[1] * ratio;
                this.__model.Geometry.positionBuferSource[3 * vm.vertexIndex + 2] += vm.vertexOffset[2] * ratio;
            }
        }
    }], [{
        key: "postProcess",
        value: function postProcess(model) {
            model.Geometry.updatePositionBuffer();
        }
    }]);

    return PMXVertexMorph;
}(PMXMorph);

var PMXUVMorph = function (_PMXMorph2) {
    _inherits(PMXUVMorph, _PMXMorph2);

    function PMXUVMorph() {
        _classCallCheck(this, PMXUVMorph);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(PMXUVMorph).apply(this, arguments));
    }

    _createClass(PMXUVMorph, [{
        key: "__updateProgress",
        value: function __updateProgress(current, last) {
            var ratio = current - last;
            for (var i = 0; i < this.TargetMorphData.morphOffsetCount; ++i) {
                var vm = this.TargetMorphData.uvMorph[i];
                this.__model.Geometry.uvBufferSource[3 * vm.vertexIndex + 0] += vm.uvOffset[0] * ratio;
                this.__model.Geometry.uvBufferSource[3 * vm.vertexIndex + 1] += vm.uvOffset[1] * ratio;
                this.__model.Geometry.uvBufferSource[3 * vm.vertexIndex + 2] += vm.uvOffset[2] * ratio;
            }
        }
    }], [{
        key: "postProcess",
        value: function postProcess(model) {
            model.Geometry.updateUVBuffer();
        }
    }]);

    return PMXUVMorph;
}(PMXMorph);

var PMXGroupMorph = function (_PMXMorph3) {
    _inherits(PMXGroupMorph, _PMXMorph3);

    function PMXGroupMorph() {
        _classCallCheck(this, PMXGroupMorph);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(PMXGroupMorph).apply(this, arguments));
    }

    _createClass(PMXGroupMorph, [{
        key: "__updateProgress",
        value: function __updateProgress(current, last) {
            var ratio = current - last;
            for (var i = 0; i < this.TargetMorphData.morphOffsetCount; ++i) {
                var vm = this.TargetMorphData.groupMorph[i];
                var m = this.__morphManager.getMorphByIndex(vm.morphIndex);
                if (m) {
                    m.Progress += ratio * vm.morphRate;
                }
            }
        }
    }]);

    return PMXGroupMorph;
}(PMXMorph);

var PMXMaterialMorph = function (_PMXMorph4) {
    _inherits(PMXMaterialMorph, _PMXMorph4);

    function PMXMaterialMorph() {
        _classCallCheck(this, PMXMaterialMorph);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(PMXMaterialMorph).apply(this, arguments));
    }

    _createClass(PMXMaterialMorph, [{
        key: "__updateProgress",
        value: function __updateProgress(current, last) {
            var ratio = current - last;
            for (var i = 0; i < this.TargetMorphData.morphOffsetCount; ++i) {
                var vm = this.TargetMorphData.materialMorph[i];
                var targetMaterials = undefined;
                if (vm.materialIndex === -1) {
                    targetMaterials = this.__model.Materials;
                } else {
                    targetMaterials = [this.__model.getPMXMaterialByIndex(vm.materialIndex)];
                }
                for (var j = 0; j < targetMaterials.length; j++) {
                    var targetMaterial = targetMaterials[j];
                    var target = vm.operationType === 1 ? targetMaterial.addMorphParam : targetMaterial.mulMorphParam;
                    target.edgeSize += ratio * (vm.edgeSize + vm.operationType - 1);
                    this._assignMorphValues(3, target.ambient, vm.ambient, ratio, vm.operationType);
                    this._assignMorphValues(4, target.diffuse, vm.diffuse, ratio, vm.operationType);
                    this._assignMorphValues(4, target.specular, vm.specular, ratio, vm.operationType);
                    this._assignMorphValues(4, target.edgeColor, vm.edgeColor, ratio, vm.operationType);
                    this._assignMorphValues(4, target.textureCoeff, vm.textureCoefficient, ratio, vm.operationType);
                    this._assignMorphValues(4, target.sphereCoeff, vm.sphereTextureCoefficient, ratio, vm.operationType);
                    this._assignMorphValues(4, target.toonCoeff, vm.toonTextureCoefficient, ratio, vm.operationType);
                }
            }
        }
    }, {
        key: "_assignMorphValues",
        value: function _assignMorphValues(vecLength, target, morphValues, ratio, opType) {
            for (var i = 0; i < vecLength; i++) {
                target[i] += ratio * (morphValues[i] + opType - 1);
            }
        }
    }]);

    return PMXMaterialMorph;
}(PMXMorph);

exports.default = PMXMorph;

},{}],295:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _PMXMorph = require("./PMXMorph");

var _PMXMorph2 = _interopRequireDefault(_PMXMorph);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PMXMorphManager = function () {
    function PMXMorphManager(model) {
        _classCallCheck(this, PMXMorphManager);

        this.postProcessFlag = [false, false, false, false, false, false, false, false, false];
        this._morphsDictionary = {};
        this._model = model;
        this._morphs = new Array(model.ModelData.Morphs.length);
        for (var i = 0; i < model.ModelData.Morphs.length; ++i) {
            this._morphs[i] = _PMXMorph2.default.createMorph(model, i, this);
            if (this._morphs[i] != null) {
                this._morphsDictionary[this._morphs[i].MorphName] = this._morphs[i];
            }
        }
    }

    _createClass(PMXMorphManager, [{
        key: "applyMorph",
        value: function applyMorph() {
            for (var i = 0; i < this._morphs.length; ++i) {
                if (this._morphs[i] != null) {
                    this._morphs[i].update();
                }
            }
            for (var _i = 0; _i < this.postProcessFlag.length; _i++) {
                if (this.postProcessFlag[_i]) {
                    _PMXMorph2.default.postProcess(this._model, _i);
                    this.postProcessFlag[_i] = false;
                }
            }
        }
    }, {
        key: "getMorphByName",
        value: function getMorphByName(name) {
            return this._morphsDictionary[name];
        }
    }, {
        key: "getMorphByIndex",
        value: function getMorphByIndex(index) {
            return this._morphs[index];
        }
    }]);

    return PMXMorphManager;
}();

exports.default = PMXMorphManager;

},{"./PMXMorph":294}],296:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _PMXBone = require("./PMXBone");

var _PMXBone2 = _interopRequireDefault(_PMXBone);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PMXSkeleton = function () {
    function PMXSkeleton(model) {
        _classCallCheck(this, PMXSkeleton);

        this._rootBones = [];
        this._boneDictionary = {};
        model.skeleton = this;
        var bones = model.ModelData.Bones;
        this._bones = new Array(model.ModelData.Bones.length);
        this._bonesInTransformOrder = new Array(model.ModelData.Bones.length);
        this._matricies = new Float32Array(model.ModelData.Bones.length * 16);
        for (var i = 0; i < bones.length; i++) {
            var bone = bones[i];
            var pmxBone = new _PMXBone2.default(model, this, i);
            if (bone.parentBoneIndex === -1) {
                this._rootBones.push(pmxBone);
            }
            this._bonesInTransformOrder[i] = this._bones[i] = pmxBone;
            this._boneDictionary[bone.boneName] = pmxBone;
        }
        this._bones.forEach(function (v) {
            return v.boneDictionaryConstructed();
        });
        this._bonesInTransformOrder.sort(function (a, b) {
            return a.OrderCriteria - b.OrderCriteria;
        });
        this._matrixTexture = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager).createTexture("jthree.pmx.bonetransform" + model.id, 4, this._bones.length, WebGLRenderingContext.RGBA, WebGLRenderingContext.FLOAT);
    }

    _createClass(PMXSkeleton, [{
        key: "getBoneByName",
        value: function getBoneByName(name) {
            return this._boneDictionary[name];
        }
    }, {
        key: "getBoneByIndex",
        value: function getBoneByIndex(index) {
            return this._bones[index];
        }
    }, {
        key: "updateMatricies",
        value: function updateMatricies() {
            // this.updateBoneTransforms();
            for (var i = 0; i < this._bones.length; i++) {
                this._bones[i].applyMatrixToBuffer(this._matricies);
            }
            this._matrixTexture.updateTexture(this._matricies);
        }
    }, {
        key: "updateBoneTransforms",
        value: function updateBoneTransforms() {
            // this.rootBones.forEach(v=>v.callRecursive(l=>{
            // 	if(l["updateBoneTransform"])(<PMXBone>l).updateBoneTransform();
            // }));
            this._bonesInTransformOrder.forEach(function (v) {
                return v.updateBoneTransform();
            });
        }
    }, {
        key: "structureToString",
        value: function structureToString() {
            var result = "";
            this._rootBones.forEach(function (v) {
                return result += v.structureToString(0);
            });
            return result;
        }
    }, {
        key: "MatrixTexture",
        get: function get() {
            return this._matrixTexture;
        }
    }, {
        key: "BoneCount",
        get: function get() {
            return this._bones.length;
        }
    }]);

    return PMXSkeleton;
}();

exports.default = PMXSkeleton;

},{"../../ContextComponents":8,"../../JThreeContext":267,"./PMXBone":288}],297:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _JThreeLogger = require("../../Base/JThreeLogger");

var _JThreeLogger2 = _interopRequireDefault(_JThreeLogger);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PMXTextureManager = function () {
    function PMXTextureManager(model) {
        _classCallCheck(this, PMXTextureManager);

        this._model = model;
    }

    _createClass(PMXTextureManager, [{
        key: "generateSharedToonImg",
        value: function generateSharedToonImg(index) {
            if (PMXTextureManager.imgConvertedToons[index]) {
                return PMXTextureManager.imgConvertedToons[index];
            } else {
                var imgTag = document.createElement("img");
                imgTag.src = PMXTextureManager._toons[index];
                PMXTextureManager.imgConvertedToons[index] = imgTag;
                return imgTag;
            }
        }
    }, {
        key: "loadTexture",
        value: function loadTexture(index) {
            var _this = this;

            var deferred = _q2.default.defer();
            if (index < 0) {
                process.nextTick(function () {
                    deferred.resolve(null);
                });
                return deferred.promise;
            }
            this._model.loadingTextureCount++;
            var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
            return rm.loadTexture(this._model.modelDirectory + this._model.ModelData.Textures[index]).then(function (texture) {
                process.nextTick(function () {
                    _this._model.loadedTextureCount++;
                    _JThreeLogger2.default.sectionLog("pmx texture", "loaded texture " + _this._model.loadedTextureCount + " / " + _this._model.loadingTextureCount);
                    if (_this._model.loadingTextureCount === _this._model.loadedTextureCount) {
                        _this._model.emit("load", _this._model);
                    }
                    deferred.resolve(texture);
                });
                return deferred.promise;
            }, function (error) {
                process.nextTick(function () {
                    _this._model.loadedTextureCount++;
                    _JThreeLogger2.default.sectionError("pmx texture", "load failure texture " + _this._model.loadedTextureCount + " / " + _this._model.loadingTextureCount + "  " + error);
                    if (_this._model.loadingTextureCount === _this._model.loadedTextureCount) {
                        _this._model.emit("load", _this._model);
                    }
                    deferred.reject(error);
                });
                return deferred.promise;
            });
        }
    }]);

    return PMXTextureManager;
}();

PMXTextureManager.imgConvertedToons = [];
PMXTextureManager._toons = ["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAABlBMVEX////Nzc1XNMFjAAAAD0lEQVQI12OgNvgPBFQkAPcnP8G6A9XkAAAAAElFTkSuQmCC", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAABlBMVEX////14eF2pXIGAAAAD0lEQVQI12OgNvgPBFQkAPcnP8G6A9XkAAAAAElFTkSuQmCC", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAABlBMVEX///+ampo+MvaSAAAAD0lEQVQI12OgNvgPBFQkAPcnP8G6A9XkAAAAAElFTkSuQmCC", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAABlBMVEX////47+sAKyXFAAAAD0lEQVQI12OgNvgPBFQkAPcnP8G6A9XkAAAAAElFTkSuQmCC", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEX/////5t3/6N7/7eX/+fb/9PD//Pv/8Op5dFmOAAAAQklEQVQoz2MYBRQDtjQYgAq4gEAIiEiBCIYiAEjYjaEcBIrLoSA0lMEYDTAooQEGRQgtqAgTEEQD5AgoYQggAFgOAHEkIrrgwCawAAAAAElFTkSuQmCC", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAflBMVEX/7WHDrAPErQT/7mT/7mn66Fj86VvizTLJswz/8of/8Hf/73L+7F7NtxLLtQ7/7mb///z//ez//OL/+9vs2ELk0Db//vX/+L7/723o1DzRvBjFrgX/+sz/+Lr/9qzw3Uj/+tL/97b/9Jf/85D/9Z//8X//6DHFrgb/+MD/5AUNrqVlAAAAwklEQVQ4y+XO226DMAwAUG/OutmhgyQQkgYYl162///BmaoV7UPFc9XzYlu2bMNrQrhS16hyRMxVCLlSgWrNmpkPvP8lDogKutb4Qbvajc5b6xpr92071qbvTMNMPfjCdzgVoulJkx2oNW4wtulqYl8YoIkVaq1lOcB8Sy4hjk4SDHTQd+8tcLokR1jxByuO8CKybDP7uLE5y84AyrKMsaqqz4VUMUZp/AjYbcW3+FrM5VbsBJxSen8kpXSCtxVPMfAPmVcPlflaGvEAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAC0lEQVQI12MY5AAAAKAAAfgHMzoAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAC0lEQVQI12MY5AAAAKAAAfgHMzoAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAC0lEQVQI12MY5AAAAKAAAfgHMzoAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAC0lEQVQI12MY5AAAAKAAAfgHMzoAAAAASUVORK5CYII="];
exports.default = PMXTextureManager;

}).call(this,require('_process'))

},{"../../Base/JThreeLogger":2,"../../ContextComponents":8,"../../JThreeContext":267,"_process":319,"q":338}],298:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SceneObjectNodeBase2 = require("./../../Goml/Nodes/SceneObjects/SceneObjectNodeBase");

var _SceneObjectNodeBase3 = _interopRequireDefault(_SceneObjectNodeBase2);

var _PMXModel = require("../Core/PMXModel");

var _PMXModel2 = _interopRequireDefault(_PMXModel);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PMXNode = function (_SceneObjectNodeBase) {
    _inherits(PMXNode, _SceneObjectNodeBase);

    function PMXNode() {
        _classCallCheck(this, PMXNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PMXNode).call(this));

        _this._pmxModel = null;
        _this._pmxLoadingDeferred = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceLoader).getResourceLoadingDeffered();
        _this.attributes.defineAttribute({
            "src": {
                converter: "string",
                value: "",
                onchanged: function onchanged(attr) {
                    attr.done();
                }
            }
        });
        return _this;
    }

    _createClass(PMXNode, [{
        key: "__onMount",
        value: function __onMount() {
            var _this2 = this;

            _get(Object.getPrototypeOf(PMXNode.prototype), "__onMount", this).call(this);
            _PMXModel2.default.loadFromUrl(this.attributes.getValue("src")).then(function (m) {
                _this2._pmxModel = m;
                _this2.TargetSceneObject = _this2._pmxModel;
                _this2.emit("loaded");
                _this2._pmxLoadingDeferred.resolve(null);
            });
        }
    }, {
        key: "PMXModel",
        get: function get() {
            return this._pmxModel;
        }
    }, {
        key: "PMXModelReady",
        get: function get() {
            return this.PMXModel != null;
        }
    }]);

    return PMXNode;
}(_SceneObjectNodeBase3.default);

exports.default = PMXNode;

},{"../../ContextComponents":8,"../../JThreeContext":267,"../Core/PMXModel":293,"./../../Goml/Nodes/SceneObjects/SceneObjectNodeBase":213}],299:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<material name=\"jthree.pmx.forward\" group=\"builtin.forward\" order=\"300\">\n<registers>\n  <register name=\"builtin.basic\"/>\n  <register name=\"builtin.buffer\"/>\n</registers>\n<passes>\n  <pass>\n    <glsl>\n      <![CDATA[\n      attribute vec3 position;\n      attribute vec3 normal;\n      attribute vec2 uv;\n      attribute vec4 boneWeights;\n      attribute vec4 boneIndicies;\n      varying vec3 vNormal;\n      varying vec4 vPosition;\n      varying vec2 vUV;\n      varying vec2 vSphereUV;\n      varying vec4 vBaseColor;\n\n      @vert{\n        @import \"jthree.pmx.vertex\"\n        uniform mat4 _matV;\n        uniform mat4 _matPV;\n        @{register:2}\n        uniform sampler2D boneMatriciesTexture;\n        uniform float boneCount;\n        uniform vec4 diffuse;\n        uniform vec3 ambient;\n        uniform vec3 ambientCoefficient;\n\n        void main(void){\n          vUV = uv;\n          mat4 boneTransform=calcBoneTransform(boneMatriciesTexture,boneCount,boneWeights,boneIndicies);\n          vPosition=gl_Position = calcPosition(boneTransform,_matPV,position);\n          vNormal = calcNormal(boneTransform,_matV,normal);\n          vSphereUV = calcSphereUV(vNormal);\n          vBaseColor.rgb = diffuse.rgb + ambient.rgb;\n          vBaseColor.a = diffuse.a;\n          vBaseColor = clamp(vBaseColor,0.,1.);\n        }\n      }\n      @frag{\n        @{type:\"buffer\",name:\"DLIGHT\",register:0}\n        uniform sampler2D _dlBuffer;\n        @{type:\"buffer\",name:\"SLIGHT\",register:1}\n        uniform sampler2D _slBuffer;\n\n        uniform vec4 specular;\n        @{register:3}\n        uniform sampler2D texture;\n        @{register:4}\n        uniform sampler2D sphere;\n        @{register:5}\n        uniform sampler2D toon;\n        uniform int textureUsed;\n        uniform int sphereMode;\n        uniform int toonFlag;\n        uniform vec4 addTexCoeff;\n        uniform vec4 mulTexCoeff;\n        uniform vec4 addSphereCoeff;\n        uniform vec4 mulSphereCoeff;\n        uniform vec4 addToonCoeff;\n        uniform vec4 mulToonCoeff;\n\n        vec2 calcLightUV(vec4 projectionSpacePos)\n        {\n           return (projectionSpacePos.xy / projectionSpacePos.w + vec2(1,1)) / 2.;\n        }\n\n        vec4 blendPMXTexture(sampler2D source,vec2 uv,vec4 addCoeff,vec4 mulCoeff)\n        {\n            vec4 result = texture2D(source,uv);\n            result.rgb = mix(mix(result.rgb,vec3(0,0,0),addCoeff.a),vec3(1,1,1),1.-mulCoeff.a);\n            result.rgb = result.rgb * mulCoeff.rgb + addCoeff.rgb;\n            return result;\n        }\n\n\n\n        void main(void){\n          vec2 lightUV=calcLightUV(vPosition);\n          vec3 dlc = texture2D(_dlBuffer,lightUV).rgb;\n          vec3 slc = texture2D(_slBuffer,lightUV).rgb;\n          vec4 dc = vBaseColor;\n          if(textureUsed == 1)\n          {\n            dc *= blendPMXTexture(texture,vUV,addTexCoeff,mulTexCoeff);\n          }\n          if(sphereMode == 1){\n            dc.rgb *= texture2D(sphere,vSphereUV).rgb;\n          }else if(sphereMode == 2){\n            dc.rgb += texture2D(sphere,vSphereUV).rgb;\n          }\n          if(toonFlag==1)\n          {\n          \t float brightness = max(max(dlc.r,dlc.g),dlc.b);\n              dc.rgb = dlc * blendPMXTexture(toon,vec2(0,1.-brightness),addToonCoeff ,mulToonCoeff ).rgb * dc.rgb;\n          }else\n          {\n              dc.rgb = dlc * dc.rgb;\n          }\n          dc.rgb += slc * specular.rgb;\n          gl_FragColor = dc;\n        }\n\n      }\n      ]]>\n    </glsl>\n  </pass>\n  <pass>\n    <cull mode=\"front\"/>\n    <glsl>\n      <![CDATA[\n      attribute vec3 position;\n      attribute vec3 normal;\n      attribute vec4 boneWeights;\n      attribute vec4 boneIndicies;\n      attribute float edgeScaling;\n      @vert{\n        @import \"jthree.pmx.vertex\"\n        uniform mat4 _matPV;\n        uniform vec2 _resolution;\n        @{register:2}\n        uniform sampler2D boneMatriciesTexture;\n        uniform float boneCount;\n        uniform float edgeSize;\n        void main(void){\n          mat4 boneTransform=calcBoneTransform(boneMatriciesTexture,boneCount,boneWeights,boneIndicies);\n          mat4 matPVM = _matPV * boneTransform;\n          vec4 p0 = matPVM * vec4(position ,1);\n          vec4 p1 = matPVM * vec4(position + normal ,1);\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n          float coeff = length(_resolution/2.0 * abs(p0.xy - p1.xy));\n          coeff = 1.0 / coeff;\n          coeff *= edgeSize * edgeScaling;\n          if(coeff > 5.0)coeff = 5.;\n          gl_Position = matPVM * vec4(position + coeff * normal,1);\n        }\n      }\n      @frag{\n\n        uniform vec4 edgeColor;\n\n        void main()\n        {\n          gl_FragColor = edgeColor;\n        }\n      }\n      ]]>\n    </glsl>\n  </pass>\n</passes>\n</material>\n"
},{}],300:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<material name=\"jthree.pmx.hitarea\" group=\"jthree.materials.hitarea\" order=\"300\">\n<registers>\n  <register name=\"builtin.basic\"/>\n</registers>\n<passes>\n  <pass>\n    <glsl>\n      <![CDATA[\n      attribute vec3 position;\n      attribute vec4 boneWeights;\n      attribute vec4 boneIndicies;\n\n      @vert{\n        @import \"jthree.pmx.vertex\"\n        uniform mat4 _matPV;\n        @{register:0}\n        uniform sampler2D boneMatriciesTexture;\n        uniform float boneCount;\n\n        void main(void){\n          mat4 boneTransform=calcBoneTransform(boneMatriciesTexture,boneCount,boneWeights,boneIndicies);\n          gl_Position = calcPosition(boneTransform,_matPV,position);\n        }\n      }\n      @frag{\n\n        uniform vec4 indexColor;\n\n        void main()\n        {\n        \tgl_FragColor = indexColor;\n        }\n      }\n      ]]>\n    </glsl>\n  </pass>\n</passes>\n</material>\n"
},{}],301:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<material name=\"jthree.gbuffer.pmx.1\" group=\"jthree.basic.gbuffer.1\" order=\"300\">\n<registers>\n  <register name=\"builtin.basic\"/>\n</registers>\n<passes>\n  <pass>\n    <blend enabled=\"false\"/>\n    <glsl>\n      <![CDATA[\n      attribute vec3 position;\n      attribute vec3 normal;\n      attribute vec2 uv;\n      attribute vec4 boneWeights;\n      attribute vec4 boneIndicies;\n      varying vec4 vPosition;\n      varying vec3 vNormal;\n\n      @vert{\n        @import \"jthree.pmx.vertex\"\n        uniform mat4 _matV;\n        uniform mat4 _matPV;\n        @{register:2}\n        uniform sampler2D boneMatriciesTexture;\n        uniform float boneCount;\n\n        void main(void){\n          mat4 boneTransform=calcBoneTransform(boneMatriciesTexture,boneCount,boneWeights,boneIndicies);\n          gl_Position = calcPosition(boneTransform,_matPV,position);\n          vNormal= calcNormal(boneTransform,_matV,normal);\n        }\n      }\n      @frag{\n        @import \"builtin.packing\"\n        @import \"builtin.gbuffer-packing\"\n\n        vec2 compressNormal()\n        {\n        \tfloat p = sqrt(vNormal.z * 8. + 8.);\n        \treturn vNormal.xy/p + 0.5;\n        }\n\n        vec4 packedNormal()\n        {\n          vec2 cNor = compressNormal();\n          return vec4(packRanged16(cNor.x,CNOR_MIN,CNOR_MAX),packRanged16(cNor.y,CNOR_MIN,CNOR_MAX));\n        }\n\n        void main(void)\n        {\n        \tgl_FragColor = packedNormal();\n        }\n      }\n      ]]>\n    </glsl>\n  </pass>\n</passes>\n</material>\n"
},{}],302:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ImageLoader = require("../Core/Resources/ImageLoader");

var _ImageLoader2 = _interopRequireDefault(_ImageLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PMXData = function () {
    function PMXData(data, resourceDirectory) {
        _classCallCheck(this, PMXData);

        this._offset = 0;
        this._resourceDirectory = resourceDirectory;
        this._reader = new DataView(data, 0, data.byteLength);
        this._loadHeader();
        this._loadVerticies();
        this._loadSurfaces();
        this._loadTextures();
        this._loadMaterials();
        this._loadBones();
        this._loadMorphs();
        this._loadDisplayFrames();
        this._loadRigidBodies();
        this._loadJoints();
    }

    _createClass(PMXData, [{
        key: "_readTextBuffer",
        value: function _readTextBuffer() {
            var length = this._readInt32();
            if (this._header.encoding === 0) {
                return this._readUTF16LEString(length);
            }
            return this._readUTF8String(length);
        }
    }, {
        key: "_loadHeader",
        value: function _loadHeader() {
            this._readUint32(); // pass magic
            this._header = {
                version: this._readFloat32(),
                headerByteSize: this._readUint8(),
                encoding: this._readUint8(),
                uvAddition: this._readUint8(),
                vertexIndexSize: this._readUint8(),
                textureIndexSize: this._readUint8(),
                materialIndexSize: this._readUint8(),
                boneIndexSize: this._readUint8(),
                morphIndexSize: this._readUint8(),
                rigidBodyIndexSize: this._readUint8(),
                modelName: "",
                modelNameEn: "",
                comment: "",
                commentEn: ""
            };
            this._header.modelName = this._readTextBuffer();
            this._header.modelNameEn = this._readTextBuffer();
            this._header.comment = this._readTextBuffer();
            this._header.commentEn = this._readTextBuffer();
        }
    }, {
        key: "_readBoneIndex",
        value: function _readBoneIndex() {
            return this._readIndexExceptVertex(this._header.boneIndexSize);
        }
    }, {
        key: "_readTextureIndex",
        value: function _readTextureIndex() {
            return this._readIndexExceptVertex(this._header.textureIndexSize);
        }
    }, {
        key: "_readMorphIndex",
        value: function _readMorphIndex() {
            return this._readIndexExceptVertex(this._header.morphIndexSize);
        }
    }, {
        key: "_readMaterialIndex",
        value: function _readMaterialIndex() {
            return this._readIndexExceptVertex(this._header.materialIndexSize);
        }
    }, {
        key: "_readRegidBodyIndex",
        value: function _readRegidBodyIndex() {
            return this._readIndexExceptVertex(this._header.rigidBodyIndexSize);
        }
    }, {
        key: "_readVertexIndex",
        value: function _readVertexIndex() {
            switch (this._header.vertexIndexSize) {
                case 1:
                    return this._readUint8();
                case 2:
                    return this._readUint16();
                case 4:
                    return this._readInt32();
            }
        }
    }, {
        key: "_readIndexExceptVertex",
        value: function _readIndexExceptVertex(byte) {
            switch (byte) {
                case 1:
                    return this._readInt8();
                case 2:
                    return this._readInt16();
                case 4:
                    return this._readInt32();
            }
        }
    }, {
        key: "_loadVerticies",
        value: function _loadVerticies() {
            var count = this._readInt32();
            var uvCount = this._header.uvAddition;
            // allocate arrays
            var additionalUvs = new Array(uvCount);
            for (var i = 0; i < uvCount; i++) {
                additionalUvs[i] = new Array(count * 4);
            }
            var bi1 = 0,
                bi2 = 0,
                bi3 = 0,
                bi4 = 0;
            var bw1 = 0,
                bw2 = 0,
                bw3 = 0,
                bw4 = 0;
            var sumCache = 0;
            var result = {
                positions: new Array(count * 3),
                normals: new Float32Array(count * 3),
                uvs: new Array(count * 2),
                additionalUV: additionalUvs,
                edgeScaling: new Float32Array(count),
                verticies: new Array(count),
                boneIndicies: new Float32Array(count * 4),
                boneWeights: new Float32Array(count * 4)
            };
            for (var _i = 0; _i < count; _i++) {
                bi1 = 0;
                bi2 = 0;
                bi3 = 0;
                bi4 = 0;
                bw1 = 0;
                bw2 = 0;
                bw3 = 0;
                bw4 = 0;
                result.positions[3 * _i + 0] = this._readFloat32();
                result.positions[3 * _i + 1] = this._readFloat32();
                result.positions[3 * _i + 2] = -this._readFloat32();
                result.normals[3 * _i + 0] = this._readFloat32();
                result.normals[3 * _i + 1] = this._readFloat32();
                result.normals[3 * _i + 2] = -this._readFloat32();
                result.uvs[2 * _i + 0] = this._readFloat32();
                result.uvs[2 * _i + 1] = this._readFloat32();
                for (var j = 0; j < uvCount; j++) {
                    result.additionalUV[j][4 * _i + 0] = this._readFloat32();
                    result.additionalUV[j][4 * _i + 1] = this._readFloat32();
                    result.additionalUV[j][4 * _i + 2] = this._readFloat32();
                    result.additionalUV[j][4 * _i + 3] = this._readFloat32();
                }
                result.verticies[_i] = { weightTransform: this._readUint8() };
                switch (result.verticies[_i].weightTransform) {
                    case 0:
                        bi1 = this._readBoneIndex();
                        bw1 = 1;
                        break;
                    case 1:
                        bi1 = this._readBoneIndex();
                        bi2 = this._readBoneIndex();
                        bw1 = this._readFloat32();
                        bw2 = 1 - bw1;
                        break;
                    case 2:
                        bi1 = this._readBoneIndex();
                        bi2 = this._readBoneIndex();
                        bi3 = this._readBoneIndex();
                        bi4 = this._readBoneIndex();
                        bw1 = this._readFloat32();
                        bw2 = this._readFloat32();
                        bw3 = this._readFloat32();
                        bw4 = this._readFloat32();
                        sumCache = bw1 + bw2 + bw3 + bw4;
                        bw1 /= sumCache;
                        bw2 /= sumCache;
                        bw3 /= sumCache;
                        bw4 /= sumCache;
                        break;
                    case 3:
                        bi1 = this._readBoneIndex();
                        bi2 = this._readBoneIndex();
                        bw1 = this._readFloat32();
                        bw2 = 1 - bw1;
                        result.verticies[_i].sdef = {
                            boneParams: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()]
                        };
                        break;
                }
                result.boneIndicies[4 * _i + 0] = bi1;
                result.boneIndicies[4 * _i + 1] = bi2;
                result.boneIndicies[4 * _i + 2] = bi3;
                result.boneIndicies[4 * _i + 3] = bi4;
                result.boneWeights[4 * _i + 0] = bw1;
                result.boneWeights[4 * _i + 1] = bw2;
                result.boneWeights[4 * _i + 2] = bw3;
                result.boneWeights[4 * _i + 3] = bw4;
                result.edgeScaling[_i] = this._readFloat32();
            }
            this._verticies = result;
        }
    }, {
        key: "_loadSurfaces",
        value: function _loadSurfaces() {
            var count = this._readInt32();
            this._surfaces = new Array(count);
            for (var i = 0; i < count / 3; i++) {
                this._surfaces[3 * i + 0] = this._readVertexIndex();
                this._surfaces[3 * i + 2] = this._readVertexIndex();
                this._surfaces[3 * i + 1] = this._readVertexIndex();
            }
        }
    }, {
        key: "_loadTextures",
        value: function _loadTextures() {
            var count = this._readInt32();
            this._textures = new Array(count);
            for (var i = 0; i < count; i++) {
                this._textures[i] = this._readTextBuffer().replace("\\", "/");
                _ImageLoader2.default.loadImage(this._resourceDirectory + this._textures[i]);
            }
        }
    }, {
        key: "_loadMaterials",
        value: function _loadMaterials() {
            var count = this._readInt32();
            this._materials = new Array(count);
            var cache = 0;
            for (var i = 0; i < count; i++) {
                this._materials[i] = {
                    materialName: this._readTextBuffer(),
                    materialNameEn: this._readTextBuffer(),
                    diffuse: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()],
                    specular: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()],
                    ambient: [this._readFloat32(), this._readFloat32(), this._readFloat32()],
                    drawFlag: this._readUint8(),
                    edgeColor: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()],
                    edgeSize: this._readFloat32(),
                    textureIndex: this._readTextureIndex(),
                    sphereTextureIndex: this._readTextureIndex(),
                    sphereMode: this._readUint8(),
                    sharedToonFlag: cache = this._readUint8(),
                    targetToonIndex: cache === 0 ? this._readTextureIndex() : this._readUint8(),
                    memo: this._readTextBuffer(),
                    vertexCount: this._readInt32()
                };
            }
        }
    }, {
        key: "_loadBones",
        value: function _loadBones() {
            var count = this._readUint32();
            this._bones = new Array(count);
            var boneFlagCache = 0;
            var ikLinkCountCache = 0;
            var ikLimitedCache = 0;
            for (var i = 0; i < count; i++) {
                this._bones[i] = {
                    boneName: this._readTextBuffer(),
                    boneNameEn: this._readTextBuffer(),
                    position: [this._readFloat32(), this._readFloat32(), -this._readFloat32()],
                    parentBoneIndex: this._readBoneIndex(),
                    transformLayer: this._readInt32(),
                    boneFlag: boneFlagCache = this._readUint16(),
                    positionOffset: (boneFlagCache & 0x0001) === 0 ? [this._readFloat32(), this._readFloat32(), -this._readFloat32()] : undefined,
                    connectingBoneIndex: (boneFlagCache & 0x0001) > 0 ? this._readBoneIndex() : undefined,
                    providingBoneIndex: (boneFlagCache & 0x0100) > 0 || (boneFlagCache & 0x0200) > 0 ? this._readBoneIndex() : undefined,
                    providingRate: (boneFlagCache & 0x0100) > 0 || (boneFlagCache & 0x0200) > 0 ? this._readFloat32() : undefined,
                    fixedAxis: (boneFlagCache & 0x0400) > 0 ? [this._readFloat32(), this._readFloat32(), -this._readFloat32()] : undefined,
                    localAxisX: (boneFlagCache & 0x0800) > 0 ? [this._readFloat32(), this._readFloat32(), -this._readFloat32()] : undefined,
                    localAxisZ: (boneFlagCache & 0x0800) > 0 ? [this._readFloat32(), this._readFloat32(), -this._readFloat32()] : undefined,
                    externalParentTransformKey: (boneFlagCache & 0x2000) > 0 ? this._readInt32() : undefined,
                    ikTargetBoneIndex: (boneFlagCache & 0x0020) > 0 ? this._readBoneIndex() : undefined,
                    ikLoopCount: (boneFlagCache & 0x0020) > 0 ? this._readInt32() : undefined,
                    ikLimitedRotation: (boneFlagCache & 0x0020) > 0 ? this._readFloat32() : undefined,
                    ikLinkCount: (boneFlagCache & 0x0020) > 0 ? ikLinkCountCache = this._readInt32() : ikLinkCountCache = undefined,
                    ikLinks: (boneFlagCache & 0x0020) > 0 ? new Array(ikLinkCountCache) : undefined
                };
                if (ikLinkCountCache) {
                    for (var j = 0; j < ikLinkCountCache; j++) {
                        this._bones[i].ikLinks[j] = {
                            ikLinkBoneIndex: this._readBoneIndex(),
                            isLimitedRotation: ikLimitedCache = this._readUint8(),
                            limitedRotation: ikLimitedCache > 0 ? [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()] : undefined
                        };
                    }
                }
            }
        }
    }, {
        key: "_loadMorphs",
        value: function _loadMorphs() {
            var count = this._readInt32();
            this._morphs = new Array(count);
            var morphCountCache = 0;
            for (var i = 0; i < count; i++) {
                this._morphs[i] = {
                    morphName: this._readTextBuffer(),
                    morphNameEn: this._readTextBuffer(),
                    editPanel: this._readUint8(),
                    morphKind: this._readUint8(),
                    morphOffsetCount: morphCountCache = this._readInt32()
                };
                switch (this._morphs[i].morphKind) {
                    case 0:
                        // group morph
                        this._morphs[i].groupMorph = new Array(morphCountCache);
                        for (var j = 0; j < morphCountCache; j++) {
                            this._morphs[i].groupMorph[j] = {
                                morphIndex: this._readMorphIndex(),
                                morphRate: this._readFloat32()
                            };
                        }
                        break;
                    case 1:
                        this._morphs[i].vertexMorph = new Array(morphCountCache);
                        for (var _j = 0; _j < morphCountCache; _j++) {
                            this._morphs[i].vertexMorph[_j] = {
                                vertexIndex: this._readVertexIndex(),
                                vertexOffset: [this._readFloat32(), this._readFloat32(), -this._readFloat32()]
                            };
                        }
                        break;
                    case 2:
                        this._morphs[i].boneMorph = new Array(morphCountCache);
                        for (var _j2 = 0; _j2 < morphCountCache; _j2++) {
                            this._morphs[i].boneMorph[_j2] = {
                                boneIndex: this._readBoneIndex(),
                                translationOffset: [this._readFloat32(), this._readFloat32(), -this._readFloat32()],
                                rotationOffset: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()]
                            };
                        }
                        break;
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        this._morphs[i].uvMorph = new Array(morphCountCache);
                        for (var _j3 = 0; _j3 < morphCountCache; _j3++) {
                            this._morphs[i].uvMorph[_j3] = {
                                vertexIndex: this._readVertexIndex(),
                                uvOffset: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()]
                            };
                        }
                        break;
                    case 8:
                        this._morphs[i].materialMorph = new Array(morphCountCache);
                        for (var _j4 = 0; _j4 < morphCountCache; _j4++) {
                            this._morphs[i].materialMorph[_j4] = {
                                materialIndex: this._readMaterialIndex(),
                                operationType: this._readUint8(),
                                diffuse: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()],
                                specular: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()],
                                ambient: [this._readFloat32(), this._readFloat32(), this._readFloat32()],
                                edgeColor: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()],
                                edgeSize: this._readFloat32(),
                                textureCoefficient: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()],
                                sphereTextureCoefficient: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()],
                                toonTextureCoefficient: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()]
                            };
                        }
                        break;
                }
            }
        }
    }, {
        key: "_loadDisplayFrames",
        value: function _loadDisplayFrames() {
            var count = this._readInt32();
            this._displayFrames = new Array(count);
            var countCache = 0;
            var targetCache = 0;
            for (var i = 0; i < count; i++) {
                this._displayFrames[i] = {
                    frameName: this._readTextBuffer(),
                    frameNameEn: this._readTextBuffer(),
                    specialFrameFlag: this._readUint8(),
                    elementCount: countCache = this._readInt32(),
                    targetElementTypes: new Array(countCache),
                    targetIndex: new Array(countCache)
                };
                for (var j = 0; j < countCache; j++) {
                    this._displayFrames[i].targetElementTypes[j] = targetCache = this._readUint8();
                    this._displayFrames[i].targetIndex[j] = targetCache > 0 ? this._readMorphIndex() : this._readBoneIndex();
                }
            }
        }
    }, {
        key: "_loadRigidBodies",
        value: function _loadRigidBodies() {
            var count = this._readInt32();
            this._rigidBodies = new Array(count);
            for (var i = 0; i < count; i++) {
                this._rigidBodies[i] = {
                    rigidBodyName: this._readTextBuffer(),
                    rigidBodyNameEn: this._readTextBuffer(),
                    boneIndex: this._readBoneIndex(),
                    group: this._readUint8(),
                    unCollisionGroupFlag: this._readUint16(),
                    shape: this._readUint8(),
                    size: [this._readFloat32(), this._readFloat32(), this._readFloat32()],
                    position: [this._readFloat32(), this._readFloat32(), -this._readFloat32()],
                    rotation: [this._readFloat32(), this._readFloat32(), this._readFloat32()],
                    mass: this._readFloat32(),
                    translationFraction: this._readFloat32(),
                    rotationFraction: this._readFloat32(),
                    boundness: this._readFloat32(),
                    fraction: this._readFloat32(),
                    calcType: this._readUint8()
                };
            }
        }
    }, {
        key: "_loadJoints",
        value: function _loadJoints() {
            var count = this._readInt32();
            this._joints = new Array(count);
            var typeCache = 0;
            for (var i = 0; i < count; i++) {
                this._joints[i] = {
                    jointName: this._readTextBuffer(),
                    jointNameEn: this._readTextBuffer(),
                    jointType: typeCache = this._readUint8(),
                    spring: typeCache === 0 ? {
                        targetRigidBody1: this._readRegidBodyIndex(),
                        targetRigidBody2: this._readRegidBodyIndex(),
                        position: [this._readFloat32(), this._readFloat32(), this._readFloat32()],
                        rotation: [this._readFloat32(), this._readFloat32(), this._readFloat32()],
                        translationLimit: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()],
                        rotationLimit: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()],
                        springCoefficientLimit: [this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32(), this._readFloat32()]
                    } : undefined
                };
            }
        }
    }, {
        key: "_readUTF16LEString",
        value: function _readUTF16LEString(length) {
            // When this was UTF-16LE
            var textArr = [];
            for (var i = 0; i < length / 2; i++) {
                var c = this._readInt16();
                if (c === 0) {
                    continue; //  To discard null char
                }
                textArr.push(c);
            }
            return String.fromCharCode.apply(null, textArr);
        }
    }, {
        key: "_readUTF8String",
        value: function _readUTF8String(length) {
            var utf16 = new ArrayBuffer(length * 2);
            var utf16View = new Uint16Array(utf16);
            for (var i = 0; i < length; ++i) {
                utf16View[i] = this._readUint8();
            }
            return String.fromCharCode.apply(null, utf16View);
        }
    }, {
        key: "_readUint8",
        value: function _readUint8() {
            var result = this._reader.getUint8(this._offset);
            this._offset += 1;
            return result;
        }
    }, {
        key: "_readUint16",
        value: function _readUint16() {
            var result = this._reader.getUint16(this._offset, true);
            this._offset += 2;
            return result;
        }
    }, {
        key: "_readUint32",
        value: function _readUint32() {
            var result = this._reader.getUint32(this._offset, true);
            this._offset += 4;
            return result;
        }
    }, {
        key: "_readInt8",
        value: function _readInt8() {
            var result = this._reader.getInt8(this._offset);
            this._offset += 1;
            return result;
        }
    }, {
        key: "_readInt16",
        value: function _readInt16() {
            var result = this._reader.getInt16(this._offset, true);
            this._offset += 2;
            return result;
        }
    }, {
        key: "_readInt32",
        value: function _readInt32() {
            var result = this._reader.getInt32(this._offset, true);
            this._offset += 4;
            return result;
        }
    }, {
        key: "_readFloat32",
        value: function _readFloat32() {
            var result = this._reader.getFloat32(this._offset, true);
            this._offset += 4;
            return result;
        }
    }, {
        key: "Header",
        get: function get() {
            return this._header;
        }
    }, {
        key: "Verticies",
        get: function get() {
            return this._verticies;
        }
    }, {
        key: "Surfaces",
        get: function get() {
            return this._surfaces;
        }
    }, {
        key: "Materials",
        get: function get() {
            return this._materials;
        }
    }, {
        key: "Textures",
        get: function get() {
            return this._textures;
        }
    }, {
        key: "Bones",
        get: function get() {
            return this._bones;
        }
    }, {
        key: "Morphs",
        get: function get() {
            return this._morphs;
        }
    }]);

    return PMXData;
}();

exports.default = PMXData;

},{"../Core/Resources/ImageLoader":119}],303:[function(require,module,exports){
module.exports = "//Fetch bone transform matrix from specified texture and index.\nmat4 boneMatrixFromTexture(sampler2D boneMatTexture,float boneCount,float index)\n{\n  float y =index / boneCount+1./boneCount/2.;\n  return mat4(\n  texture2D(boneMatTexture,vec2(0.125,y)),\n  texture2D(boneMatTexture,vec2(0.375,y)),\n  texture2D(boneMatTexture,vec2(0.625,y)),\n  texture2D(boneMatTexture,vec2(0.875,y)));\n}\n//Compute transform matrix from specified bone skinning configuration\nmat4 calcBoneTransform(sampler2D boneMatTexture,float boneCount,vec4 boneWeights,vec4 boneIndicies)\n{\n  return boneWeights.x*boneMatrixFromTexture(boneMatTexture,boneCount,boneIndicies.x)\n        +boneWeights.y*boneMatrixFromTexture(boneMatTexture,boneCount,boneIndicies.y)\n        +boneWeights.z*boneMatrixFromTexture(boneMatTexture,boneCount,boneIndicies.z)\n        +boneWeights.w*boneMatrixFromTexture(boneMatTexture,boneCount,boneIndicies.w);\n}\n//Compute skinned position\nvec4 calcPosition(mat4 boneTransform,mat4 matPV,vec3 position)\n{\n  return matPV * boneTransform * vec4(position,1.0);\n}\n//Compute skinned normal\nvec3 calcNormal(mat4 boneTransform,mat4 matV,vec3 normal)\n{\n  return normalize((matV*boneTransform*vec4(normal,0)).xyz);\n}\n//Compute skinned spherical normal\nvec2 calcSphereUV(vec3 viewSpaceNormal)\n{\n  return viewSpaceNormal.xy/2.+vec2(0.5,0.5);\n}\n"
},{}],304:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GomlTreeNodeBase2 = require("../../Goml/GomlTreeNodeBase");

var _GomlTreeNodeBase3 = _interopRequireDefault(_GomlTreeNodeBase2);

var _VMDData = require("../Parser/VMDData");

var _VMDData2 = _interopRequireDefault(_VMDData);

var _Vector = require("../../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _Quaternion = require("../../Math/Quaternion");

var _Quaternion2 = _interopRequireDefault(_Quaternion);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VMDNode = function (_GomlTreeNodeBase) {
    _inherits(VMDNode, _GomlTreeNodeBase);

    function VMDNode() {
        _classCallCheck(this, VMDNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(VMDNode).call(this));

        _this._autoSpeed = 0;
        _this._lastTime = null;
        _this._frame = 0;
        _this.attributes.defineAttribute({
            "src": {
                value: "",
                converter: "string",
                onchanged: _this._onSrcAttrChanged
            },
            "frame": {
                value: 0,
                converter: "float",
                onchanged: _this._onFrameAttrChanged
            },
            "enabled": {
                value: false,
                converter: "boolean",
                onchanged: function onchanged(attr) {
                    _this._enabled = attr.Value;
                    attr.done();
                }
            },
            "autoSpeed": {
                value: "0",
                converter: "float",
                onchanged: function onchanged(attr) {
                    _this._autoSpeed = attr.Value;
                    attr.done();
                }
            }
        });
        return _this;
    }

    _createClass(VMDNode, [{
        key: "__onMount",
        value: function __onMount() {
            var _this2 = this;

            _get(Object.getPrototypeOf(VMDNode.prototype), "__onMount", this).call(this);
            this._targetPMX = this.__parent;
            this._targetPMX.on("loaded", function () {
                _this2.attributes.getAttribute("frame").notifyValueChanged();
            });
        }
    }, {
        key: "update",
        value: function update() {
            if (this._enabled && this._autoSpeed !== 0) {
                var timer = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.Timer);
                if (this._lastTime === null) {
                    this._lastTime = timer.time;
                    return;
                } else {
                    var dt = timer.time - this._lastTime;
                    this._lastTime = timer.time;
                    this.attributes.setValue("frame", this._frame + dt / 1000 * 30 * this._autoSpeed);
                }
            }
        }
    }, {
        key: "_onSrcAttrChanged",
        value: function _onSrcAttrChanged(attr) {
            var _this3 = this;

            if (!attr.Value || attr.Value === this._lastURL) {
                attr.done();
                return;
            }
            if (this._vmdLoadingDeferred) {
                this._vmdLoadingDeferred.resolve(null);
                attr.done();
            }
            this._vmdLoadingDeferred = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceLoader).getResourceLoadingDeffered();
            _VMDData2.default.loadFromUrl(attr.Value).then(function (data) {
                _this3._lastURL = attr.Value;
                _this3._targetVMD = data;
                _this3._vmdLoadingDeferred.resolve(null);
                _this3.attributes.getAttribute("frame").notifyValueChanged();
                attr.done();
            });
        }
    }, {
        key: "_onFrameAttrChanged",
        value: function _onFrameAttrChanged(attr) {
            this._frame = Math.max(0, attr.Value);
            if (!this.attributes.getValue("enabled")) {
                attr.done();
                return;
            }
            if (this._targetPMX.PMXModelReady && this._targetVMD) {
                for (var boneName in this._targetVMD.Motions) {
                    var bone = undefined;
                    if (bone = this._targetPMX.PMXModel.skeleton.getBoneByName(boneName)) {
                        var current = this._targetVMD.getBoneFrame(this._frame, boneName);
                        bone.Transformer.userTranslation = new _Vector2.default(current.position);
                        bone.Transformer.userRotation = new _Quaternion2.default(current.rotation);
                    }
                }
                this._targetPMX.PMXModel.skeleton.updateBoneTransforms();
                for (var morphName in this._targetVMD.Morphs) {
                    var morph = undefined;
                    if (morph = this._targetPMX.PMXModel.MorphManager.getMorphByName(morphName)) {
                        var morphCurrent = this._targetVMD.getMorphFrame(this._frame, morphName);
                        if (morph) {
                            morph.Progress = morphCurrent.value;
                        }
                    }
                }
                attr.done();
            } else {
                attr.done();
            }
        }
    }]);

    return VMDNode;
}(_GomlTreeNodeBase3.default);

exports.default = VMDNode;

},{"../../ContextComponents":8,"../../Goml/GomlTreeNodeBase":183,"../../JThreeContext":267,"../../Math/Quaternion":275,"../../Math/Vector3":278,"../Parser/VMDData":306}],305:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BezierCurve = function () {
    function BezierCurve(v1x, v1y, v2x, v2y) {
        _classCallCheck(this, BezierCurve);

        this._v1x = v1x;
        this._v1y = v1y;
        this._v2x = v2x;
        this._v2y = v2y;
    }

    _createClass(BezierCurve, [{
        key: "evaluate",
        value: function evaluate(progress) {
            // Newton method
            var t = this._clamp(progress, 0, 1);
            var dt = undefined;
            do {
                dt = -(this._fx(t) - progress) / this._dfxdt(t);
                if (isNaN(dt)) {
                    break;
                }
                t += this._clamp(dt, -1, 1);
            } while (Math.abs(dt) > BezierCurve._epsilon);
            return this._clamp(this._fy(t), 0, 1);
        }
    }, {
        key: "_fy",
        value: function _fy(t) {
            // _fy(t)=(1-t)^3*0+3*(1-t)^2*t*v1.y+3*(1-t)*t^2*v2.y+t^3*1
            return 3 * (1 - t) * (1 - t) * t * this._v1y + 3 * (1 - t) * t * t * this._v2y + t * t * t;
        }
    }, {
        key: "_fx",
        value: function _fx(t) {
            // fx(t)=(1-t)^3*0+3*(1-t)^2*t*v1.x+3*(1-t)*t^2*v2.x+t^3*1
            return 3 * (1 - t) * (1 - t) * t * this._v1x + 3 * (1 - t) * t * t * this._v2x + t * t * t;
        }
    }, {
        key: "_dfxdt",
        value: function _dfxdt(t) {
            // dfx(t)/dt=-6(1-t)*t*v1.x+3(1-t)^2*v1.x-3t^2*v2.x+6(1-t)*t*v2.x+3t^2
            return -6 * (1 - t) * t * this._v1x + 3 * (1 - t) * (1 - t) * this._v1x - 3 * t * t * this._v2x + 6 * (1 - t) * t * this._v2x + 3 * t * t;
        }
    }, {
        key: "_clamp",
        value: function _clamp(p, min, max) {
            return Math.max(min, Math.min(p, max));
        }
    }]);

    return BezierCurve;
}();

BezierCurve._epsilon = 1.0E-3;
exports.default = BezierCurve;

},{}],306:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ResourceResolver = require("../../Core/Resources/ResourceResolver");

var _ResourceResolver2 = _interopRequireDefault(_ResourceResolver);

var _glMatrix = require("gl-matrix");

var _BezierCurve = require("./BezierCurve");

var _BezierCurve2 = _interopRequireDefault(_BezierCurve);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VMDData = function () {
    function VMDData(data) {
        _classCallCheck(this, VMDData);

        this._offset = 0;
        this._reader = new DataView(data, 0, data.byteLength);
        this._loadHeader();
        this._loadMotion();
        this._loadMorph();
    }

    _createClass(VMDData, [{
        key: "getBoneFrame",
        value: function getBoneFrame(frame, boneName) {
            var frames = this._motions[boneName];
            if (typeof frames === "undefined") {
                return null;
            } else {
                var index = this._binaryframeSearch(frames, frame);
                if (index + 1 < frames.length) {
                    var nextFrame = frames[index + 1];
                    var currentFrame = frames[index];
                    var progress = (frame - currentFrame.frameNumber) / (nextFrame.frameNumber - currentFrame.frameNumber);
                    return {
                        frameNumber: frame,
                        position: this._complementBoneTranslation(currentFrame.position, nextFrame.position, progress, currentFrame.interpolation),
                        rotation: _glMatrix.quat.slerp([0, 0, 0, 0], currentFrame.rotation, nextFrame.rotation, currentFrame.interpolation[3].evaluate(progress))
                    };
                } else {
                    return {
                        frameNumber: frame,
                        position: frames[index].position,
                        rotation: frames[index].rotation
                    };
                }
            }
        }
    }, {
        key: "getMorphFrame",
        value: function getMorphFrame(frame, morphName) {
            var frames = this._morphs[morphName];
            if (typeof frames === "undefined") {
                return null;
            } else {
                var index = this._binaryframeSearch(frames, frame);
                if (index + 1 < frames.length) {
                    var nextFrame = frames[index + 1];
                    var currentFrame = frames[index];
                    var progress = (frame - currentFrame.frameNumber) / (nextFrame.frameNumber - currentFrame.frameNumber);
                    return {
                        frameNumber: frame,
                        value: currentFrame.morphValue + (nextFrame.morphValue - currentFrame.morphValue) * progress
                    };
                } else {
                    return {
                        frameNumber: frame,
                        value: frames[index].morphValue
                    };
                }
            }
        }
    }, {
        key: "_loadHeader",
        value: function _loadHeader() {
            this._header = {
                header: this._loadString(30),
                modelName: this._loadString(20)
            };
        }
    }, {
        key: "_loadMotion",
        value: function _loadMotion() {
            this._motions = {};
            var frameCount = this._readUint32();
            for (var i = 0; i < frameCount; i++) {
                var frameName = this._loadString(15);
                var data = {
                    frameNumber: this._readUint32(),
                    position: [this._readFloat32(), this._readFloat32(), -this._readFloat32()],
                    rotation: [-this._readFloat32(), -this._readFloat32(), this._readFloat32(), this._readFloat32()],
                    interpolation: this._loadInterpolation()
                };
                if (typeof this._motions[frameName] === "undefined") {
                    this._motions[frameName] = [];
                }
                this._motions[frameName].push(data);
            }
            for (var motion in this._motions) {
                this._motions[motion].sort(function (i1, i2) {
                    return i1.frameNumber - i2.frameNumber;
                });
            }
        }
    }, {
        key: "_loadMorph",
        value: function _loadMorph() {
            this._morphs = {};
            var frameCount = this._readUint32();
            for (var i = 0; i < frameCount; i++) {
                var frameName = this._loadString(15);
                var data = {
                    frameNumber: this._readUint32(),
                    morphValue: this._readFloat32()
                };
                if (typeof this._morphs[frameName] === "undefined") {
                    this._morphs[frameName] = [];
                }
                this._morphs[frameName].push(data);
            }
            for (var morph in this._morphs) {
                this._morphs[morph].sort(function (i1, i2) {
                    return i1.frameNumber - i2.frameNumber;
                });
            }
        }
    }, {
        key: "_loadBytes",
        value: function _loadBytes(byteLength) {
            var isPadding = false;
            var arr = [];
            for (var i = 0; i < byteLength; i++) {
                var current = this._readUint8();
                if (current === 0x00) {
                    isPadding = true;
                }
                if (!isPadding) {
                    arr.push(current);
                }
            }
            return new Uint8Array(arr);
        }
    }, {
        key: "_loadString",
        value: function _loadString(length) {
            var decoder = new TextDecoder("shift-jis");
            return decoder.decode(this._loadBytes(length));
        }
    }, {
        key: "_loadInterpolation",
        value: function _loadInterpolation() {
            var interpolation = new Array(4);
            for (var i = 0; i < 4; i++) {
                interpolation[i] = new Array(4);
                for (var j = 0; j < 4; j++) {
                    interpolation[i][j] = new Array(4);
                }
            }
            for (var _i = 0; _i < 4; _i++) {
                for (var _j = 0; _j < 4; _j++) {
                    for (var k = 0; k < 4; k++) {
                        interpolation[_i][_j][k] = this._readUint8();
                    }
                }
            }
            var result = new Array(4);
            for (var _i2 = 0; _i2 < 4; _i2++) {
                result[_i2] = new _BezierCurve2.default(interpolation[0][0][_i2] / 128.0, interpolation[0][1][_i2] / 128.0, interpolation[0][2][_i2] / 128.0, interpolation[0][3][_i2] / 128);
            }
            return result;
        }
    }, {
        key: "_binaryframeSearch",
        value: function _binaryframeSearch(source, frame) {
            var minIndex = 0;
            var maxIndex = source.length - 1;
            var currentIndex = -1;
            var currentElement = undefined;
            if (source.length === 1) {
                return 0;
            }
            while (minIndex <= maxIndex) {
                currentIndex = (minIndex + maxIndex) / 2 | 0;
                currentElement = source[currentIndex];
                if (currentElement.frameNumber < frame) {
                    if (currentIndex + 1 < source.length && source[currentIndex + 1].frameNumber > frame) {
                        return currentIndex;
                    }
                    minIndex = currentIndex + 1;
                } else if (currentElement.frameNumber > frame) {
                    maxIndex = currentIndex - 1;
                    if (currentIndex - 1 >= 0 && source[currentIndex - 1].frameNumber < frame) {
                        return currentIndex - 1;
                    }
                } else {
                    return currentIndex;
                }
            }
            return currentIndex;
        }
    }, {
        key: "_complementBoneTranslation",
        value: function _complementBoneTranslation(begin, end, progress, bezierCurves) {
            var result = [0, 0, 0]; // TODO optimize this
            for (var i = 0; i < 3; i++) {
                result[i] = begin[i] + (end[i] - begin[i]) * bezierCurves[i].evaluate(progress);
            }
            return result;
        }
    }, {
        key: "_readUint8",
        value: function _readUint8() {
            var result = this._reader.getUint8(this._offset);
            this._offset += 1;
            return result;
        }
    }, {
        key: "_readUint32",
        value: function _readUint32() {
            var result = this._reader.getUint32(this._offset, true);
            this._offset += 4;
            return result;
        }
    }, {
        key: "_readFloat32",
        value: function _readFloat32() {
            var result = this._reader.getFloat32(this._offset, true);
            this._offset += 4;
            return result;
        }
    }, {
        key: "Motions",
        get: function get() {
            return this._motions;
        }
    }, {
        key: "Morphs",
        get: function get() {
            return this._morphs;
        }
    }], [{
        key: "loadFromUrl",
        value: function loadFromUrl(url) {
            return VMDData._cacheResolver.fetch(url, function (path) {
                var d = _q2.default.defer();
                var oReq = new XMLHttpRequest();
                oReq.open("GET", path, true);
                oReq.setRequestHeader("Accept", "*/*");
                oReq.responseType = "arraybuffer";
                oReq.onload = function () {
                    var data = new VMDData(oReq.response);
                    d.resolve(data);
                };
                oReq.onerror = function (err) {
                    d.reject(err);
                };
                oReq.send(null);
                return d.promise;
            });
        }
    }]);

    return VMDData;
}();

VMDData._cacheResolver = new _ResourceResolver2.default();
exports.default = VMDData;

},{"../../Core/Resources/ResourceResolver":125,"./BezierCurve":305,"gl-matrix":320,"q":338}],307:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _BasicGeometry2 = require("../../Core/Geometries/Base/BasicGeometry");

var _BasicGeometry3 = _interopRequireDefault(_BasicGeometry2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var XGeometry = function (_BasicGeometry) {
    _inherits(XGeometry, _BasicGeometry);

    function XGeometry(x) {
        _classCallCheck(this, XGeometry);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(XGeometry).call(this));

        var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        _this.indexBuffer = rm.createBuffer(name + "-index", WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 1, WebGLRenderingContext.UNSIGNED_INT);
        _this.positionBuffer = rm.createBuffer(name + "-pos", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.normalBuffer = rm.createBuffer(name + "-nor", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 3, WebGLRenderingContext.FLOAT);
        _this.uvBuffer = rm.createBuffer(name + "-uv", WebGLRenderingContext.ARRAY_BUFFER, WebGLRenderingContext.STATIC_DRAW, 2, WebGLRenderingContext.FLOAT);
        _this.__updateBuffers(x);
        return _this;
    }
    /**
     * apply pmx geometries to buffer.
     */


    _createClass(XGeometry, [{
        key: "__updateBuffers",
        value: function __updateBuffers(x) {
            this.indexBuffer.update(x.indicies, x.indicies.length);
            this.normalBuffer.update(x.normals, x.normals.length);
            this.uvBuffer.update(x.texCoords, x.texCoords.length);
            this.positionBuffer.update(x.positions, x.texCoords.length);
        }
    }]);

    return XGeometry;
}(_BasicGeometry3.default);

exports.default = XGeometry;

},{"../../ContextComponents":8,"../../Core/Geometries/Base/BasicGeometry":21,"../../JThreeContext":267}],308:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextComponents = require("../../ContextComponents");

var _ContextComponents2 = _interopRequireDefault(_ContextComponents);

var _JThreeContext = require("../../JThreeContext");

var _JThreeContext2 = _interopRequireDefault(_JThreeContext);

var _BasicMaterial2 = require("../../Core/Materials/BasicMaterial");

var _BasicMaterial3 = _interopRequireDefault(_BasicMaterial2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var XMaterial = function (_BasicMaterial) {
    _inherits(XMaterial, _BasicMaterial);

    function XMaterial(_material) {
        _classCallCheck(this, XMaterial);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(XMaterial).call(this, require("../Material/Forward.xmml"), "x.forward"));

        _this._material = _material;
        _this.shaderVariables = {
            faceColor: _this._material.faceColor,
            power: _this._material.power,
            specularColor: _this._material.specularColor,
            emissiveColor: _this._material.emissiveColor
        };
        var rm = _JThreeContext2.default.getContextComponent(_ContextComponents2.default.ResourceManager);
        if (_material.texture) {
            rm.loadTexture(_material.texture).then(function (texture) {
                texture.MagFilter = WebGLRenderingContext.LINEAR;
                _this.shaderVariables["texture"] = texture;
            });
        }
        return _this;
    }

    _createClass(XMaterial, [{
        key: "getDrawGeometryLength",
        value: function getDrawGeometryLength(geo) {
            return this._material.faceColor.W > 0 ? this._material.indexCount : 0;
        }
    }, {
        key: "getDrawGeometryOffset",
        value: function getDrawGeometryOffset(geo) {
            return this._material.indexOffset * 4;
        }
    }]);

    return XMaterial;
}(_BasicMaterial3.default);

exports.default = XMaterial;

},{"../../ContextComponents":8,"../../Core/Materials/BasicMaterial":36,"../../JThreeContext":267,"../Material/Forward.xmml":312}],309:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _HitAreaMaterial = require("../../Core/Materials/Buffering/HitAreaMaterial");

var _HitAreaMaterial2 = _interopRequireDefault(_HitAreaMaterial);

var _XPrimaryBufferMaterial = require("./XPrimaryBufferMaterial");

var _XPrimaryBufferMaterial2 = _interopRequireDefault(_XPrimaryBufferMaterial);

var _XMaterial = require("./XMaterial");

var _XMaterial2 = _interopRequireDefault(_XMaterial);

var _XGeometry = require("./XGeometry");

var _XGeometry2 = _interopRequireDefault(_XGeometry);

var _XFileData = require("../XFileData");

var _XFileData2 = _interopRequireDefault(_XFileData);

var _SceneObject2 = require("../../Core/SceneObjects/SceneObject");

var _SceneObject3 = _interopRequireDefault(_SceneObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var XModel = function (_SceneObject) {
    _inherits(XModel, _SceneObject);

    function XModel(modelData) {
        _classCallCheck(this, XModel);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(XModel).call(this));

        _this._modelData = modelData;
        _this.Geometry = new _XGeometry2.default(modelData);
        _this._modelData.materials.forEach(function (material) {
            _this.addMaterial(new _XMaterial2.default(material));
            _this.addMaterial(new _HitAreaMaterial2.default());
            _this.addMaterial(new _XPrimaryBufferMaterial2.default(material));
        });
        return _this;
    }

    _createClass(XModel, null, [{
        key: "fromUrl",
        value: function fromUrl(src) {
            return _XFileData2.default.loadFile(src).then(function (data) {
                return new XModel(data);
            });
        }
    }]);

    return XModel;
}(_SceneObject3.default);

exports.default = XModel;

},{"../../Core/Materials/Buffering/HitAreaMaterial":37,"../../Core/SceneObjects/SceneObject":151,"../XFileData":314,"./XGeometry":307,"./XMaterial":308,"./XPrimaryBufferMaterial":310}],310:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BasicMaterial2 = require("../../Core/Materials/BasicMaterial");

var _BasicMaterial3 = _interopRequireDefault(_BasicMaterial2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var XPrimaryMaterial = function (_BasicMaterial) {
    _inherits(XPrimaryMaterial, _BasicMaterial);

    function XPrimaryMaterial(_material) {
        _classCallCheck(this, XPrimaryMaterial);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(XPrimaryMaterial).call(this, require("../Material/Primary.xmml"), "x.gbuffer.1"));

        _this._material = _material;
        _this.shaderVariables = {
            power: _material.power
        };
        return _this;
    }

    _createClass(XPrimaryMaterial, [{
        key: "getDrawGeometryLength",
        value: function getDrawGeometryLength(geo) {
            return this._material.faceColor.W > 0 ? this._material.indexCount : 0;
        }
    }, {
        key: "getDrawGeometryOffset",
        value: function getDrawGeometryOffset(geo) {
            return this._material.indexOffset * 4;
        }
    }]);

    return XPrimaryMaterial;
}(_BasicMaterial3.default);

exports.default = XPrimaryMaterial;

},{"../../Core/Materials/BasicMaterial":36,"../Material/Primary.xmml":313}],311:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _XModel = require("../Core/XModel");

var _XModel2 = _interopRequireDefault(_XModel);

var _SceneObjectNodeBase2 = require("./../../Goml/Nodes/SceneObjects/SceneObjectNodeBase");

var _SceneObjectNodeBase3 = _interopRequireDefault(_SceneObjectNodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var XNode = function (_SceneObjectNodeBase) {
    _inherits(XNode, _SceneObjectNodeBase);

    function XNode() {
        _classCallCheck(this, XNode);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(XNode).call(this));

        _this.attributes.defineAttribute({
            "src": {
                converter: "string",
                value: undefined,
                constant: true
            }
        });
        return _this;
    }

    _createClass(XNode, [{
        key: "__onMount",
        value: function __onMount() {
            var _this2 = this;

            _get(Object.getPrototypeOf(XNode.prototype), "__onMount", this).call(this);
            _XModel2.default.fromUrl(this.attributes.getValue("src")).then(function (m) {
                _this2.TargetSceneObject = m;
            });
        }
    }]);

    return XNode;
}(_SceneObjectNodeBase3.default);

exports.default = XNode;

},{"../Core/XModel":309,"./../../Goml/Nodes/SceneObjects/SceneObjectNodeBase":213}],312:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<material name=\"jthree.x.basic\" group=\"builtin.forward\" order=\"300\">\n<registers>\n  <register name=\"builtin.basic\"/>\n  <register name=\"builtin.buffer\"/>\n</registers>\n<passes>\n  <pass>\n    <glsl>\n      <![CDATA[\n      attribute vec3 position;\n      attribute vec3 normal;\n      attribute vec2 uv;\n\n      @vert {\n      @import \"jthree.builtin.vertex\"\n        uniform mat4 _matPVM;\n        uniform mat4 _matVM;\n      }\n\n      varying vec3 vNormal;\n      varying vec2 vUv;\n      varying vec4 vPosition;\n\n      vec2 calcLightUV(vec4 projectionSpacePos)\n      {\n         return (projectionSpacePos.xy/projectionSpacePos.w+vec2(1,1))/2.;\n      }\n\n      @vert{\n        void main(void)\n        {\n          BasicVertexTransformOutput o =  basicVertexTransform(position,normal,uv,_matPVM,_matVM);\n          gl_Position = vPosition = o.position;\n          vNormal = o.normal;\n          vUv = o.uv;\n        }\n      }\n\n      @frag{\n        @{register:1,type:\"buffer\",name:\"DLIGHT\"}\n        uniform sampler2D _dlBuffer;\n        @{register:2,type:\"buffer\",name:\"SLIGHT\"}\n        uniform sampler2D _slBuffer;\n        uniform vec4 faceColor;\n        @{register:3,flag:\"_textureUsed\"}\n        uniform sampler2D texture;\n        uniform int _textureUsed;\n        uniform vec3 emissiveColor;\n        uniform vec3 specularColor;\n        void main(void)\n        {\n          vec2 lUV = vPosition.xy/vPosition.w /2.0 + vec2(.5);\n          gl_FragColor=faceColor;\n          if(_textureUsed == 1){\n            gl_FragColor = texture2D(texture,vUv);\n          }\n          gl_FragColor.rgb *= (texture2D(_dlBuffer,lUV).rgb + emissiveColor);\n          gl_FragColor.rgb *= texture2D(_slBuffer,lUV).rgb * specularColor;\n          ////calculate light uv\n        }\n      }\n      ]]>\n    </glsl>\n  </pass>\n</passes>\n</material>\n"
},{}],313:[function(require,module,exports){
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<material name=\"jthree.gbuffer.x.1\" group=\"jthree.basic.gbuffer.1\" order=\"300\">\n<registers>\n  <register name=\"builtin.basic\"/>\n</registers>\n<passes>\n  <pass>\n    <blend enabled=\"true\" src=\"1\" dst=\"0\"/>\n    <glsl>\n      <![CDATA[\n      attribute vec4 position;\n      attribute vec3 normal;\n      varying vec3 vNormal;\n\n      @vert{\n        uniform mat4 _matVM;\n        uniform mat4 _matPVM;\n\n        void main(void)\n        {\n        \tgl_Position =_matPVM * position;\n        \tvNormal =normalize(( _matVM * vec4(normal,0)).xyz);\n        }\n      }\n\n      @frag{\n        @import \"builtin.packing\"\n        @import \"builtin.gbuffer-packing\"\n\n        vec2 compressNormal()\n        {\n        \tfloat p = sqrt(vNormal.z * 8. + 8.);\n        \treturn vNormal.xy/p + 0.5;\n        }\n\n        vec4 packedNormal()\n        {\n          vec2 cNor = compressNormal();\n          return vec4(packRanged16(cNor.x,CNOR_MIN,CNOR_MAX),packRanged16(cNor.y,CNOR_MIN,CNOR_MAX));\n        }\n\n        void main(void)\n        {\n        \tgl_FragColor = packedNormal();\n        }\n      }\n\n      ]]>\n    </glsl>\n  </pass>\n</passes>\n</material>\n"
},{}],314:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ImageLoader = require("../Core/Resources/ImageLoader");

var _ImageLoader2 = _interopRequireDefault(_ImageLoader);

var _Vector = require("../Math/Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _Vector3 = require("../Math/Vector4");

var _Vector4 = _interopRequireDefault(_Vector3);

var _ResourceResolver = require("../Core/Resources/ResourceResolver");

var _ResourceResolver2 = _interopRequireDefault(_ResourceResolver);

var _q = require("q");

var _q2 = _interopRequireDefault(_q);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var XFileData = function () {
    function XFileData(dataSource, directory) {
        _classCallCheck(this, XFileData);

        this.materials = [];
        this._dataSource = dataSource;
        this._directory = directory;
        var meshSection = this._sliceSection(dataSource, "Mesh", 0);
        var meshMaterialSection = this._sliceSection(meshSection, "MeshMaterialList", 0);
        this._parsePositions(meshSection);
        this._parseTexCoords(this._sliceSection(meshSection, "MeshTextureCoords", 0));
        this._parseMaterials(meshMaterialSection);
        this._parseFaces(meshSection, meshMaterialSection);
        this._generateNormals();
        this._prepareForUsing();
    }

    _createClass(XFileData, [{
        key: "_sliceSection",
        value: function _sliceSection(source, sectionName, offset) {
            var regex = new RegExp("([^{template}]\\s+)" + sectionName + "\\s*\\{", "g");
            var found = regex.exec(source);
            for (var i = 0; i < offset; i++) {
                found = regex.exec(source);
            }
            if (!found) {
                return undefined;
            }
            var bracketCount = 0;
            var index = found.index;
            while (true) {
                var nextEndBlacket = source.indexOf("}", index);
                var nextBeginBlacket = source.indexOf("{", index);
                if (nextEndBlacket < 0 && nextBeginBlacket < 0) {
                    throw new Error("Unmatch blacket!!");
                }
                if (nextBeginBlacket < 0) {
                    // This means this blacket is end of this section
                    index = nextEndBlacket + 1;
                    break;
                } else if (nextBeginBlacket < nextEndBlacket) {
                    index = nextBeginBlacket + 1;
                    bracketCount++;
                } else {
                    index = nextEndBlacket + 1;
                    bracketCount--;
                }
                if (bracketCount === 0) {
                    break;
                }
            }
            return source.substring(found.index + found[1].length, index);
        }
    }, {
        key: "_parsePositions",
        value: function _parsePositions(meshSection) {
            var positionRegex = /([-\.\d]+);\s*([-\.\d]+);\s*([-\.\d]+);\s*/g;
            var regexResult = undefined;
            var positionCache = [];
            while (regexResult = positionRegex.exec(meshSection)) {
                positionCache.push(parseFloat(regexResult[1]), parseFloat(regexResult[2]), parseFloat(regexResult[3]));
            }
            this.positions = new Float32Array(positionCache);
        }
    }, {
        key: "_parseFaces",
        value: function _parseFaces(meshSection, meshMaterialListSection) {
            var faceRegex = /[34];(\d+),(\d+),(\d+)(?:,(\d+))?;/g;
            var faceRegexResult = undefined;
            var faceCache = [];
            var materialIndexRegex = /(\d+)/g;
            var materialGroupCount = parseInt(materialIndexRegex.exec(meshMaterialListSection)[1], 10);
            var matIndiciesCount = parseInt(materialIndexRegex.exec(meshMaterialListSection)[1], 10);
            for (var i = 0; i < materialGroupCount; i++) {
                faceCache[i] = [];
            }
            for (var _i = 0; _i < matIndiciesCount; _i++) {
                faceRegexResult = faceRegex.exec(meshSection);
                var materialIndex = parseInt(materialIndexRegex.exec(meshMaterialListSection)[1], 10);
                if (faceRegexResult[4]) {
                    var f1 = parseInt(faceRegexResult[1], 10),
                        f2 = parseInt(faceRegexResult[2], 10),
                        f3 = parseInt(faceRegexResult[3], 10),
                        f4 = parseInt(faceRegexResult[4], 10);
                    faceCache[materialIndex].push(f1, f2, f4, f2, f3, f4);
                } else {
                    faceCache[materialIndex].push(parseInt(faceRegexResult[1], 10), parseInt(faceRegexResult[2], 10), parseInt(faceRegexResult[3], 10));
                }
            }
            // Reduce unused materials
            for (var _i2 = 0; _i2 < faceCache.length; _i2++) {
                if (faceCache[_i2].length === 0) {
                    faceCache.splice(_i2, 1);
                    this.materials.splice(_i2, 1);
                    _i2--;
                }
            }
            // Set face count for materials
            var offset = 0;
            for (var _i3 = 0; _i3 < faceCache.length; _i3++) {
                this.materials[_i3].indexOffset = offset;
                offset += this.materials[_i3].indexCount = faceCache[_i3].length;
            }
            // Concat face Array
            var concattedFaceArray = [];
            for (var _i4 = 0; _i4 < faceCache.length; _i4++) {
                concattedFaceArray = concattedFaceArray.concat(faceCache[_i4]);
            }
            this.indicies = new Uint32Array(concattedFaceArray);
        }
    }, {
        key: "_parseMaterials",
        value: function _parseMaterials(meshMaterialSection) {
            var materialSection = undefined;
            var materialIndex = 0;
            while (materialSection = this._sliceSection(meshMaterialSection, "Material", materialIndex)) {
                var numberRegex = /([-\.\d]+);/;
                var foundNumbers = new Array(11);
                for (var i = 0; i < 11; i++) {
                    var regexResult = numberRegex.exec(materialSection);
                    foundNumbers[i] = parseFloat(regexResult[1]);
                }
                var textureSection = this._sliceSection(materialSection, "TextureFilename", 0);
                var texturePath = undefined;
                if (textureSection) {
                    texturePath = /"([^"]+)"/.exec(textureSection)[1].replace(/\\/g, "/");
                    texturePath = texturePath.replace(".tga", ".tga.png");
                }
                this.materials[materialIndex] = {
                    faceColor: new _Vector4.default(foundNumbers[0], foundNumbers[1], foundNumbers[2], foundNumbers[3]),
                    power: foundNumbers[4],
                    specularColor: new _Vector2.default(foundNumbers[5], foundNumbers[6], foundNumbers[7]),
                    emissiveColor: new _Vector2.default(foundNumbers[8], foundNumbers[9], foundNumbers[10]),
                    texture: texturePath ? this._directory + texturePath : undefined,
                    indexCount: undefined,
                    indexOffset: undefined
                };
                materialIndex++;
            }
        }
    }, {
        key: "_parseTexCoords",
        value: function _parseTexCoords(meshTextureSection) {
            var texCoordRegex = /([-\.\d]+);([-\.\d]+);/g;
            var regexResult = undefined;
            var texCoordCache = [];
            while (regexResult = texCoordRegex.exec(meshTextureSection)) {
                texCoordCache.push(parseFloat(regexResult[1]), parseFloat(regexResult[2]));
            }
            this.texCoords = new Float32Array(texCoordCache);
        }
    }, {
        key: "_prepareForUsing",
        value: function _prepareForUsing() {
            // Load textures
            for (var i = 0; i < this.materials.length; i++) {
                if (this.materials[i].texture) {
                    _ImageLoader2.default.loadImage(this.materials[i].texture);
                }
            }
        }
    }, {
        key: "_generateNormals",
        value: function _generateNormals() {
            var normalCache = [];
            for (var i = 0; i < this.indicies.length; i += 3) {
                var f1i = this.indicies[i];
                var f2i = this.indicies[i + 1];
                var f3i = this.indicies[i + 2];
                var normal = this._generateNormal(f1i, f2i, f3i);
                normalCache[3 * f1i] = normalCache[3 * f2i] = normalCache[3 * f3i] = normal[0];
                normalCache[3 * f1i + 1] = normalCache[3 * f2i + 1] = normalCache[3 * f3i + 1] = normal[1];
                normalCache[3 * f1i + 2] = normalCache[3 * f2i + 2] = normalCache[3 * f3i + 2] = normal[2];
            }
            this.normals = new Float32Array(normalCache);
        }
    }, {
        key: "_generateNormal",
        value: function _generateNormal(p1Index, p2Index, p3Index) {
            var p1x = this.positions[3 * p1Index];
            var p1y = this.positions[3 * p1Index + 1];
            var p1z = this.positions[3 * p1Index + 2];
            var p2x = this.positions[3 * p2Index];
            var p2y = this.positions[3 * p2Index + 1];
            var p2z = this.positions[3 * p2Index + 2];
            var p3x = this.positions[3 * p3Index];
            var p3y = this.positions[3 * p3Index + 1];
            var p3z = this.positions[3 * p3Index + 2];
            var ret = [(p2y - p1y) * (p3z - p1z) - (p2z - p1z) * (p3y - p1y), (p2z - p1z) * (p3x - p1x) - (p2x - p1x) * (p3z - p1z), (p2x - p1x) * (p3y - p1y) - (p2y - p1y) * (p3x - p1x)];
            var length = Math.sqrt(ret[0] * ret[0] + ret[1] * ret[1] + ret[2] * ret[2]);
            ret[0] /= length;
            ret[1] /= length;
            ret[2] /= length;
            return ret;
        }
    }], [{
        key: "loadFile",
        value: function loadFile(src) {
            var directory = src.substr(0, src.lastIndexOf("/") + 1);
            return this._loader.fetch(src, function (absPath) {
                var deferred = _q2.default.defer();
                var xhr = new XMLHttpRequest();
                xhr.open("GET", absPath, true);
                xhr.setRequestHeader("Accept", "text");
                xhr.onload = function () {
                    deferred.resolve(new XFileData(xhr.responseText, directory));
                };
                xhr.onerror = function (err) {
                    deferred.reject(err);
                };
                xhr.send(null);
                return deferred.promise;
            });
        }
    }]);

    return XFileData;
}();

XFileData._loader = new _ResourceResolver2.default();
exports.default = XFileData;

},{"../Core/Resources/ImageLoader":119,"../Core/Resources/ResourceResolver":125,"../Math/Vector3":278,"../Math/Vector4":279,"q":338}],315:[function(require,module,exports){
"use strict";

var _Init = require("./Init");

var _Init2 = _interopRequireDefault(_Init);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Init2.default.init();

},{"./Init":228}],316:[function(require,module,exports){
module.exports=module.exports = {"aliceblue":"#F0F8FF","antiquewhite":"#FAEBD7","aqua":"#00FFFF","aquamarine":"#7FFFD4","azure":"#F0FFFF","beige":"#F5F5DC","bisque":"#FFE4C4","black":"#000000","blanchedalmond":"#FFEBCD","blue":"#0000FF","blueviolet":"#8A2BE2","brown":"#A52A2A","burlywood":"#DEB887","cadetblue":"#5F9EA0","chartreuse":"#7FFF00","chocolate":"#D2691E","coral":"#FF7F50","cornflowerblue":"#6495ED","cornsilk":"#FFF8DC","crimson":"#DC143C","cyan":"#00FFFF","darkblue":"#00008B","darkcyan":"#008B8B","darkgoldenrod":"#B8860B","darkgray":"#A9A9A9","darkgreen":"#006400","darkgrey":"#A9A9A9","darkkhaki":"#BDB76B","darkmagenta":"#8B008B","darkolivegreen":"#556B2F","darkorange":"#FF8C00","darkorchid":"#9932CC","darkred":"#8B0000","darksalmon":"#E9967A","darkseagreen":"#8FBC8F","darkslateblue":"#483D8B","darkslategray":"#2F4F4F","darkslategrey":"#2F4F4F","darkturquoise":"#00CED1","darkviolet":"#9400D3","deeppink":"#FF1493","deepskyblue":"#00BFFF","dimgray":"#696969","dimgrey":"#696969","dodgerblue":"#1E90FF","firebrick":"#B22222","floralwhite":"#FFFAF0","forestgreen":"#228B22","fuchsia":"#FF00FF","gainsboro":"#DCDCDC","ghostwhite":"#F8F8FF","gold":"#FFD700","goldenrod":"#DAA520","gray":"#808080","green":"#008000","greenyellow":"#ADFF2F","grey":"#808080","honeydew":"#F0FFF0","hotpink":"#FF69B4","indianred":"#CD5C5C","indigo":"#4B0082","ivory":"#FFFFF0","khaki":"#F0E68C","lavender":"#E6E6FA","lavenderblush":"#FFF0F5","lawngreen":"#7CFC00","lemonchiffon":"#FFFACD","lightblue":"#ADD8E6","lightcoral":"#F08080","lightcyan":"#E0FFFF","lightgoldenrodyellow":"#FAFAD2","lightgray":"#D3D3D3","lightgreen":"#90EE90","lightgrey":"#D3D3D3","lightpink":"#FFB6C1","lightsalmon":"#FFA07A","lightseagreen":"#20B2AA","lightskyblue":"#87CEFA","lightslategray":"#778899","lightslategrey":"#778899","lightsteelblue":"#B0C4DE","lightyellow":"#FFFFE0","lime":"#00FF00","limegreen":"#32CD32","linen":"#FAF0E6","magenta":"#FF00FF","maroon":"#800000","mediumaquamarine":"#66CDAA","mediumblue":"#0000CD","mediumorchid":"#BA55D3","mediumpurple":"#9370DB","mediumseagreen":"#3CB371","mediumslateblue":"#7B68EE","mediumspringgreen":"#00FA9A","mediumturquoise":"#48D1CC","mediumvioletred":"#C71585","midnightblue":"#191970","mintcream":"#F5FFFA","mistyrose":"#FFE4E1","moccasin":"#FFE4B5","navajowhite":"#FFDEAD","navy":"#000080","oldlace":"#FDF5E6","olive":"#808000","olivedrab":"#6B8E23","orange":"#FFA500","orangered":"#FF4500","orchid":"#DA70D6","palegoldenrod":"#EEE8AA","palegreen":"#98FB98","paleturquoise":"#AFEEEE","palevioletred":"#DB7093","papayawhip":"#FFEFD5","peachpuff":"#FFDAB9","peru":"#CD853F","pink":"#FFC0CB","plum":"#DDA0DD","powderblue":"#B0E0E6","purple":"#800080","red":"#FF0000","rosybrown":"#BC8F8F","royalblue":"#4169E1","saddlebrown":"#8B4513","salmon":"#FA8072","sandybrown":"#F4A460","seagreen":"#2E8B57","seashell":"#FFF5EE","sienna":"#A0522D","silver":"#C0C0C0","skyblue":"#87CEEB","slateblue":"#6A5ACD","slategray":"#708090","slategrey":"#708090","snow":"#FFFAFA","springgreen":"#00FF7F","steelblue":"#4682B4","tan":"#D2B48C","teal":"#008080","thistle":"#D8BFD8","tomato":"#FF6347","turquoise":"#40E0D0","violet":"#EE82EE","wheat":"#F5DEB3","white":"#FFFFFF","whitesmoke":"#F5F5F5","yellow":"#FFFF00","yellowgreen":"#9ACD32"}
},{}],317:[function(require,module,exports){
module.exports = "<div style=\"background:black;height:100%;width:100%;\">\n  <div style=\"position:relative;top: 50%;-webkit-transform: translateY(-50%);-ms-transform: translateY(-50%);transform: translateY(-50%);\">\n      <svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 128 128\" style=\"width:128px;height:128px;display:block;position:relative;left: 50%;-webkit-transform: translateX(-50%);-ms-transform: translateX(-50%);transform: translateX(-50%);\" xml:space=\"preserve\">\n        <g>\n          <path style=\"fill:none;stroke:#FFFFFF;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;\" d=\"M64,55.967L1.5,20.701l14.223,62.696l11.873,10.601L16.819,29.244l4.079,24.204l21.555,15.126l3.713,42.002L64,126.5V55.967z\"/>\n          <path style=\"fill:none;stroke:#FFFFFF;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;\" d=\"M126.5,20.701L64,1.5L1.5,20.701l15.021,8.476L64,11.686l23.507,8.655L39.754,42.286L64,55.967L126.5,20.701z\"/>\n          <path style=\"fill:none;stroke:#FFFFFF;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;\" d=\"M64,109.793l38.989-32.105l3.905-23.793L64,83.405V55.967l62.5-35.266l-13.822,62.696L64,126.5V109.793z\"/>\n        </g>\n      </svg>\n    <div style=\"height:5px;background:white;width:30%;margin-left:auto;margin-right:auto;margin-top:30px;border:white solid 2px;\">\n      <div class=\"x-j3-loader-progress\" style=\"background:lime;height:5px;width:0%;\"/>\n    </div>\n  </div>\n</div>\n"
},{}],318:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],319:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],320:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = require("./gl-matrix/common.js");
exports.mat2 = require("./gl-matrix/mat2.js");
exports.mat2d = require("./gl-matrix/mat2d.js");
exports.mat3 = require("./gl-matrix/mat3.js");
exports.mat4 = require("./gl-matrix/mat4.js");
exports.quat = require("./gl-matrix/quat.js");
exports.vec2 = require("./gl-matrix/vec2.js");
exports.vec3 = require("./gl-matrix/vec3.js");
exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":321,"./gl-matrix/mat2.js":322,"./gl-matrix/mat2d.js":323,"./gl-matrix/mat3.js":324,"./gl-matrix/mat4.js":325,"./gl-matrix/quat.js":326,"./gl-matrix/vec2.js":327,"./gl-matrix/vec3.js":328,"./gl-matrix/vec4.js":329}],321:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;
glMatrix.ENABLE_SIMD = false;

// Capability detection
glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

module.exports = glMatrix;

},{}],322:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
mat2.fromValues = function(m00, m01, m10, m11) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
mat2.set = function(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};


/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
mat2.sub = mat2.subtract;

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
mat2.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

module.exports = mat2;

},{"./common.js":321}],323:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
mat2d.fromValues = function(a, b, c, d, tx, ty) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
mat2d.set = function(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
};

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
mat2d.sub = mat2d.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
mat2d.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
};

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
};

module.exports = mat2d;

},{"./common.js":321}],324:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/*
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && 
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


module.exports = mat3;

},{"./common.js":321}],325:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {
  scalar: {},
  SIMD: {},
};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Transpose the values of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.transpose = function(out, a) {
    var a0, a1, a2, a3,
        tmp01, tmp23,
        out0, out1, out2, out3;

    a0 = SIMD.Float32x4.load(a, 0);
    a1 = SIMD.Float32x4.load(a, 4);
    a2 = SIMD.Float32x4.load(a, 8);
    a3 = SIMD.Float32x4.load(a, 12);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 0,  out0);
    SIMD.Float32x4.store(out, 4,  out1);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 8,  out2);
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Transpse a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Inverts a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.invert = function(out, a) {
  var row0, row1, row2, row3,
      tmp1,
      minor0, minor1, minor2, minor3,
      det,
      a0 = SIMD.Float32x4.load(a, 0),
      a1 = SIMD.Float32x4.load(a, 4),
      a2 = SIMD.Float32x4.load(a, 8),
      a3 = SIMD.Float32x4.load(a, 12);

  // Compute matrix adjugate
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  // Compute matrix determinant
  det   = SIMD.Float32x4.mul(row0, minor0);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
  det   = SIMD.Float32x4.sub(
               SIMD.Float32x4.add(tmp1, tmp1),
               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
  if (!det) {
      return null;
  }

  // Compute matrix inverse
  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
  return out;
}

/**
 * Inverts a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.adjoint = function(out, a) {
  var a0, a1, a2, a3;
  var row0, row1, row2, row3;
  var tmp1;
  var minor0, minor1, minor2, minor3;

  var a0 = SIMD.Float32x4.load(a, 0);
  var a1 = SIMD.Float32x4.load(a, 4);
  var a2 = SIMD.Float32x4.load(a, 8);
  var a3 = SIMD.Float32x4.load(a, 12);

  // Transpose the source matrix.  Sort of.  Not a true transpose operation
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  SIMD.Float32x4.store(out, 0,  minor0);
  SIMD.Float32x4.store(out, 4,  minor1);
  SIMD.Float32x4.store(out, 8,  minor2);
  SIMD.Float32x4.store(out, 12, minor3);
  return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand, must be a Float32Array
 * @param {mat4} b the second operand, must be a Float32Array
 * @returns {mat4} out
 */
mat4.SIMD.multiply = function (out, a, b) {
    var a0 = SIMD.Float32x4.load(a, 0);
    var a1 = SIMD.Float32x4.load(a, 4);
    var a2 = SIMD.Float32x4.load(a, 8);
    var a3 = SIMD.Float32x4.load(a, 12);

    var b0 = SIMD.Float32x4.load(b, 0);
    var out0 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 0, out0);

    var b1 = SIMD.Float32x4.load(b, 4);
    var out1 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 4, out1);

    var b2 = SIMD.Float32x4.load(b, 8);
    var out2 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 8, out2);

    var b3 = SIMD.Float32x4.load(b, 12);
    var out3 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
                        SIMD.Float32x4.add(
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.scalar.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Multiplies two mat4's using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.scalar.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.SIMD.translate = function (out, a, v) {
    var a0 = SIMD.Float32x4.load(a, 0),
        a1 = SIMD.Float32x4.load(a, 4),
        a2 = SIMD.Float32x4.load(a, 8),
        a3 = SIMD.Float32x4.load(a, 12),
        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);

    if (a !== out) {
        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
    }

    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
    SIMD.Float32x4.store(out, 12, t0);

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scalar.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.SIMD.scale = function(out, a, v) {
    var a0, a1, a2;
    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

    a0 = SIMD.Float32x4.load(a, 0);
    SIMD.Float32x4.store(
        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

    a1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(
        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

    a2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(
        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 */
mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateX = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
      out[0]  = a[0];
      out[1]  = a[1];
      out[2]  = a[2];
      out[3]  = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_1 = SIMD.Float32x4.load(a, 4);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateY = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateZ = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) { 
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S; 
    out[2] = (mat[1] - mat[4]) / S; 
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S; 
    out[2] = (mat[8] + mat[2]) / S; 
  } else if (mat[5] > mat[10]) { 
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S; 
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S; 
  } else { 
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};



module.exports = mat4;

},{"./common.js":321}],326:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");
var mat3 = require("./mat3.js");
var vec3 = require("./vec3.js");
var vec4 = require("./vec4.js");

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;

module.exports = quat;

},{"./common.js":321,"./mat3.js":324,"./vec3.js":328,"./vec4.js":329}],327:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

module.exports = vec2;

},{"./common.js":321}],328:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

module.exports = vec3;

},{"./common.js":321}],329:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

module.exports = vec4;

},{"./common.js":321}],330:[function(require,module,exports){
// json5.js
// Modern JSON. See README.md for details.
//
// This file is based directly off of Douglas Crockford's json_parse.js:
// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js

var JSON5 = (typeof exports === 'object' ? exports : {});

JSON5.parse = (function () {
    "use strict";

// This is a function that can parse a JSON5 text, producing a JavaScript
// data structure. It is a simple, recursive descent parser. It does not use
// eval or regular expressions, so it can be used as a model for implementing
// a JSON5 parser in other languages.

// We are defining the function inside of another function to avoid creating
// global variables.

    var at,           // The index of the current character
        lineNumber,   // The current line number
        columnNumber, // The current column number
        ch,           // The current character
        escapee = {
            "'":  "'",
            '"':  '"',
            '\\': '\\',
            '/':  '/',
            '\n': '',       // Replace escaped newlines in strings w/ empty string
            b:    '\b',
            f:    '\f',
            n:    '\n',
            r:    '\r',
            t:    '\t'
        },
        ws = [
            ' ',
            '\t',
            '\r',
            '\n',
            '\v',
            '\f',
            '\xA0',
            '\uFEFF'
        ],
        text,

        renderChar = function (chr) {
            return chr === '' ? 'EOF' : "'" + chr + "'";
        },

        error = function (m) {

// Call error when something is wrong.

            var error = new SyntaxError();
            // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
            error.message = m + " at line " + lineNumber + " column " + columnNumber + " of the JSON5 data. Still to read: " + JSON.stringify(text.substring(at - 1, at + 19));
            error.at = at;
            // These two property names have been chosen to agree with the ones in Gecko, the only popular
            // environment which seems to supply this info on JSON.parse
            error.lineNumber = lineNumber;
            error.columnNumber = columnNumber;
            throw error;
        },

        next = function (c) {

// If a c parameter is provided, verify that it matches the current character.

            if (c && c !== ch) {
                error("Expected " + renderChar(c) + " instead of " + renderChar(ch));
            }

// Get the next character. When there are no more characters,
// return the empty string.

            ch = text.charAt(at);
            at++;
            columnNumber++;
            if (ch === '\n' || ch === '\r' && peek() !== '\n') {
                lineNumber++;
                columnNumber = 0;
            }
            return ch;
        },

        peek = function () {

// Get the next character without consuming it or
// assigning it to the ch varaible.

            return text.charAt(at);
        },

        identifier = function () {

// Parse an identifier. Normally, reserved words are disallowed here, but we
// only use this for unquoted object keys, where reserved words are allowed,
// so we don't check for those here. References:
// - http://es5.github.com/#x7.6
// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
// TODO Identifiers can have Unicode "letters" in them; add support for those.

            var key = ch;

            // Identifiers must start with a letter, _ or $.
            if ((ch !== '_' && ch !== '$') &&
                    (ch < 'a' || ch > 'z') &&
                    (ch < 'A' || ch > 'Z')) {
                error("Bad identifier as unquoted key");
            }

            // Subsequent characters can contain digits.
            while (next() && (
                    ch === '_' || ch === '$' ||
                    (ch >= 'a' && ch <= 'z') ||
                    (ch >= 'A' && ch <= 'Z') ||
                    (ch >= '0' && ch <= '9'))) {
                key += ch;
            }

            return key;
        },

        number = function () {

// Parse a number value.

            var number,
                sign = '',
                string = '',
                base = 10;

            if (ch === '-' || ch === '+') {
                sign = ch;
                next(ch);
            }

            // support for Infinity (could tweak to allow other words):
            if (ch === 'I') {
                number = word();
                if (typeof number !== 'number' || isNaN(number)) {
                    error('Unexpected word for number');
                }
                return (sign === '-') ? -number : number;
            }

            // support for NaN
            if (ch === 'N' ) {
              number = word();
              if (!isNaN(number)) {
                error('expected word to be NaN');
              }
              // ignore sign as -NaN also is NaN
              return number;
            }

            if (ch === '0') {
                string += ch;
                next();
                if (ch === 'x' || ch === 'X') {
                    string += ch;
                    next();
                    base = 16;
                } else if (ch >= '0' && ch <= '9') {
                    error('Octal literal');
                }
            }

            switch (base) {
            case 10:
                while (ch >= '0' && ch <= '9' ) {
                    string += ch;
                    next();
                }
                if (ch === '.') {
                    string += '.';
                    while (next() && ch >= '0' && ch <= '9') {
                        string += ch;
                    }
                }
                if (ch === 'e' || ch === 'E') {
                    string += ch;
                    next();
                    if (ch === '-' || ch === '+') {
                        string += ch;
                        next();
                    }
                    while (ch >= '0' && ch <= '9') {
                        string += ch;
                        next();
                    }
                }
                break;
            case 16:
                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {
                    string += ch;
                    next();
                }
                break;
            }

            if(sign === '-') {
                number = -string;
            } else {
                number = +string;
            }

            if (!isFinite(number)) {
                error("Bad number");
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                delim,      // double quote or single quote
                uffff;

// When parsing for string values, we must look for ' or " and \ characters.

            if (ch === '"' || ch === "'") {
                delim = ch;
                while (next()) {
                    if (ch === delim) {
                        next();
                        return string;
                    } else if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (ch === '\r') {
                            if (peek() === '\n') {
                                next();
                            }
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else if (ch === '\n') {
                        // unescaped newlines are invalid; see:
                        // https://github.com/aseemk/json5/issues/24
                        // TODO this feels special-cased; are there other
                        // invalid unescaped chars?
                        break;
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },

        inlineComment = function () {

// Skip an inline comment, assuming this is one. The current character should
// be the second / character in the // pair that begins this inline comment.
// To finish the inline comment, we look for a newline or the end of the text.

            if (ch !== '/') {
                error("Not an inline comment");
            }

            do {
                next();
                if (ch === '\n' || ch === '\r') {
                    next();
                    return;
                }
            } while (ch);
        },

        blockComment = function () {

// Skip a block comment, assuming this is one. The current character should be
// the * character in the /* pair that begins this block comment.
// To finish the block comment, we look for an ending */ pair of characters,
// but we also watch for the end of text before the comment is terminated.

            if (ch !== '*') {
                error("Not a block comment");
            }

            do {
                next();
                while (ch === '*') {
                    next('*');
                    if (ch === '/') {
                        next('/');
                        return;
                    }
                }
            } while (ch);

            error("Unterminated block comment");
        },

        comment = function () {

// Skip a comment, whether inline or block-level, assuming this is one.
// Comments always begin with a / character.

            if (ch !== '/') {
                error("Not a comment");
            }

            next('/');

            if (ch === '/') {
                inlineComment();
            } else if (ch === '*') {
                blockComment();
            } else {
                error("Unrecognized comment");
            }
        },

        white = function () {

// Skip whitespace and comments.
// Note that we're detecting comments by only a single / character.
// This works since regular expressions are not valid JSON(5), but this will
// break if there are other valid values that begin with a / character!

            while (ch) {
                if (ch === '/') {
                    comment();
                } else if (ws.indexOf(ch) >= 0) {
                    next();
                } else {
                    return;
                }
            }
        },

        word = function () {

// true, false, or null.

            switch (ch) {
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            case 'I':
                next('I');
                next('n');
                next('f');
                next('i');
                next('n');
                next('i');
                next('t');
                next('y');
                return Infinity;
            case 'N':
              next( 'N' );
              next( 'a' );
              next( 'N' );
              return NaN;
            }
            error("Unexpected " + renderChar(ch));
        },

        value,  // Place holder for the value function.

        array = function () {

// Parse an array value.

            var array = [];

            if (ch === '[') {
                next('[');
                white();
                while (ch) {
                    if (ch === ']') {
                        next(']');
                        return array;   // Potentially empty array
                    }
                    // ES5 allows omitting elements in arrays, e.g. [,] and
                    // [,null]. We don't allow this in JSON5.
                    if (ch === ',') {
                        error("Missing array element");
                    } else {
                        array.push(value());
                    }
                    white();
                    // If there's no comma after this value, this needs to
                    // be the end of the array.
                    if (ch !== ',') {
                        next(']');
                        return array;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad array");
        },

        object = function () {

// Parse an object value.

            var key,
                object = {};

            if (ch === '{') {
                next('{');
                white();
                while (ch) {
                    if (ch === '}') {
                        next('}');
                        return object;   // Potentially empty object
                    }

                    // Keys can be unquoted. If they are, they need to be
                    // valid JS identifiers.
                    if (ch === '"' || ch === "'") {
                        key = string();
                    } else {
                        key = identifier();
                    }

                    white();
                    next(':');
                    object[key] = value();
                    white();
                    // If there's no comma after this pair, this needs to be
                    // the end of the object.
                    if (ch !== ',') {
                        next('}');
                        return object;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad object");
        };

    value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

        white();
        switch (ch) {
        case '{':
            return object();
        case '[':
            return array();
        case '"':
        case "'":
            return string();
        case '-':
        case '+':
        case '.':
            return number();
        default:
            return ch >= '0' && ch <= '9' ? number() : word();
        }
    };

// Return the json_parse function. It will have access to all of the above
// functions and variables.

    return function (source, reviver) {
        var result;

        text = String(source);
        at = 0;
        lineNumber = 1;
        columnNumber = 1;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error("Syntax error");
        }

// If there is a reviver function, we recursively walk the new structure,
// passing each name/value pair to the reviver function for possible
// transformation, starting with a temporary root object that holds the result
// in an empty key. If there is not a reviver function, we simply return the
// result.

        return typeof reviver === 'function' ? (function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && typeof value === 'object') {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = walk(value, k);
                        if (v !== undefined) {
                            value[k] = v;
                        } else {
                            delete value[k];
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        }({'': result}, '')) : result;
    };
}());

// JSON5 stringify will not quote keys where appropriate
JSON5.stringify = function (obj, replacer, space) {
    if (replacer && (typeof(replacer) !== "function" && !isArray(replacer))) {
        throw new Error('Replacer must be a function or an array');
    }
    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {
        var value = holder[key];

        // Replace the value with its toJSON value first, if possible
        if (value && value.toJSON && typeof value.toJSON === "function") {
            value = value.toJSON();
        }

        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for
        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).
        if (typeof(replacer) === "function") {
            return replacer.call(holder, key, value);
        } else if(replacer) {
            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {
                return value;
            } else {
                return undefined;
            }
        } else {
            return value;
        }
    };

    function isWordChar(c) {
        return (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            (c >= '0' && c <= '9') ||
            c === '_' || c === '$';
    }

    function isWordStart(c) {
        return (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            c === '_' || c === '$';
    }

    function isWord(key) {
        if (typeof key !== 'string') {
            return false;
        }
        if (!isWordStart(key[0])) {
            return false;
        }
        var i = 1, length = key.length;
        while (i < length) {
            if (!isWordChar(key[i])) {
                return false;
            }
            i++;
        }
        return true;
    }

    // export for use in tests
    JSON5.isWord = isWord;

    // polyfills
    function isArray(obj) {
        if (Array.isArray) {
            return Array.isArray(obj);
        } else {
            return Object.prototype.toString.call(obj) === '[object Array]';
        }
    }

    function isDate(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    var objStack = [];
    function checkForCircular(obj) {
        for (var i = 0; i < objStack.length; i++) {
            if (objStack[i] === obj) {
                throw new TypeError("Converting circular structure to JSON");
            }
        }
    }

    function makeIndent(str, num, noNewLine) {
        if (!str) {
            return "";
        }
        // indentation no more than 10 chars
        if (str.length > 10) {
            str = str.substring(0, 10);
        }

        var indent = noNewLine ? "" : "\n";
        for (var i = 0; i < num; i++) {
            indent += str;
        }

        return indent;
    }

    var indentStr;
    if (space) {
        if (typeof space === "string") {
            indentStr = space;
        } else if (typeof space === "number" && space >= 0) {
            indentStr = makeIndent(" ", space, true);
        } else {
            // ignore space parameter
        }
    }

    // Copied from Crokford's implementation of JSON
    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195
    // Begin
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        meta = { // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    };
    function escapeString(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ?
                c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }
    // End

    function internalStringify(holder, key, isTopLevel) {
        var buffer, res;

        // Replace the value, if necessary
        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);

        if (obj_part && !isDate(obj_part)) {
            // unbox objects
            // don't unbox dates, since will turn it into number
            obj_part = obj_part.valueOf();
        }
        switch(typeof obj_part) {
            case "boolean":
                return obj_part.toString();

            case "number":
                if (isNaN(obj_part) || !isFinite(obj_part)) {
                    return "null";
                }
                return obj_part.toString();

            case "string":
                return escapeString(obj_part.toString());

            case "object":
                if (obj_part === null) {
                    return "null";
                } else if (isArray(obj_part)) {
                    checkForCircular(obj_part);
                    buffer = "[";
                    objStack.push(obj_part);

                    for (var i = 0; i < obj_part.length; i++) {
                        res = internalStringify(obj_part, i, false);
                        buffer += makeIndent(indentStr, objStack.length);
                        if (res === null || typeof res === "undefined") {
                            buffer += "null";
                        } else {
                            buffer += res;
                        }
                        if (i < obj_part.length-1) {
                            buffer += ",";
                        } else if (indentStr) {
                            buffer += "\n";
                        }
                    }
                    objStack.pop();
                    buffer += makeIndent(indentStr, objStack.length, true) + "]";
                } else {
                    checkForCircular(obj_part);
                    buffer = "{";
                    var nonEmpty = false;
                    objStack.push(obj_part);
                    for (var prop in obj_part) {
                        if (obj_part.hasOwnProperty(prop)) {
                            var value = internalStringify(obj_part, prop, false);
                            isTopLevel = false;
                            if (typeof value !== "undefined" && value !== null) {
                                buffer += makeIndent(indentStr, objStack.length);
                                nonEmpty = true;
                                key = isWord(prop) ? prop : escapeString(prop);
                                buffer += key + ":" + (indentStr ? ' ' : '') + value + ",";
                            }
                        }
                    }
                    objStack.pop();
                    if (nonEmpty) {
                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + "}";
                    } else {
                        buffer = '{}';
                    }
                }
                return buffer;
            default:
                // functions and undefined should be ignored
                return undefined;
        }
    }

    // special case...when undefined is used inside of
    // a compound object/array, return null.
    // but when top-level, return undefined
    var topLevelHolder = {"":obj};
    if (obj === undefined) {
        return getReplacedValueOrUndefined(topLevelHolder, '', true);
    }
    return internalStringify(topLevelHolder, '', true);
};

},{}],331:[function(require,module,exports){
/**
 * lodash 4.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],332:[function(require,module,exports){
/**
 * lodash 3.0.8 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array constructors, and
  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isFunction;

},{}],333:[function(require,module,exports){
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
 * as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && objectToString.call(value) == numberTag);
}

module.exports = isNumber;

},{}],334:[function(require,module,exports){
/**
 * lodash 4.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var getPrototypeOf = Object.getPrototypeOf;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) ||
      objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  var Ctor = proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

module.exports = isPlainObject;

},{}],335:[function(require,module,exports){
/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

module.exports = isString;

},{}],336:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;

},{}],337:[function(require,module,exports){
/* eslint-disable no-unused-vars */
'use strict';
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],338:[function(require,module,exports){
(function (process){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.nextTick()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
                deferred.reject(new Error(
                    "Can't get fulfillment value from any promise, all " +
                    "promises were rejected."
                ));
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'))

},{"_process":319}]},{},[315])


//# sourceMappingURL=j3.js.map
